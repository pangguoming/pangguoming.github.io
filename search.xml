<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微服务Spring cloud经验总结系列(初级），第三篇：服务注册与发现 Eureka]]></title>
    <url>%2Fpost%2Fe405e215.html</url>
    <content type="text"></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VuePress]]></title>
    <url>%2Fpost%2F6a25e0e9.html</url>
    <content type="text"><![CDATA[VuePress这篇文章主要是记录自己在使用VuePress过程中所遇到的问题以及如何一步一步的解决问题。 安装vuepress前，请确保你的 Node.js 版本 &gt;= 8 全局安装# 安装 yarn global add vuepress 或者：npm install -g vuepress &lt;span class=&quot;hljs-comment&quot;&gt;# 新建一个 markdown 文件 echo &lt;span class=&quot;hljs-string&quot;&gt;&apos;# Hello VuePress!&apos; &gt; README.md &lt;span class=&quot;hljs-comment&quot;&gt;# 开始写作 vuepress dev . &lt;span class=&quot;hljs-comment&quot;&gt;# 构建静态文件 vuepress build .&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516注意 ：`vuepress dev .`和`vuepress build .`后面的`.`。 ## 在现有项目中安装 &lt;pre&gt;&lt;code class=&quot;hljs dockerfile&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# 将 vuepress 作为一个本地依赖安装 yarn &lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;span class=&quot;bash&quot;&gt; -D vuepress 或者：npm install -D vuepress &lt;span class=&quot;hljs-comment&quot;&gt;# 新建一个 docs 文件夹 mkdir docs &lt;span class=&quot;hljs-comment&quot;&gt;# 新建一个 markdown 文件 echo &lt;span class=&quot;hljs-string&quot;&gt;&apos;# Hello VuePress!&apos; &gt; docs/README.md &lt;span class=&quot;hljs-comment&quot;&gt;# 开始写作 npx vuepress dev docs&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 接着，在 package.json 里加一些脚本: &lt;pre&gt;&lt;code class=&quot;hljs json&quot;&gt;{ &lt;span class=&quot;hljs-attr&quot;&gt;&quot;scripts&quot;: { &lt;span class=&quot;hljs-attr&quot;&gt;&quot;docs:dev&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;vuepress dev docs&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;docs:build&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;vuepress build docs&quot; } }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;1234开始写作 &lt;pre&gt;&lt;code class=&quot;hljs less&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yarn &lt;span class=&quot;hljs-selector-tag&quot;&gt;docs&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:dev 或者：&lt;span class=&quot;hljs-selector-tag&quot;&gt;npm &lt;span class=&quot;hljs-selector-tag&quot;&gt;run &lt;span class=&quot;hljs-selector-tag&quot;&gt;docs&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:dev&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 第一个坑：我的项目就是依赖webpack 3.6.0同时也是用npm安装依赖，然后继续使用npm安装vuepress，然后执行npx vuepress dev docs的时候报错了，上网查了好久也没有解决问题，最后使用yarn安装vuepress成功了。 如果你的现有项目依赖了 webpack 3.x，推荐使用 yarn而不是 npm 来安装 vuepress。 要生成静态的 HTML 文件，运行： &lt;pre&gt;&lt;code class=&quot;hljs less&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yarn &lt;span class=&quot;hljs-selector-tag&quot;&gt;docs&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:build 或者：&lt;span class=&quot;hljs-selector-tag&quot;&gt;npm &lt;span class=&quot;hljs-selector-tag&quot;&gt;run &lt;span class=&quot;hljs-selector-tag&quot;&gt;docs&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:build&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819默认情况下，文件将会被生成在 `.vuepress/dist`，也可以通过 `.vuepress/config.js` 中的 `dest` 字段来修改.以上步骤都成功以后，就可以在浏览器总看到页面了，接下来就是对页面进行布局 ## 主题配置本文是根据VuePress默认主题配置 ### 1.首页在docs文件夹下创建`.vuepress文件夹`和`README.md文件`。(如果以及有了就不要再新建) 根目录下的README.md文件可以当作首页，在文件中加入下面文字： &lt;pre&gt;&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;--- &lt;span class=&quot;hljs-attr&quot;&gt;home: &lt;span class=&quot;hljs-literal&quot;&gt;true &lt;span class=&quot;hljs-attr&quot;&gt;actionText: &lt;span class=&quot;hljs-string&quot;&gt;快速上手 &lt;span class=&quot;hljs-string&quot;&gt;→ &lt;span class=&quot;hljs-attr&quot;&gt;actionLink: &lt;span class=&quot;hljs-string&quot;&gt;/guide/install/install &lt;span class=&quot;hljs-meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 可以根据自己的需要添加、删除、修改，这就完成了首页的布局actionLink: /guide/install/install就是首页后要显示的下一个页面 接下来在docs文件夹中创建guide文件夹(根据自己的需要命名)。这个文件夹中放的是markdown文件，每一个markdown文件对应一个页面。至于页面之间的跳转和页面导航栏和侧边栏布局在config.js文件中设置。VuePress 网站必要的配置文件是 .vuepress/config.js，它应该导出一个 JavaScript 对象： &lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;module.&lt;span class=&quot;hljs-keyword&quot;&gt;exports = { title: &lt;span class=&quot;hljs-string&quot;&gt;&apos;VuePress&apos;, description: &lt;span class=&quot;hljs-string&quot;&gt;&apos;VuePress&apos;, }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456789101112131415对于上述的配置，运行`yarn docs:dev`，你应该能看到一个页面，它包含一个页头，里面包含一个标题和一个搜索框。 ### 2.导航栏可以通过 `themeConfig.nav` 增加一些导航栏链接: &lt;pre&gt;&lt;code class=&quot;hljs groovy&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// .vuepress/config.js module.exports = &#123; &lt;span class=&quot;hljs-symbol&quot;&gt; themeConfig: &#123; &lt;span class=&quot;hljs-symbol&quot;&gt; nav: [ &#123;&lt;span class=&quot;hljs-string&quot;&gt;text: &lt;span class=&quot;hljs-string&quot;&gt;&apos;指南&apos;,&lt;span class=&quot;hljs-string&quot;&gt;link:&lt;span class=&quot;hljs-string&quot;&gt;&apos;/guide/install/install&apos;&#125; ] &#125; &#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 当你提供了一个 items 数组而不是一个单一的 link 时，它将显示为一个 下拉列表 ： &lt;pre&gt;&lt;code class=&quot;hljs groovy&quot;&gt;module.exports = { &lt;span class=&quot;hljs-symbol&quot;&gt; themeConfig: { &lt;span class=&quot;hljs-symbol&quot;&gt; nav: [ { &lt;span class=&quot;hljs-symbol&quot;&gt; text: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Languages&apos;, &lt;span class=&quot;hljs-symbol&quot;&gt; items: [ { &lt;span class=&quot;hljs-string&quot;&gt;text: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Chinese&apos;, &lt;span class=&quot;hljs-string&quot;&gt;link: &lt;span class=&quot;hljs-string&quot;&gt;&apos;/language/chinese/&apos; }, { &lt;span class=&quot;hljs-string&quot;&gt;text: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Japanese&apos;, &lt;span class=&quot;hljs-string&quot;&gt;link: &lt;span class=&quot;hljs-string&quot;&gt;&apos;/language/japanese/&apos; } ] } ] } }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;1234567891011121314151617181920212223 ### 3.侧边栏想要使侧边栏（Sidebar）生效，需要配置 `themeConfig.sidebar` &lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// .vuepress/config.js &lt;span class=&quot;hljs-keyword&quot;&gt;module.&lt;span class=&quot;hljs-keyword&quot;&gt;exports = &#123; themeConfig: &#123; sidebar: [ &#123; title: &lt;span class=&quot;hljs-string&quot;&gt;&apos;开发指南&apos;, collapsable: &lt;span class=&quot;hljs-keyword&quot;&gt;false, &lt;span class=&quot;hljs-comment&quot;&gt;//是否展开 &#125;, [&lt;span class=&quot;hljs-string&quot;&gt;&apos;./guide/install/install&apos;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;安装&apos;], [&lt;span class=&quot;hljs-string&quot;&gt;&apos;./guide/started/started&apos;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;快速上手&apos;], &#123; title: &lt;span class=&quot;hljs-string&quot;&gt;&apos;组件&apos;, collapsable: &lt;span class=&quot;hljs-keyword&quot;&gt;false &#125;, [&lt;span class=&quot;hljs-string&quot;&gt;&apos;./guide/icon/icon&apos;,&lt;span class=&quot;hljs-string&quot;&gt;&apos;icon&apos;], ] &#125; &#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 可以省略 .md 拓展名，同时以 / 结尾的路径将会被视为 */README.md如果想要显示地指定链接的文字，使用一个格式为 [link, text] 的数组。具体配置可以根据官网配置：默认主题配置 这是浏览器显示效果： 现在页面基本也搭建完成，可以在页面之间进行切换。下一步是如何在markdown中使用vue组件，也就是在页面中展示自己的项目。 ## 在markdown中使用Vue 在.vuepress中创建components文件夹。所有在 .vuepress/components 中找到的 *.vue 文件将会自动地被注册为全局的异步组件。 如果需要引入静态文件，可以在.vuepress下新建public文件夹，里面可以放静态文件。 因为本文的案例是展示Icon图标，所有引入了svg.js，svg.js可以在http://www.iconfont.cn/中获取，本文使用## symbol引用具体方法请访问官网。放在public文件夹中，可以在components文件夹中的组件引入。 这是docs文件夹目录结构 &lt;pre&gt;&lt;code class=&quot;hljs css&quot;&gt;. └─ &lt;span class=&quot;hljs-selector-class&quot;&gt;.vuepress └─ &lt;span class=&quot;hljs-selector-tag&quot;&gt;components ├─ &lt;span class=&quot;hljs-selector-tag&quot;&gt;demo-1&lt;span class=&quot;hljs-selector-class&quot;&gt;.vue └─ &lt;span class=&quot;hljs-selector-tag&quot;&gt;Icon └─ &lt;span class=&quot;hljs-selector-tag&quot;&gt;vi-icon&lt;span class=&quot;hljs-selector-class&quot;&gt;.vue&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345可以直接使用这些组件在任意的 Markdown 文件中（组件名是通过文件名取到的）： &lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;demo&lt;span class=&quot;hljs-number&quot;&gt;-1/&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-name&quot;&gt;Icon-vi-icon/&gt; &lt;span class=&quot;hljs-comment&quot;&gt;//文件名和组件名之间同`-`连接&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 完成这一步以后就可以在页面中看到自己的组件在页面中展示了，但是在运行下面命令进行打包的时候会报错：报错原因参考官网文档：浏览器的 API 访问限制 &lt;pre&gt;&lt;code class=&quot;hljs less&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yarn &lt;span class=&quot;hljs-selector-tag&quot;&gt;docs&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:build 或者：&lt;span class=&quot;hljs-selector-tag&quot;&gt;npm &lt;span class=&quot;hljs-selector-tag&quot;&gt;run &lt;span class=&quot;hljs-selector-tag&quot;&gt;docs&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:build&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456解决这个问题只需要在使用Vue组件的`markdown`文件中使用`&lt;ClientOnly&gt;&lt;/ClientOnly&gt;`将组件包裹起来。如： &lt;pre&gt;&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-name&quot;&gt;ClientOnly&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-name&quot;&gt;Icon-vi-icon/&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-name&quot;&gt;ClientOnly&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 注意：在markdown文件中如果需要给组件名缩进，不要用tab键，会被当做markdown语法解析。 浏览器效果图 到这一步，基本上可以在页面中展示自己的组件。下一篇将继续写如何通过Vue组件实现跟：Element相似的效果。通过VuePress管理项目文档(二)]]></content>
      <tags>
        <tag>Vuepress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose安装以及入门]]></title>
    <url>%2Fpost%2Fd4c0a2fe.html</url>
    <content type="text"><![CDATA[Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。## Compose 简介Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multicontainer Docker applications）」，其前身是开源项目 Fig。使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。Compose 中有两个重要的概念： 服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例 项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。可见，一个项目可以由多个服务（容器）关联而成， Compose 面向项目进行管理Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。## 安装与卸载Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景。Docker for Mac 、 Docker for Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。Linux 系统请使用以下介绍的方法安装。### 二进制包安装在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-uname -s-uname -m &gt; /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose1234对于卸载如果是二进制包方式安装的，删除二进制文件即可。 &lt;pre&gt;&lt;code class=&quot;hljs groovy&quot;&gt;sudo rm &lt;span class=&quot;hljs-regexp&quot;&gt;/usr/local&lt;span class=&quot;hljs-regexp&quot;&gt;/bin/docker-compose&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ### PIP 安装这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。执行安装命令： sudo pip install -U docker-compose1234使用PIP安装的时候，卸载可以使用如下命令： &lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;sudo pip uninstall docker-compose&lt;/span&gt;&lt;/code&gt; ## 简单入门下面我们模拟一个网站，该网站的作用是能够记录页面的访问次数。我们使用Flask开发，缓存使用redis ### 编写wen应用新建一个文件夹web，在该文件夹下创建app.py文件，内容如下： from flask import Flask from redis import Redis app = Flask(name) redis = Redis(host=“redis”,port=6379) @app.route(“/“) def hello(): count = redis.incr(‘hits’) return ‘hello world! {}’.format(count) if name == “main“: app.run(host=“0.0.0.0”,debug=True)12345678### 编写Dockerfile文件&lt;pre&gt;&lt;code class=&quot;hljs dockerfile&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;FROM python:&lt;span class=&quot;hljs-number&quot;&gt;3.6-alpine&lt;span class=&quot;hljs-keyword&quot;&gt;ADD&lt;span class=&quot;bash&quot;&gt; . /code&lt;span class=&quot;hljs-keyword&quot;&gt;WORKDIR&lt;span class=&quot;bash&quot;&gt; /code&lt;span class=&quot;hljs-keyword&quot;&gt;RUN&lt;span class=&quot;bash&quot;&gt; pip install redis flask&lt;span class=&quot;hljs-keyword&quot;&gt;CMD&lt;span class=&quot;bash&quot;&gt; [&lt;span class=&quot;hljs-string&quot;&gt;&quot;python&quot;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;app.py&quot;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ### docker-compose.yml编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。 version: ‘3’ services: web: build: . ports: - “5000:5000” redis: images: “redis:alpine”1234### 运行 compose 项目&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;docker-compose up&lt;/code&gt;此时访问本地 5000 端口，每次刷新页面，计数就会加 1。 每天进步一点点]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF.js实现个性化PDF渲染（文本复制）]]></title>
    <url>%2Fpost%2F59d097ac.html</url>
    <content type="text"><![CDATA[我肥来啦😁。看到Redux教程突破3w的浏览量，小窃喜，很高兴自己的文章能够帮助到大家。 这次重返，依然带给大家一个小指南，也是最近工作中遇到的一个小case。 前不久，产品经理提出要在界面上优雅地展示PDF文档，当即就有了两种实现方式： 实现方式一使用embed标记来使用浏览器自带的pdf工具。 这种实现方式优缺点都很明显：优点：自带“打印”，“搜索”，“翻页”等功能，强大且实现方便。缺点：不同浏览器的pdf工具样式不一，且无法满足个性化需求，比如：禁止打印，下载等。 我们的产品经理是挑剔的😒，于是… 实现方式二使用Mozilla的PDF.js，自定义展示PDF。 下面我们就细致讲述一下使用PDF.js过程中遇到的问题。主要包括： 基础功能集成 使用Text-Layers渲染 什么是PDF.JSPDF.js是基于HTML5技术构建的，用于展示可移植文档格式的文件(PDF)，它可以在现代浏览器中使用且无需安装任何第三方插件。 基础功能集成1️⃣引用 首先，引用PDF.js就遇到了问题，官网中提到通过CDN引用或者下载源码至本地。而我们并不想污染我们的index.html并且希望可以对每一个引用的框架有统一的版本管理。于是，我们搜寻到一个包：pdfjs-dist。 通过npm install pdfjs-dist，我们引入了PDF.js。 基础功能有两个必须引用的文件： pdf.js pdf.worker.js 如果使用CDN的方式，直接引用如下对应文件即可： https://mozilla.github.io/pdf… https://mozilla.github.io/pdf… 如果使用npm的方式，则在需要使用PDF.js的文件中如下引用: import PDFJS from ‘pdfjs-dist’; PDFJS.GlobalWorkerOptions.workerSrc = &lt;span class=&quot;hljs-string&quot;&gt;&apos;pdfjs-dist/build/pdf.worker.js&apos;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456789101112这两个文件包含了获取、解析和展示PDF文档的方法，但是解析和渲染PDF需要较长的时间，可能会阻塞其它JS代码的运行。为解决该问题，pdf.js依赖了HTML5引入的[Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)——通过从主线程中移除大量CPU操作（如解析和渲染）来提升性能。PDF.js的API都会返回一个Promise，使得我们可以优雅的处理异步操作。2️⃣**使用**首先，我们需要在HTML中添加`&lt;canvas&gt;`元素以渲染PDF： &lt;pre class=&quot;xml hljs&quot;&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-name&quot;&gt;canvas &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;pdf-canvas&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-name&quot;&gt;canvas&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 然后添加渲染PDF的js代码： &lt;pre class=&quot;javascript hljs&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var url = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Helloworld.pdf&apos;; PDFJS.getDocument(url).then(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;pdf) =&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return pdf.getPage(&lt;span class=&quot;hljs-number&quot;&gt;1); }).then(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;page) =&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;// 设置展示比例 &lt;span class=&quot;hljs-keyword&quot;&gt;var scale = &lt;span class=&quot;hljs-number&quot;&gt;1.5; &lt;span class=&quot;hljs-comment&quot;&gt;// 获取pdf尺寸 &lt;span class=&quot;hljs-keyword&quot;&gt;var viewport = page.getViewport(scale); &lt;span class=&quot;hljs-comment&quot;&gt;// 获取需要渲染的元素 &lt;span class=&quot;hljs-keyword&quot;&gt;var canvas = &lt;span class=&quot;hljs-built_in&quot;&gt;document.getElementById(&lt;span class=&quot;hljs-string&quot;&gt;&apos;pdf-canvas&apos;); &lt;span class=&quot;hljs-keyword&quot;&gt;var context = canvas.getContext(&lt;span class=&quot;hljs-string&quot;&gt;&apos;2d&apos;); canvas.height = viewport.height; canvas.width = viewport.width; &lt;span class=&quot;hljs-keyword&quot;&gt;var renderContext = { &lt;span class=&quot;hljs-attr&quot;&gt;canvasContext: context, &lt;span class=&quot;hljs-attr&quot;&gt;viewport: viewport }; page.render(renderContext); });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456789101112131415161718192021222324现在，PDF已经成功渲染在界面上了。我们来分析一下使用到的函数：`getDocument()`：用于异步获取PDf文档，发送多个Ajax请求以块的形式下载文档。它返回一个Promise，该Promise的成功回调传递一个对象，该对象包含PDF文档的信息，该回调中的代码将在完成PDf文档获取时执行。`getPage()`：用于获取PDF文档中的各个页面。`getViewport()`：针对提供的展示比例，返回PDf文档的页面尺寸。`render()`：渲染PDF。到这里，基本功能告一段落了。 满心欢喜准备上线的时候，产品经理提出了另一个需求：文本复制。 然鹅。。。翻了好几遍官方文档，也没有找到文本复制的方法，并且stackoverflow上有很多类似的问题。 在不断的尝试下，我们发现了`Text-Layer`。 #### 使用Text-Layers渲染PDF.js支持在使用Canvas渲染的PDF页面上渲染文本图层。然而，这个功能需要用到额外的两个文件：`text_layer_builder.js`和`text_layer_builder.css`。我们可以在GitHub的repo中获取到。如果是使用npm，则需要做如下引用： &lt;pre class=&quot;javascript hljs&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import &#123; TextLayerBuilder &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;&apos;pdfjs-dist/web/pdf_viewer&apos;; &lt;span class=&quot;hljs-keyword&quot;&gt;import &lt;span class=&quot;hljs-string&quot;&gt;&apos;pdfjs-dist/web/pdf_viewer.css&apos;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 现在，我们开始实现文本复制功能。 首先，创建渲染需要用到DOM节点： &lt;pre class=&quot;xml hljs&quot;&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-name&quot;&gt;div &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;container&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456789101112131415161718192021222324252627282930313233343536373839`div#container`为最外层节点，在该div中，我们会为PDF的每个页面创建自己的`div`，在每个页面的`div`中，都会有`Canvas`元素。接着，我们修改JS代码： &lt;pre class=&quot;javascript hljs&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var container, pageDiv; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;getPDF(&lt;span class=&quot;hljs-params&quot;&gt;url) &#123; PDFJS.getDocument(url).then(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;pdf) =&gt; &#123; pdfDoc = pdf; container = &lt;span class=&quot;hljs-built_in&quot;&gt;document.getElementById(&lt;span class=&quot;hljs-string&quot;&gt;&apos;container&apos;); &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;var i = &lt;span class=&quot;hljs-number&quot;&gt;1; i&lt;= pdf.numPages; i++) &#123; renderPDF(i); &#125; &#125;) &#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-title&quot;&gt;renderPDF(&lt;span class=&quot;hljs-params&quot;&gt;num) &#123; pdf.getPage(num).then(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;page) =&gt; &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;var scale = &lt;span class=&quot;hljs-number&quot;&gt;1.5; &lt;span class=&quot;hljs-keyword&quot;&gt;var viewport = page.getViewport(scale); pageDiv = &lt;span class=&quot;hljs-built_in&quot;&gt;document.createElement(&lt;span class=&quot;hljs-string&quot;&gt;&apos;div&apos;); pageDiv.setAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&apos;id&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;page-&apos; + (page.pageIndex + &lt;span class=&quot;hljs-number&quot;&gt;1)); pageDiv.setAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&apos;style&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;position: relative&apos;); container.appendChild(pageDiv); &lt;span class=&quot;hljs-keyword&quot;&gt;var canvas = &lt;span class=&quot;hljs-built_in&quot;&gt;document.createElement(&lt;span class=&quot;hljs-string&quot;&gt;&apos;canvas&apos;); pageDiv.appendChild(canvas); &lt;span class=&quot;hljs-keyword&quot;&gt;var context = canvas.getContext(&lt;span class=&quot;hljs-string&quot;&gt;&apos;2d&apos;); canvas.height = viewport.height; canvas.width = view.width; &lt;span class=&quot;hljs-keyword&quot;&gt;var renderContext = &#123; &lt;span class=&quot;hljs-attr&quot;&gt;canvasContext: context, &lt;span class=&quot;hljs-attr&quot;&gt;viewport: viewport &#125;; page.render(renderContext); &#125;); &#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 以上代码只是实现了多页渲染，接下来，开始渲染文本图层。我们需要将page.render(renderContext)修改为以下代码： &lt;pre class=&quot;javascript hljs&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;page.render(renderContext).then(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;() =&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return page.getTextContent(); }).then(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;textContent) =&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;// 创建文本图层div &lt;span class=&quot;hljs-keyword&quot;&gt;const textLayerDiv = &lt;span class=&quot;hljs-built_in&quot;&gt;document.createElement(&lt;span class=&quot;hljs-string&quot;&gt;&apos;div&apos;); textLayerDiv.setAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&apos;class&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;textLayer&apos;); &lt;span class=&quot;hljs-comment&quot;&gt;// 将文本图层div添加至每页pdf的div中 pageDiv.appendChild(textLayerDiv); &lt;span class=&quot;hljs-comment&quot;&gt;// 创建新的TextLayerBuilder实例 &lt;span class=&quot;hljs-keyword&quot;&gt;var textLayer = &lt;span class=&quot;hljs-keyword&quot;&gt;new TextLayerBuilder({ &lt;span class=&quot;hljs-attr&quot;&gt;textLayerDiv: textLayerDiv, &lt;span class=&quot;hljs-attr&quot;&gt;pageIndex: page.pageIndex, &lt;span class=&quot;hljs-attr&quot;&gt;viewport: viewport }); textLayer.setTextContent(textContent); textLayer.render(); });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;``` 我们依旧来讲解以下用到的几个关键函数： page.render()：该函数返回一个当PDF页面成功渲染到界面上时解析的promise，我们可以使用成功回调来渲染文本图层。 page.getTextContent()：该函数的成功回调会返回PDF页面上的文本片段。 TextLayerBuilder：该类的实例有两个重要的方法。setTextContent()用于设置page.getTextContent()函数返回的文本片段；render()用于渲染文本图层。 Bingo😎！通过以上改造，文本复制功能就实现了。官方文档上可没有这个小技巧哦。 PDF.js是一个很棒的工具，但无奈文档写的较为精简，需要开发人员不断探索PDF.js的强大功能。 如果这篇文章有帮助到您，记得点赞咯👍！]]></content>
      <tags>
        <tag>pdf.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超详细动手搭建一个Vuepress站点及开启PWA与自动部署]]></title>
    <url>%2Fpost%2F67684c56.html</url>
    <content type="text"><![CDATA[# 超详细动手搭建一个Vuepress站点及开启PWA与自动部署&gt; 五一之前就想写一篇关于Vuepress的文章,结果朋友结婚就不了了之了。&gt;&gt; 记得最后一定要看注意事项！## Vuepress介绍官网：https://vuepress.vuejs.org/类似hexo一个极简的静态网站生成器,用来写技术文档不能在爽。当然搭建成博客也不成问题。## Vuepress特点 响应式,也可以自定义主题与hexo类似 内置markdown(还增加了一些扩展),并且可以在其使用Vue组件 Google Analytics 集成 PWA 自动生成Service Worker## 快速上手### 安装初始化项目yarn init -y # 或者 npm init -y 123456安装vuepress &lt;pre class=&quot;hljs shell&quot;&gt;&lt;code class=&quot;shell&quot;&gt;yarn add -D vuepress &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;bash&quot;&gt; 或者 npm install -D vuepress &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;全局安装vuepress yarn global add vuepress # 或者 npm install -g vuepress 12345新建一个docs文件夹 &lt;pre class=&quot;hljs shell&quot;&gt;&lt;code class=&quot;shell&quot;&gt;mkdir docs &lt;/code&gt;设置下package.json { “scripts”: { “docs:dev”: “vuepress dev docs”, “docs:build”: “vuepress build docs” } } 12345### 写作&lt;pre class=&quot;hljs shell&quot;&gt;&lt;code class=&quot;shell&quot;&gt;yarn docs:dev # 或者：npm run docs:dev&lt;/code&gt;也就是运行开发环境,直接去docs文件下书写文章就可以,打开http://localhost:8080/可以预览 image ### 构建build生成静态的HTML文件,默认会在 .vuepress/dist 文件夹下 yarn docs:build # 或者：npm run docs:build 1234567891011121314151617 ## 基本配置在 `.vuepress`目录下新建一个`config.js`,他导出一个对象一些配置可以参考[官方文档](https://link.jianshu.com?t=https%3A%2F%2Fvuepress.vuejs.org%2Fconfig%2F%23base),这里我配置常用及必须配置的 ### 网站信息 &lt;pre class=&quot;hljs javascript&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module.exports = &#123; &lt;span class=&quot;hljs-attr&quot;&gt;title: &lt;span class=&quot;hljs-string&quot;&gt;&apos;游魂的文档&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;description: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Document library&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;head: [ [&lt;span class=&quot;hljs-string&quot;&gt;&apos;link&apos;, &#123; &lt;span class=&quot;hljs-attr&quot;&gt;rel: &lt;span class=&quot;hljs-string&quot;&gt;&apos;icon&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;href: &lt;span class=&quot;hljs-string&quot;&gt;`/favicon.ico` &#125;], ], &#125; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ### 导航栏配置 module.exports = { themeConfig: { nav: [ { text: ‘主页’, link: ‘/‘ }, { text: ‘前端规范’, link: ‘/frontEnd/‘ }, { text: ‘开发环境’, link: ‘/development/‘ }, { text: ‘学习文档’, link: ‘/notes/‘ }, { text: ‘游魂博客’, link: ‘https://www.iyouhun.com&#39; }, // 下拉列表的配置 { text: ‘Languages’, items: [ { text: ‘Chinese’, link: ‘/language/chinese’ }, { text: ‘English’, link: ‘/language/English’ } ] } ] } } 12345678910111213141516171819202122如图： &lt;div class=&quot;image-package&quot;&gt; &lt;div class=&quot;image-container&quot;&gt; &lt;div class=&quot;image-container-fill&quot;&gt; &lt;div class=&quot;image-view&quot; data-width=&quot;556&quot; data-height=&quot;83&quot;&gt;![](http://pangguoming.com/blog/images/d0397c5a-09c6-4d33-bdd8-fd95ecb6d468.jpg) &lt;div class=&quot;image-caption&quot;&gt;image ### 侧边栏配置可以省略`.md`扩展名,同时以 `/` 结尾的路径将会被视为 `*/README.md` &lt;pre class=&quot;hljs javascript&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module.exports = &#123; &lt;span class=&quot;hljs-attr&quot;&gt;themeConfig: &#123; &lt;span class=&quot;hljs-attr&quot;&gt;sidebar: &#123; &lt;span class=&quot;hljs-string&quot;&gt;&apos;/frontEnd/&apos;: genSidebarConfig(&lt;span class=&quot;hljs-string&quot;&gt;&apos;前端开发规范&apos;), &#125; &#125; &#125; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;上面封装的genSidebarConfig函数 function genSidebarConfig(title) { return [{ title, collapsable: false, children: [ ‘’, ‘html-standard’, ‘css-standard’, ‘js-standard’, ‘git-standard’ ] }] } 12345678910111213141516171819202122232425262728293031支持侧边栏分组(可以用来做博客文章分类) collapsable是当前分组是否展开 &lt;pre class=&quot;hljs javascript&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module.exports = &#123; &lt;span class=&quot;hljs-attr&quot;&gt;themeConfig: &#123; &lt;span class=&quot;hljs-attr&quot;&gt;sidebar: &#123; &lt;span class=&quot;hljs-string&quot;&gt;&apos;/note&apos;: [ &#123; &lt;span class=&quot;hljs-attr&quot;&gt;title:&lt;span class=&quot;hljs-string&quot;&gt;&apos;前端&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;collapsable: &lt;span class=&quot;hljs-literal&quot;&gt;true, &lt;span class=&quot;hljs-attr&quot;&gt;children:[ &lt;span class=&quot;hljs-string&quot;&gt;&apos;/notes/frontEnd/VueJS组件编码规范&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;/notes/frontEnd/vue-cli脚手架快速搭建项目&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;/notes/frontEnd/深入理解vue中的slot与slot-scope&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;/notes/frontEnd/webpack入门&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;/notes/frontEnd/PWA介绍及快速上手搭建一个PWA应用&apos;, ] &#125;, &#123; &lt;span class=&quot;hljs-attr&quot;&gt;title:&lt;span class=&quot;hljs-string&quot;&gt;&apos;后端&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;collapsable: &lt;span class=&quot;hljs-literal&quot;&gt;true, &lt;span class=&quot;hljs-attr&quot;&gt;children:[ &lt;span class=&quot;hljs-string&quot;&gt;&apos;notes/backEnd/nginx入门&apos;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;notes/backEnd/CentOS如何挂载磁盘&apos;, ] &#125;, ] &#125; &#125; &#125; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;如图： 成品图 ## 默认主题修改 ### 主题色修改在.vuepress目录下的创建一个override.styl文件 $accentColor = #3eaf7c // 主题色 $textColor = #2c3e50 // 文字颜色 $borderColor = #eaecef // 边框颜色 $codeBgColor = #282c34 // 代码背景颜色 123456789 ### 自定义页面类有时需要在不同的页面应用不同的css,可以先在该页面中声明 &lt;pre class=&quot;hljs yaml&quot;&gt;&lt;code class=&quot;yaml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;--- &lt;span class=&quot;hljs-attr&quot;&gt;pageClass: &lt;span class=&quot;hljs-string&quot;&gt;custom-page-class &lt;span class=&quot;hljs-meta&quot;&gt;--- &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;然后在override.styl中书写 .theme-container.custom-page-class { / 特定页面的 CSS / } 1234567891011121314 ## PWA设置设置serviceWorker为true,然后提供Manifest 和 icons,可以参考我之前的《[PWA介绍及快速上手搭建一个PWA应用](https://www.jianshu.com/p/fad8aa9e277f)》 &lt;pre class=&quot;hljs javascript&quot;&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module.exports = &#123; &lt;span class=&quot;hljs-attr&quot;&gt;head: [ [&lt;span class=&quot;hljs-string&quot;&gt;&apos;link&apos;, &#123; &lt;span class=&quot;hljs-attr&quot;&gt;rel: &lt;span class=&quot;hljs-string&quot;&gt;&apos;icon&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;href: &lt;span class=&quot;hljs-string&quot;&gt;`/favicon.ico` &#125;], &lt;span class=&quot;hljs-comment&quot;&gt;//增加manifest.json [&lt;span class=&quot;hljs-string&quot;&gt;&apos;link&apos;, &#123; &lt;span class=&quot;hljs-attr&quot;&gt;rel: &lt;span class=&quot;hljs-string&quot;&gt;&apos;manifest&apos;, &lt;span class=&quot;hljs-attr&quot;&gt;href: &lt;span class=&quot;hljs-string&quot;&gt;&apos;/manifest.json&apos; &#125;], ], &lt;span class=&quot;hljs-attr&quot;&gt;serviceWorker: &lt;span class=&quot;hljs-literal&quot;&gt;true, &#125; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ## 部署上线 ### 设置基础路径在config.js设置base 例如：你想要部署在https://foo.github.io 那么设置base为/,base默认就为/,所以可以不用设置 想要部署在https://foo.github.io/bar/,那么 base 应该被设置成 &quot;/bar/&quot; module.exports = { base: ‘/documents/‘, } 12345678910`base` 将会自动地作为前缀插入到所有以 `/` 开始的其他选项的链接中,所以你只需要指定一次。 ### 构建与自动部署用[gitHub](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com)的pages或者[coding](https://link.jianshu.com?t=https%3A%2F%2Fcoding.net%2Fr%2FO5YOFA)的pages都可以,也可以搭建在自己的服务器上。 将`dist`文件夹中的内容提交到git上或者上传到服务器就好 &lt;pre class=&quot;hljs shell&quot;&gt;&lt;code class=&quot;shell&quot;&gt;yarn docs:build # 或者：npm run docs:build &lt;/code&gt;&gt; 另外可以弄一个脚本,设置持续集成,在每次 push 代码时自动运行脚本deploy.sh #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist # 如果是发布到自定义域名 # echo ‘www.example.com&#39; &gt; CNAME git init git add -A git commit -m ‘deploy’ # 如果发布到 https://.github.io # git push -f git@github.com:/.github.io.git master # 如果发布到 https://.github.io/ git push -f git@github.com:/.git master:gh-pages cd - ` ## 注意事项(坑) 把你想引用的资源都放在.vuepress目录下的public文件夹 给git仓库绑定了独立域名后,记得修改base路径 设置侧边栏分组后默认会自动生成 上/下一篇链接 设置了自动生成侧边栏会把侧边栏分组覆盖掉 * 设置PWA记得开启SSL]]></content>
      <tags>
        <tag>Vuepress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPTP服务端与客户端 修改默认PPTP默认端口1723]]></title>
    <url>%2Fpost%2Fa210281e.html</url>
    <content type="text"><![CDATA[linux pptp服务端：我们在Linux下建立的pptpd端口号默认是1723，有时候这个端口并不是那么的好用，不是麽?所以服务端修改端口号比较简单 修改 /etc/services 文件查找 1723,然后将其修改为你想修改的数值,重启 pptpd即可. Windows PPTP客户端： 1、找到 C:\WINDOWS\system32\drivers\etc，修改services文件，修改里面的VPN（PPTP）端口1723为你设定的端口 2、系统自带的东西，修改配置参数当然就得进注册表了。进入HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE- BFC1-08002bE10318}项，其中有类似0000、0001、0002……这样的子项，每个子项都对应一个网适配器的配置。逐一打开这些子项，找到其中字段DriverDesc值为WAN Miniport (PPTP)的子项，例如我找到的是0003。在这个子项里的TcpPortNumber的值就是pptp vpn所使用的端口，双击修改其值，选择基数为十进制，修改成所需要的值确认即可。重启机器后，修改生效。]]></content>
      <tags>
        <tag>PPTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7防火墙iptables开放常用端口]]></title>
    <url>%2Fpost%2F4b16a513.html</url>
    <content type="text"><![CDATA[清除所有规则： iptables -F12342. 开放常用tcp端口：&lt;pre&gt;&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;iptables &lt;span class=&quot;hljs-selector-tag&quot;&gt;-I &lt;span class=&quot;hljs-selector-tag&quot;&gt;INPUT &lt;span class=&quot;hljs-selector-tag&quot;&gt;-p &lt;span class=&quot;hljs-selector-tag&quot;&gt;tcp &lt;span class=&quot;hljs-selector-tag&quot;&gt;-m &lt;span class=&quot;hljs-selector-tag&quot;&gt;multiport &lt;span class=&quot;hljs-selector-tag&quot;&gt;--dports 20,21,22,3690,80,443,4443,8023,8888,25,110,30000&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:30999 &lt;span class=&quot;hljs-selector-tag&quot;&gt;-j &lt;span class=&quot;hljs-selector-tag&quot;&gt;ACCEPT&lt;span class=&quot;hljs-selector-tag&quot;&gt;iptables &lt;span class=&quot;hljs-selector-tag&quot;&gt;-I &lt;span class=&quot;hljs-selector-tag&quot;&gt;OUTPUT &lt;span class=&quot;hljs-selector-tag&quot;&gt;-p &lt;span class=&quot;hljs-selector-tag&quot;&gt;tcp &lt;span class=&quot;hljs-selector-tag&quot;&gt;-m &lt;span class=&quot;hljs-selector-tag&quot;&gt;multiport &lt;span class=&quot;hljs-selector-tag&quot;&gt;--sports 20,21,22,3690,80,443,4443,8023,8888,25,110,30000&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:30999 &lt;span class=&quot;hljs-selector-tag&quot;&gt;-j &lt;span class=&quot;hljs-selector-tag&quot;&gt;ACCEPT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 3. 开放常用udp端口： &lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;iptables -I INPUT -p udp -m multiport &lt;span class=&quot;hljs-comment&quot;&gt;--dports 53,123,8571,8888 -j ACCEPT iptables -I OUTPUT -p udp -m multiport &lt;span class=&quot;hljs-comment&quot;&gt;--sports 53,123,8571,8888 -j ACCEPT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12344. 开放特殊udp端口（如：dns）：&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;iptables -I INPUT -p udp &lt;span class=&quot;hljs-comment&quot;&gt;--sport 53 -j ACCEPTiptables -I OUTPUT -p udp &lt;span class=&quot;hljs-comment&quot;&gt;--dport 53 -j ACCEPT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 5. 开放vrrp协议： &lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;iptables -I INPUT -p vrrp -j ACCEPT&lt;/span&gt;&lt;/code&gt;12346. 允许服务器互ping：&lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;iptables -A OUTPUT -p icmp -j ACCEPTiptables -A INPUT -p icmp -j ACCEPT&lt;/span&gt;&lt;/code&gt; 7. 允许握手成功的数据通过： &lt;pre&gt;&lt;code class=&quot;hljs perl&quot;&gt;iptables -I INPUT -p tcp -&lt;span class=&quot;hljs-keyword&quot;&gt;m &lt;span class=&quot;hljs-keyword&quot;&gt;state --&lt;span class=&quot;hljs-keyword&quot;&gt;state RELATED,ESTABLISHED -j ACCEPT iptables -I OUTPUT -p tcp -&lt;span class=&quot;hljs-keyword&quot;&gt;m &lt;span class=&quot;hljs-keyword&quot;&gt;state --&lt;span class=&quot;hljs-keyword&quot;&gt;state RELATED,ESTABLISHED -j ACCEPT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123458. 设置默认关闭所有端口：&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;iptables -P FORWARD &lt;span class=&quot;hljs-keyword&quot;&gt;DROPiptables -P &lt;span class=&quot;hljs-keyword&quot;&gt;OUTPUT &lt;span class=&quot;hljs-keyword&quot;&gt;ACCEPTiptables -P &lt;span class=&quot;hljs-keyword&quot;&gt;INPUT &lt;span class=&quot;hljs-keyword&quot;&gt;DROP&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 9. 防syn***： &lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;iptables -N syn-flood iptables -A INPUT -p tcp &lt;span class=&quot;hljs-comment&quot;&gt;--syn -j syn-flood iptables -I syn-flood -p tcp -m limit &lt;span class=&quot;hljs-comment&quot;&gt;--limit 3/s --limit-burst 6 -j RETURN iptables -A syn-flood -j REJECT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345610. 防ddos***：&lt;pre&gt;&lt;code class=&quot;hljs sql&quot;&gt;iptables -A INPUT -i eth0 -p tcp &lt;span class=&quot;hljs-comment&quot;&gt;--syn -m connlimit --connlimit-above 15 -j DROP iptables -A INPUT -p tcp -m state &lt;span class=&quot;hljs-comment&quot;&gt;--state ESTABLISHED,RELATED -j ACCEPTiptables -A INPUT -p tcp &lt;span class=&quot;hljs-comment&quot;&gt;--syn -m limit --limit 12/s --limit-burst 24 -j ACCEPTiptables -A FORWARD -p tcp &lt;span class=&quot;hljs-comment&quot;&gt;--syn -m limit --limit 1/s -j ACCEPT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 11. 防cc***： &lt;pre&gt;&lt;code class=&quot;hljs cs&quot;&gt;iptables -I INPUT -p tcp --dport &lt;span class=&quot;hljs-number&quot;&gt;80 -m connlimit --connlimit-above &lt;span class=&quot;hljs-number&quot;&gt;50 -j REJECT &lt;span class=&quot;hljs-meta&quot;&gt;# 允许单个IP的最大连接数为30 iptables -A INPUT -p tcp --dport &lt;span class=&quot;hljs-number&quot;&gt;80 -m recent --name BAD_HTTP_ACCESS --update --seconds &lt;span class=&quot;hljs-number&quot;&gt;60 --hitcount &lt;span class=&quot;hljs-number&quot;&gt;30 -j REJECT iptables -A INPUT -p tcp --dport &lt;span class=&quot;hljs-number&quot;&gt;80 -m recent --name BAD_HTTP_ACCESS --&lt;span class=&quot;hljs-keyword&quot;&gt;set -j ACCEPT &lt;span class=&quot;hljs-meta&quot;&gt;#单个IP在60秒内只允许最多新建30个连接&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12312. 保存：&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;iptables-save &gt; &lt;span class=&quot;hljs-regexp&quot;&gt;/etc/sysconfig/iptables&lt;/span&gt;&lt;/code&gt; &lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF.js 分片下载的介绍2:分片下载demo]]></title>
    <url>%2Fpost%2F68a72078.html</url>
    <content type="text"><![CDATA[上一个章节，简要说了以下分片下载的几个特性。今天主要用示例说明一下pdf.js分片下载。 服务器环境：php7.2nginx 1.14ubuntu 18.04测试浏览器:谷歌浏览器 70.0.3538.110（ 第一个场景，直接使用pdf 文件1.1 代码如下：注意路径使用的是pdf 文件的物理路径 $filePath = ‘…/doc/big.pdf’;这里是举例，这样作有一个明显的缺点，就是容易被盗链getDocument 方法中的 rangeChunkSize 参数，就是设置分块大小，默认是64k,可以修改这个数字，来改变这个例子使用的 1664k ,1m 左右来分片，方便测试。您可以根据具体情况，来调整PDFJS.getDocument({url:url,rangeChunkSize:6553616,disableAutoFetch:0}). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;html&gt; &lt;head&gt;&lt;title&gt;pdf.js展示1，上一页，下一页&lt;/title&gt;&lt;/head&gt; &lt;h1&gt;PDF.js Previous/Next example&lt;/h1&gt; &lt;div&gt; &lt;button id=&quot;prev&quot;&gt;Previous&lt;/button&gt; &lt;button id=&quot;next&quot;&gt;Next&lt;/button&gt; &lt;span&gt;Page: &lt;span id=&quot;page_num&quot;&gt;&lt;/span&gt; / &lt;span id=&quot;page_count&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &lt;canvas id=&quot;the-canvas&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;../js/pdfjs/pdf.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/pdfjs/pdf.worker.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var url = &apos;../doc/big.pdf&apos;; var pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null, scale = 0.8, canvas = document.getElementById(&apos;the-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); /** * Get page info from document, resize canvas accordingly, and render page. * @param num Page number. */ function renderPage(num) &#123; pageRendering = true; // Using promise to fetch the page pdfDoc.getPage(num).then(function (page) &#123; var viewport = page.getViewport(scale); canvas.height = viewport.height; canvas.width = viewport.width; // Render PDF page into canvas context var renderContext = &#123; canvasContext: ctx, viewport: viewport &#125;; var renderTask = page.render(renderContext); // Wait for rendering to finish renderTask.promise.then(function () &#123; pageRendering = false; if (pageNumPending !== null) &#123; // New page rendering is pending renderPage(pageNumPending); pageNumPending = null; &#125; &#125;); &#125;); // Update page counters document.getElementById(&apos;page_num&apos;).textContent = num; &#125; /** * If another page rendering in progress, waits until the rendering is * finised. Otherwise, executes rendering immediately. */ function queueRenderPage(num) &#123; if (pageRendering) &#123; pageNumPending = num; &#125; else &#123; renderPage(num); &#125; &#125; /** * Displays previous page. */ function onPrevPage() &#123; if (pageNum &lt;= 1) &#123; return; &#125; pageNum--; queueRenderPage(pageNum); &#125; document.getElementById(&apos;prev&apos;).addEventListener(&apos;click&apos;, onPrevPage); /** * Displays next page. */ function onNextPage() &#123; if (pageNum &gt;= pdfDoc.numPages) &#123; return; &#125; pageNum++; queueRenderPage(pageNum); &#125; document.getElementById(&apos;next&apos;).addEventListener(&apos;click&apos;, onNextPage); /** * Asynchronously downloads PDF. */ PDFJS.getDocument(&#123;url:url,rangeChunkSize:65536*16,disableAutoFetch:0&#125;).then(function(pdfDoc_) &#123; pdfDoc = pdfDoc_; document.getElementById(&apos;page_count&apos;).textContent = pdfDoc.numPages; // Initial/first page rendering renderPage(pageNum); &#125;); &lt;/script&gt; &lt;/html&gt; 1.2今天第一加载：发现没有出现分片效果。如果您也遇到这种情况，不要着急，很大程度是因为浏览器缓存1.3 在浏览器中，安Ctrl+alt+delte 键，清除缓存 1.4 清除缓存后，再次刷新页面，发现分片下载功能出现了。 123456789101112131415&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;后台代码 &lt;?php$filePath = &apos;../doc/big.pdf&apos;;//普通的方式处理包装pdf文件 download_file($filePath);function download_file($file, $fname = &apos;chunk.pdf&apos;)&#123; header(&quot;Content-Type: application/octet-stream&quot;); header(&quot;Content-Disposition: attachment;filename=$fname&quot;); echo(file_get_contents($file));&#125; 前台js 调用代码 123456789101112&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt; 。。。。。 var url = &apos;download.php&apos;; var pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null, scale = 0.8, canvas = document.getElementById(&apos;the-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;);。。。。 2.2 经过清理缓存，发现无法达到分片的效果。 初步总结如下，常规的附件处理方式，会影响分片下载的效果 ## 场景3：使用php 结合httprange,实现分片的效果 3.1 这里是从网上搜集到的分片下载php 函数 代码的核心是，增加head 头，开启分片 Header(“Accept-Ranges: bytes”); 至于 Http range 如何计算，就比较繁琐了，这里就不详细介绍了。有兴趣的可以去百度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;?php$filePath = &apos;../doc/big.pdf&apos;;//分片下载chunk_download_file($filePath);/** * 分篇下载的汉书 * * @param $file * @param $fname */function chunk_download_file($file, $fname = &apos;chunk.pdf&apos;)&#123; $fhandle = fopen($file, &apos;rb&apos;);//文件句柄 $fsize = filesize($file);//文件大小 //断点续传和整个文件下载的判断，支持多段下载 if (!empty($_SERVER[&apos;HTTP_RANGE&apos;])) &#123; $range = str_replace(&quot;=&quot;, &quot;-&quot;, $_SERVER[&apos;HTTP_RANGE&apos;]); $match = explode(&quot;-&quot;, $range); $start = $match[1]; $end = !empty($match[2]) ? $match[2] : $fsize - 1; &#125; else &#123; $start = 0; $end = $fsize - 1; &#125; if (($end - $start) &lt; ($fsize - 1)) &#123; fseek($fhandle, $start); header(&quot;HTTP/1.1 206 Partial Content&quot;); header(&quot;Content-Length: &quot; . ($end - $start + 1)); header(&quot;Content-Range: bytes &quot; . $start . &quot;-&quot; . $end . &quot;/&quot; . $fsize); &#125; else &#123; header(&quot;HTTP/1.1 200 OK&quot;); header(&quot;Content-Length: $fsize&quot;); Header(&quot;Accept-Ranges: bytes&quot;); header(&quot;Content-Range: bytes &quot; . $start . &quot;-&quot; . $end . &quot;/&quot; . $fsize); &#125; header(&quot;Content-Type: application/octet-stream&quot;); header(&quot;Content-Disposition: attachment;filename=$fname&quot;); if (!feof($fhandle)) &#123; set_time_limit(0); $buffer = fread($fhandle, $end - $start + 1); echo $buffer; flush(); ob_flush(); &#125;&#125; demo 下载路径：https://download.csdn.net/download/niedewang/10804164 3.2 清理调浏览器缓存，发现这种方式可以达到分片下载的效果 经过测试，谷歌浏览器支持的很好，如上图所示，截图就是使用的谷歌浏览器。但是firefox 在这种场景下，分片效果不理想。具体原因未知 简要的总结1：前期承诺的demo 放出来了，blog貌似会清理连接地址，不知道是否会删除2：使用pdf 真实文件路径，分片兼容性最好。但是地址容易泄漏3：如果使用php 处理，一般的处理程序，不能达到分片效果。需要结合http range特性，但是不知道什么原因，firefox测试下来，效果不好。谷歌浏览器支持的较好，好消息是谷歌浏览器现在占用量是最大的。 4：后面有时间了，会介绍以下使用 x-sendfile 的方式处理附件，无论性能还是兼容性都比php 处理要好 作者：只看远方来源：CSDN原文：https://blog.csdn.net/niedewang/article/details/84576969版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <tags>
        <tag>pdf.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 JMeter 进行压力测试]]></title>
    <url>%2Fpost%2Ff6aaf7d7.html</url>
    <content type="text"><![CDATA[一.前言压力测试是每一个Web应用程序上线之前都需要做的一个测试，他可以帮助我们发现系统中的瓶颈问题，减少发布到生产环境后出问题的几率；预估系统的承载能力，使我们能根据其做出一些应对措施。所以压力测试是一个非常重要的步骤，下面我带大家来使用一款压力测试工具JMeter。 二.关于JMeterApache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。Apache jmeter 可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，java 对象，数据库和查询，FTP服务器等等）的性能进行测试。它可以用于对服务器、网络或对象模拟繁重的负载来测试它们的强度或分析不同压力类型下的整体性能。你可以使用它做性能的图形分析或在大并发负载测试你的服务器/脚本/对象。 官网：http://jmeter.apache.org/download_jmeter.cgi 这里我选用了 4.0 版本的二进制包：http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip 更多内容介绍 https://baike.baidu.com/item/Jmeter/3104456 三.准备工作 因为JMeter是使用JAVA写的，所以使用JMeter之前，先安装JAVA环境，本文就不讲不如安装JAVA环境了。. JAVA环境变量配置:https://jingyan.baidu.com/article/fd8044fa2c22f15031137a2a.html 解压下载的二进制包，进入bin目录，使用jmeter.bat启动程序。 启动之后会有两个窗口，一个cmd窗口，一个JMeter的 GUI。前面不要忽略CMD窗口的提示信息： JMeter: CMD窗口的提示信息================================================================================ Don’t use GUI mode for load testing !, only for Test creation and Test debugging. For load testing, use NON GUI Mode: jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder] &amp; increase Java Heap to meet your test requirements: Modify current env variable HEAP=”-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m” in the jmeter batch file Check : https://jmeter.apache.org/usermanual/best-practices.html ================================================================================1234上面的意思就是：不要使用GUI运行压力测试，GUI仅用于压力测试的创建和调试；执行压力测试请不要使用GUI。使用下面的命令来执行测试： &lt;pre class=&quot;shell&quot;&gt;&lt;code class=&quot;hljs&quot;&gt; jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]&lt;/code&gt; 并且修改JMeter批处理文件的环境变量：HEAP=&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m&quot; ### 更改语言为中文 官方默认为我们提供了简体中文。通过 【Options】-&gt;【Choose Language】变更为简体中文 ## 四.创建测试 ### 1.创建线程组 在“测试计划”上右键 【添加】–&gt;【Threads(Users)】–&gt;【线程组】。 设置线程数和循环次数。我这里设置线程数为500，循环一次。 ### 2.配置元件 在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP请求默认值】。 配置我们需要进行测试的程序协议、地址和端口 当所有的接口测试的访问域名和端口都一样时，可以使用该元件，一旦服务器地址变更，只需要修改请求默认值即可。 ### 3.构造HTTP请求 在“线程组”右键 【添加-】-&gt;【samlper】–&gt;【HTTP 请求】设置我们需要测试的API的请求路径和数据。我这里是用的json ### 4.添加HTTP请求头 在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP信息头管理器】。 因为我要传输的数据为json，所以设置一个 Content-Type:application/json ### 5.添加断言 在我们刚刚创建的线程组上右键 【添加】–&gt;【断言】–&gt;【响应断言】。 根据响应的数据来判断请求是否正常。我在这里只判断的响应代码是否为200。还可以配置错误信息 ### 6.添加察看结果树 在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【察看结果树】。 直接添加，然后点击运行按钮就可以看到结果了。 ### 7.添加Summary Report 在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【Summary Report】。 直接添加，然后点击运行按钮就可以看到结果了。 为了不引起不必要的争论，隐藏了TPS。此数据不具备任何价值，仅仅为文章演示。 ### 8.测试计划创建完成 记得点保存。 ## 五.执行测试计划 前面我们说过，执行测试计划不能用GUI，需要用命令行来执行。 我这里执行的命令为： &lt;pre class=&quot;shell&quot;&gt;&lt;code class=&quot;hljs&quot;&gt;jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport&lt;/code&gt;``` 说明： testplan/RedisLock.jmx 为测试计划文件路径testplan/result/result.txt 为测试结果文件路径testplan/webreport 为web报告保存路径。 Web报告如下： ## 六.写在最后 线程数量和循环次数将会影响最终的测试报告,请大家多多测试。]]></content>
      <tags>
        <tag>JMeter</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 设置、查看、添加、删除服务的开机启动项]]></title>
    <url>%2Fpost%2Fe5142445.html</url>
    <content type="text"><![CDATA[查看开机启动项 systemctl list-unit-files | grep enable 为服务添加开机启动项 systemctl enable zabbix-server.service 移除开机启动项的服务 [root@localhost bin]# systemctl disable zabbix-server.serviceRemoved symlink /etc/systemd/system/multi-user.target.wants/zabbix-server.service. 减价修改自定义开机启动的脚本 修改 /etc/rc.d/rc.local 这个文件 例如将 apache、mysql、samba、svn 等这些服务的开机自启动问题一起搞定： 123456789101112[root@localhost ~]# vim /etc/rc.d/rc.local #添加以下命令 /usr/sbin/apachectl start /etc/rc.d/init.d/mysqld start /etc/rc.d/init.d/smb start /usr/local/subversion/bin/svnserve -d]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv+python-图片文本倾斜校正]]></title>
    <url>%2Fpost%2Fb2fef61b.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: UTF-8 -*- import numpy as np import cv2 ## 图片旋转 def rotate_bound(image, angle): #获取宽高 (h, w) = image.shape[:2] (cX, cY) = (w // 2, h // 2) # 提取旋转矩阵 sin cos M = cv2.getRotationMatrix2D((cX, cY), -angle, 1.0) cos = np.abs(M[0, 0]) sin = np.abs(M[0, 1]) # 计算图像的新边界尺寸 nW = int((h * sin) + (w * cos)) # nH = int((h * cos) + (w * sin)) nH = h # 调整旋转矩阵 M[0, 2] += (nW / 2) - cX M[1, 2] += (nH / 2) - cY return cv2.warpAffine(image, M, (nW, nH),flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE) ## 获取图片旋转角度 def get_minAreaRect(image): gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) gray = cv2.bitwise_not(gray) thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1] coords = np.column_stack(np.where(thresh &gt; 0)) return cv2.minAreaRect(coords) image_path = &quot;54321.png&quot; image = cv2.imread(image_path) angle = get_minAreaRect(image)[-1] rotated = rotate_bound(image, angle) cv2.putText(rotated, &quot;angle: &#123;:.2f&#125; &quot;.format(angle), (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) # show the output image print(&quot;[INFO] angle: &#123;:.3f&#125;&quot;.format(angle)) cv2.imshow(&quot;imput&quot;, image) cv2.imshow(&quot;output&quot;, rotated) cv2.waitKey(0) 可矫正所有 图片格式包括 png jpg tif等]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos cron 自动执行脚本异常 命令不生效的解决办法]]></title>
    <url>%2Fpost%2F452ebe5d.html</url>
    <content type="text"><![CDATA[办法： 1、sh脚本加入 source /etc/profile 2、非系统命令，要写绝对路径]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后端WebSocket的Tomcat实现]]></title>
    <url>%2Fpost%2Fa6e5ffe4.html</url>
    <content type="text"><![CDATA[一.WebSocket简单介绍 随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。 我们知道，传统的HTTP协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回response结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统Web模式 对于信息变化不频繁的Web应用来说造成的麻烦较小，而对于涉及实时信息的Web应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应 用。在WebSocket规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：轮询（polling）和Comet技术。其实后者本质上也是一种轮询，只不过有所改进。 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。 Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 这两种技术都是基于请求-应答模式，都不算是真正意义上的实时技术；它们的每一次请求、应答，都浪费了一定流量在相同的头部信息上，并且开发复杂度也较大。 伴随着HTML5推出的WebSocket，真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力。WebSocket的工作流程是这 样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小 了很多。本文不详细地介绍WebSocket规范，主要介绍下WebSocket在Java Web中的实现。 JavaEE 7中出了JSR-356:Java API for WebSocket规范。不少Web容器，如Tomcat,Nginx,Jetty等都支持WebSocket。Tomcat从7.0.27开始支持 WebSocket，从7.0.47开始支持JSR-356，下面的Demo代码也是需要部署在Tomcat7.0.47以上的版本才能运行。 二.WebSocket示例2.1.新建JavaWeb测试项目 在pom.xml中添加Jar包依赖 1234561 &lt;dependency&gt;2 &lt;groupId&gt;javax&lt;/groupId&gt;3 &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;4 &lt;version&gt;7.0&lt;/version&gt;5 &lt;scope&gt;provided&lt;/scope&gt;6 &lt;/dependency&gt; 客户端（Web主页）代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 1 &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; 2 &lt;!DOCTYPE html&gt; 3 &lt;html&gt; 4 &lt;head&gt; 5 &lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt; 6 &lt;/head&gt; 7 &lt;body&gt; 8 Welcome&lt;br/&gt;&lt;input id=&quot;text&quot; type=&quot;text&quot;/&gt; 9 &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;10 &lt;hr/&gt;11 &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭WebSocket连接&lt;/button&gt;12 &lt;hr/&gt;13 &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;14 &lt;/body&gt;15 16 &lt;script type=&quot;text/javascript&quot;&gt;17 var websocket = null;18 //判断当前浏览器是否支持WebSocket19 if (&apos;WebSocket&apos; in window) &#123;20 websocket = new WebSocket(&quot;ws://localhost:8080/websocket&quot;);21 &#125;22 else &#123;23 alert(&apos;当前浏览器 Not support websocket&apos;)24 &#125;25 26 //连接发生错误的回调方法27 websocket.onerror = function () &#123;28 setMessageInnerHTML(&quot;WebSocket连接发生错误&quot;);29 &#125;;30 31 //连接成功建立的回调方法32 websocket.onopen = function () &#123;33 setMessageInnerHTML(&quot;WebSocket连接成功&quot;);34 &#125;35 36 //接收到消息的回调方法37 websocket.onmessage = function (event) &#123;38 setMessageInnerHTML(event.data);39 &#125;40 41 //连接关闭的回调方法42 websocket.onclose = function () &#123;43 setMessageInnerHTML(&quot;WebSocket连接关闭&quot;);44 &#125;45 46 //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。47 window.onbeforeunload = function () &#123;48 closeWebSocket();49 &#125;50 51 //将消息显示在网页上52 function setMessageInnerHTML(innerHTML) &#123;53 document.getElementById(&apos;message&apos;).innerHTML += innerHTML + &apos;&lt;br/&gt;&apos;;54 &#125;55 56 //关闭WebSocket连接57 function closeWebSocket() &#123;58 websocket.close();59 &#125;60 61 //发送消息62 function send() &#123;63 var message = document.getElementById(&apos;text&apos;).value;64 websocket.send(message);65 &#125;66 &lt;/script&gt;67 &lt;/html&gt; Java Web后端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 1 package me.gacl.websocket; 2 3 import java.io.IOException; 4 import java.util.concurrent.CopyOnWriteArraySet; 5 6 import javax.websocket.*; 7 import javax.websocket.server.ServerEndpoint; 8 9 /**10 * @ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,11 * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端12 */13 @ServerEndpoint(&quot;/websocket&quot;)14 public class WebSocketTest &#123;15 //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。16 private static int onlineCount = 0;17 18 //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识19 private static CopyOnWriteArraySet&lt;WebSocketTest&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketTest&gt;();20 21 //与某个客户端的连接会话，需要通过它来给客户端发送数据22 private Session session;23 24 /**25 * 连接建立成功调用的方法26 * @param session 可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据27 */28 @OnOpen29 public void onOpen(Session session)&#123;30 this.session = session;31 webSocketSet.add(this); //加入set中32 addOnlineCount(); //在线数加133 System.out.println(&quot;有新连接加入！当前在线人数为&quot; + getOnlineCount());34 &#125;35 36 /**37 * 连接关闭调用的方法38 */39 @OnClose40 public void onClose()&#123;41 webSocketSet.remove(this); //从set中删除42 subOnlineCount(); //在线数减143 System.out.println(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());44 &#125;45 46 /**47 * 收到客户端消息后调用的方法48 * @param message 客户端发送过来的消息49 * @param session 可选的参数50 */51 @OnMessage52 public void onMessage(String message, Session session) &#123;53 System.out.println(&quot;来自客户端的消息:&quot; + message);54 //群发消息55 for(WebSocketTest item: webSocketSet)&#123;56 try &#123;57 item.sendMessage(message);58 &#125; catch (IOException e) &#123;59 e.printStackTrace();60 continue;61 &#125;62 &#125;63 &#125;64 65 /**66 * 发生错误时调用67 * @param session68 * @param error69 */70 @OnError71 public void onError(Session session, Throwable error)&#123;72 System.out.println(&quot;发生错误&quot;);73 error.printStackTrace();74 &#125;75 76 /**77 * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。78 * @param message79 * @throws IOException80 */81 public void sendMessage(String message) throws IOException&#123;82 this.session.getBasicRemote().sendText(message);83 //this.session.getAsyncRemote().sendText(message);84 &#125;85 86 public static synchronized int getOnlineCount() &#123;87 return onlineCount;88 &#125;89 90 public static synchronized void addOnlineCount() &#123;91 WebSocketTest.onlineCount++;92 &#125;93 94 public static synchronized void subOnlineCount() &#123;95 WebSocketTest.onlineCount--;96 &#125;97 &#125; 1.2.运行效果 同时打开Google浏览器和火狐浏览器进行多客户端模拟测试,运行效果如下: 该Demo在Jdk1.7+Tomcat7.0.65下环境测试过,示例项目代码下载 本篇博客的大部分内容转载自http://blog.chenzuhuang.com/archive/28.html,然后在此基础上进行完善,在此对作者表示感谢.]]></content>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5新特性[ Notifications ] 桌面消息]]></title>
    <url>%2Fpost%2F1202d869.html</url>
    <content type="text"><![CDATA[在执行完以上代码后，我们就成功地创建了一个消息框实例，在Chrome下面它最终会显示成这样： 到这里我们已经成功了一半，但能不能正确地显示出这个消息框，最终还取决于用户的授权。鉴于浏览器的安全机制，只有用户同意网页弹出消息通知框，消息通知才能够真正的显示出来。所以现在我们要做的就是申请用户授权。 Notification类提供了一个requestPermission方法，用来请求用户授权，代码如下： 1234Notification.requestPermission(function (permission) &#123; console.log(permission); popNotice();&#125;); 温馨提示：用户一旦没有授权，拒绝，以上方法将不再执行！ 示例demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;桌面消息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--JS代码：--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 判断是否支持Notification if (window.Notification) &#123; //Notification 方法 var popNotice = function () &#123; var notification = new Notification(&quot;Hi，帅哥：&quot;, &#123; body: &apos;可以加你为好友吗？&apos;, //显示消息的内容 icon: &apos;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&apos; //显示消息的缩略图 &#125;); //消息框被点击时被调用 //可以打开相关的视图，同时关闭该消息框等操作 notification.onclick = function () &#123; notification.close(); &#125;; //5秒后关闭消息框 notification.onshow = function () &#123; setTimeout(function () &#123; notification.close(); &#125;, 5000); &#125;; &#125;; if (Notification.permission == &quot;granted&quot;) &#123; //授权 popNotice(); &#125; else if (Notification.permission != &quot;denied&quot;) &#123; //没有授权时询问 Notification.requestPermission(function (permission) &#123; console.log(permission); popNotice(); &#125;); &#125; &#125; else &#123; alert(&apos;浏览器不支持Notification&apos;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos下mysql自动备份(亲测可用)]]></title>
    <url>%2Fpost%2Fb7419eb.html</url>
    <content type="text"><![CDATA[编写sh脚本如下： 123456789101112131415161718192021222324252627#!/bin/bash db_user=&quot;root&quot; db_passwd=&quot;123456&quot; db_name=&quot;test_db&quot; #进入备份目录将之前的移动到old目录 cd /mnt/backup/bakmysql echo &quot;you are in bakmysql directory now&quot; mv test_db* /mnt/backup/bakmysqlold echo &quot;Old databases are moved to bakmysqlold folder&quot; #备份目录 backup_dir=&quot;/mnt/backup/bakmysql&quot; #时间格式 time=$(date +&quot;%Y-%m-%d&quot;) #mysql 备份的命令，注意有空格和没有空格 mysqldump -u$db_user -p$db_passwd $db_name &gt; &quot;$backup_dir/$db_name&quot;-&quot;$time.sql&quot; echo &quot;your database backup successfully completed&quot; #这里将7天之前的备份文件删掉 SevenDays=$(date -d -7day +&quot;%Y-%m-%d&quot;) if [ -f /mnt/backup/bakmysqlold/pashanhu-$SevenDays.sql ] then rm -rf /mnt/backup/bakmysqlold/pashanhu-$SevenDays.sql echo &quot;you have delete 7days ago bak sql file &quot; else echo &quot;7days ago bak sql file not exist &quot; echo &quot;bash complete&quot; fi 然后通过下面命令将脚步加入系统的计划任务 123crontab -e0 2 * * * cd /usr/sbin/ &amp;&amp; ./bakmysql.sh 保存退出以后就可以了。 也许需要重启crontab 启用命令：/sbin/service crond restart 后期更改~结果如下]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows IIS注册asp 此操作系统版本不支持此选项 错误解决方法]]></title>
    <url>%2Fpost%2F785fece0.html</url>
    <content type="text"><![CDATA[更新Win10，原来的IIS站点访问不了，原因是因为IIS 没有.net 4.5,使用网上的aspnet_regiis.exe -i命令，一点都不靠谱，直接提示：C:\WINDOWS\system32&gt;c:\windows\microsoft.net\framework64\v4.0.30319\aspnet_regiis.exe -iMicrosoft (R) ASP.NET RegIIS 版本 4.0.30319.0用于在本地计算机上安装和卸载 ASP.NET 的管理实用工具。版权所有(C) Microsoft Corporation。保留所有权利。开始安装 ASP.NET (4.0.30319.0)。此操作系统版本不支持此选项。管理员应使用“打开或关闭 Windows 功能”对话框、“服务器管理器”管理工具或 dism.exe 命令行工 具安装/卸载包含 IIS8 的 ASP.NET4.5。有关更多详细信息，请参见 http://go.microsoft.com/fwlink/?LinkID=216771。 ASP.NET (4.0.30319.0)安装完毕。后来辗转找到了一篇文章，原文如下：http://www.jb51.net/os/windows/509075.html，利用dism工具 执行下面命令才成功dism /online /enable-feature /featurename:IIS-ISAPIFilterdism /online /enable-feature /featurename:IIS-ISAPIExtensionsdism /online /enable-feature /featurename:IIS-NetFxExtensibility45dism /online /enable-feature /featurename:IIS-ASPNET45作者：天国的声音链接：https://www.jianshu.com/p/7b453b7495d3來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <tags>
        <tag>iis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 初始化硬盘分区、挂载]]></title>
    <url>%2Fpost%2F6b13ee42.html</url>
    <content type="text"><![CDATA[通过命令fdisk-l查看硬盘信息 可以看到有两块硬盘/dev/vda和/dev/vdb，启动vda是系统盘vdb是我们新增的数据盘。 2.执行以下命令，进入fdisk模式，开始对新增数据盘执行分区操作。 fdisk 新增数据盘 以新挂载的数据盘“/dev/xvdb”为例： fdisk /dev/xvdb 回显类似如下信息： 3.输入“n”，按“Enter”，开始新建分区。回显类似如下信息： 表示磁盘有两种分区类型： “p”表示主要分区。 “e”表示延伸分区。 4.以创建一个主要分区为例，输入“p”，按“Enter”，开始创建一个主分区。回显类似如下信息： “Partition number”表示主分区编号，可以选择1-4。 5.以分区编号选择“1”为例，输入主分区编号“1”，按“Enter”。回显类似如下信息 “First sector”表示初始磁柱区域，可以选择2048-20971519，默认为2048。 6.以选择默认初始磁柱编号2048为例，按“Enter”。回显类似如下信息： “Last sector”表示截止磁柱区域，可以选择2048-104857599，默认为104857599。 7.以选择默认截止磁柱编号2104857599为例，按“Enter”。回显类似如下信息： 表示分区完成，即为50GB的数据盘新建了1个分区。 8.输入“p”，按“Enter”，查看新建分区的详细信息。回显类似如下信息： 表示新建分区“/dev/vdb1”的详细信息。 9.输入“w”，按“Enter”，将分区结果写入分区表中。回显类似如下信息： 表示分区创建完成。 10.执行以下命令，将新的分区表变更同步至操作系统。 partprobe 11.执行以下命令，将新建分区文件系统设为系统所需格式。mkfs -t 文件系统格式 /dev/vdb1 以设置文件系统为“ext4”为例： mkfs -t ext4 /dev/vdb1 回显类似如下信息： 格式化需要等待一段时间，请观察系统运行状态，不要退出。 12.执行以下命令，新建挂载点。 mkdir 挂载点 以新建挂载点“/XC”为例： mkdir /XC 13.执行以下命令，将新建分区挂载到12中新建的挂载点下。 mount /dev/vdb1 挂载点 以挂载新建分区至“/XC”为例： mount /dev/vdb1 /XC 14.执行以下命令，查看挂载结果。 df -TH 回显类似如下信息： 表示新建分区“/dev/vdb1”已挂载至“/XC”。 设置开机自动挂载磁盘如果您需要在云服务器系统启动时自动挂载磁盘，不能采用在 /etc/fstab直接指定 /dev/xvdb1的方法，因为云中设备的顺序编码在关闭或者开启云服务器过程中可能发生改变，例如/dev/xvdb1可能会变成/dev/xvdb2。推荐使用UUID来配置自动挂载数据盘。 说明：磁盘的UUID（universally unique identifier）是Linux系统为存储设备提供的唯一的标识字符串。 1.执行如下命令，查询磁盘分区的UUID。blkid 磁盘分区 以查询磁盘分区“/dev/vdb1”的UUID为例： blkid /dev/vdb1 回显类似如下信息： 表示“/dev/vdb1”的UUID。 2.通过vim编辑`/etc/fstab 在末尾增加一行 UUID=f5c5c392-4704-4475-9abc-f6a2e049f2ea /XC ext4 defaults 0 2 保存 3.重启服务器 通过命令df -TH查看磁盘信息 可以看出已经自动挂载了。 开机自动挂载磁盘错误，将会造成无法开机，解决方法，通过单用户模式进入系统，修改挂载配置 vnc单用户模式进入 https://www.west.cn/faq/list.asp?unid=756更改开机自动挂载磁盘配置 https://wenku.baidu.com/view/58c7e1f0f61fb7360b4c6503.html]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用sshfs挂载远程服务器目录]]></title>
    <url>%2Fpost%2F69e8318a.html</url>
    <content type="text"><![CDATA[点击访问原文 您还可以加入全栈技术交流群（QQ群号：254842154） *服务器日志查看，是开发人员和服务器运维人员在工作中经常会遇到的一件事情，只有一台服务器时，比较好办，直接登录服务器使用tail -f file-path 命令就可以实时查看到日志文件的输出。当有负载的需要，服务器多了之后，就会比较麻烦，为了查找一个问题的日志可能需要登录多台服务器。今天给大家介绍一种借助sshfs，非常简单的日志文件挂载方案，可以方便大家查看服务器日志文件。&gt; sshfs介绍sshfs是基于fuse构建的ssh文件系统客户端程序，通过它远程主机的配置无需作任何改变，就可以透过SSH协议来挂载远程文件系统了，非常方便及安全。sshfs的安装，在centOS中的安装命令如下： yum -y install sshfs 1234567891011&gt; 挂载sshfs的远程文件挂载，需要结合ssh免密码登录一起实施。假设现在有A、B、C三台服务器的日志，需要挂载到D服务器。首先需要将D服务器的公钥写入A、B、C三台服务器。配置方法参见我之前的[文章](https://link.jianshu.com?t=http://www.hello1010.com/linux_scp)。把远程服务器的 `/mydata/logs/`目录下的所有文件，挂载到D服务器，在D服务器的`/mydata/logs/`目录下为每个服务器建一个目录。（ip_address_A代表A服务器的ip地址，需要自行替换） &lt;pre class=&quot;hljs ruby&quot;&gt;&lt;code class=&quot;ruby&quot;&gt;/&lt;span class=&quot;hljs-regexp&quot;&gt;/把A服务器的 /mydata&lt;span class=&quot;hljs-regexp&quot;&gt;/logs/ 目录 挂载到 D服务器的 /mydata/logs/A/ 目录 sshfs root@ip_address_A&lt;span class=&quot;hljs-symbol&quot;&gt;:/mydata/logs/ /mydata/logs/A/ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;其他两台服务器的挂载方法一样。挂载成功后，可以使用 mount命令查看挂载情况： mount -l 123456789可以看到挂载的情况： &lt;pre class=&quot;hljs ruby&quot;&gt;&lt;code class=&quot;ruby&quot;&gt;root@ip_address_A&lt;span class=&quot;hljs-symbol&quot;&gt;:/mydata/logs/on /mydata/logs/A type fuse.sshfs (rw,nosuid,nodev) root@ip_address_B&lt;span class=&quot;hljs-symbol&quot;&gt;:/mydata/logs/on /mydata/logs/B type fuse.sshfs (rw,nosuid,nodev) root@ip_address_C&lt;span class=&quot;hljs-symbol&quot;&gt;:/mydata/logs/on /mydata/logs/C type fuse.sshfs (rw,nosuid,nodev) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;也可以使用df -h命令查看磁盘的挂载情况。另外，想要开机自动挂载目录，可以编辑/etc/fstab文件，加入以下几行： sshfs#root@ip_address_A:/mydata/logs/ /mydata/logs/A fuse defaults,auto,allow_other 0 0 sshfs#root@ip_address_B:/mydata/logs/ /mydata/logs/B fuse defaults,auto,allow_other 0 0 sshfs#root@ip_address_C:/mydata/logs/ /mydata/logs/C fuse defaults,auto,allow_other 0 0 1234567其中，`allow_other`参数代表该设置对其他用户也生效。也必须先把ssh自动登录配置好了，让root用户能够使用root身份登录远程主机。配置方法参见我之前的[文章](https://link.jianshu.com?t=http://www.hello1010.com/linux_scp)。挂载成功后，就可以在服务器D直接查看所有服务器的日志了，在D服务器的`/mydata/logs/`目录输入以下命令。（假设A、B、C三台服务器的`/mydata/logs/`目录下都有log.txt这个文件） &lt;pre class=&quot;hljs cpp&quot;&gt;&lt;code class=&quot;cpp&quot;&gt;tail -f */&lt;span class=&quot;hljs-built_in&quot;&gt;log.txt &lt;/span&gt;&lt;/code&gt;日志的输出中，会标出日志是在哪台服务器的，例如： ==&gt; A/log.txt &lt;== get log message from A 12345假如只想查看日志中包含关键字 `a b c`的日志，可以这样查看 &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt; tail -f */log.txt | grep &lt;span class=&quot;hljs-string&quot;&gt;&apos;a b c&apos; &lt;/span&gt;&lt;/code&gt;日志的输出会有一定的延时。 需要注意的是，取消挂载时，不要直接删除挂载目录，请使用以下命令取消挂载： fusermount -u /mydata/logs/A `或者直接使用umount命令取消挂载。作者：hellojammyPlus链接：https://www.jianshu.com/p/cdf5652a88d3來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum install --downloadonly 下载依赖包到本地 但不安装]]></title>
    <url>%2Fpost%2F20abf56c.html</url>
    <content type="text"><![CDATA[如果手动去一个个找依赖是很困难的，即便已经知道名字、版本，下面就依赖系统自带的命令完成该步骤 以java为例，其他安装包只要替换包名 1yum install --downloadonly --downloaddir=/home/java java]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7安装SSHFS 实现远程主机目录 挂载为本地目录]]></title>
    <url>%2Fpost%2F77689e56.html</url>
    <content type="text"><![CDATA[安装sshfs 官方下载地址 https://github.com/libfuse/sshfs/releases 首先，我们需要安装sshfs软件。sshfs是一个基于SSH文件传输协议的文件系统客户端，它的官方网页是：http://fuse.sourceforge.net/sshfs.html 。在CentOS下，我们可以通过yum来安装(注意使用yum安装需要安装EPEL源)： yum -y install fuse-sshfs 安装好后，系统会自动建立fuse用户组，要使用sshfs的用户只要加入这个用户组即可。 挂载远程目录要想挂载远程目录，使用如下命令即可：sshfs user@hostname:path mout_point例如：sshfs root@127.0. 0. 0:/data/www/rabbit/Upload/ /mnt/file_server_storage/mnt/file_server_storage为本地的路径这里user为远程主机用户名，hostname为远程主机IP地址，path为远程主机中想要挂载到本地的目录，mount_point为挂载到本地的目录。 卸载挂载点当不需要使用的时候，使用以下命令卸载：fusermount -u mount_point如果想要开机自动挂载，可以在/etc/fstab中加入下面一行：sshfs#user@hostname:path mount_point fuse defaults,auto,allow_other 0 0这就要求必须先把ssh自动登录配置好了，让root用户能够使用user身份登录远程主机，另外allow_other这个参数很重要，没有这个参数的话，挂载过来的目录只有root能够访问。 以下为实际操作中所遇到的问题1、执行卸载命令：fusermount -u /mnt/file_server_storage 提示device is busy.执行: umount -fl ./file_server_storage 命令可以完成卸载.关于: umount 命令umount可卸除目前挂在Linux目录中的文件系统 2、关于操作操作权限以前经常出现执行挂载命令以后,shell命令可以直接进入挂载点操作，但远程程序一直无法操作成功。后来发现是需要加上-o 参数：执行sshfs –h 会看到如下帮助说明 FUSE options:FUSE（用户空间文件系统）用户空间文件系统（Filesystem in Userspace），是Linux 中用于挂载某些网络空间，如SSH，到本地文件系统的模块，在SourceForge上可以找到相关内容。 sshfs root@127.0. 0. 0:/data/www/rabbit/Upload/ /mnt/file_server_storage//替换为以下命令即可sshfs root@127.0. 0. 0:/data/www/rabbit/Upload/ /mnt/file_server_storage –o allow_other 配合的在/etc下面增加了一个文件fuse.conf在fuse.conf里面就一句话: user_allow_other，保存退出即可。]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7下FTP的安装与配置]]></title>
    <url>%2Fpost%2F495b6e12.html</url>
    <content type="text"><![CDATA[1、安装vsftpd 1[root@localhost modules]# yum install -y vsftpd 2、编辑ftp配置文件1[root@localhost modules]# vi /etc/vsftpd/vsftpd.conf做如下修改：12345678910111213141516anonymous_enable=NO #关闭匿名登录 chroot_local_user=YES #用于指定用户列表文件中的用户是否允许切换到上级目录。默认值为NO。#通过搭配能实现以下几种效果： #①当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。 #②当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。 #③当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。 #④当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。 chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_listallow_writeable_chroot=YES #加上这行解决了无法登陆的问题 3、设置开机启动ftp1[root@localhost modules]# chkconfig vsftpd on4、启动/重新启动ftp服务12[root@localhost modules]# systemctl start vsftpd.service[root@localhost modules]# systemctl restart vsftpd.service5、防火墙配置方法1：1234[root@localhost modules]# vim /etc/sysconfig/iptables-A INPUT -m state –state NEW -m tcp -p tcp –dport 21 -j ACCEPT#增加本行方法2：关闭防火墙12[root@localhost modules]# systemctl stop firewalld.service #停止 [root@localhost modules]# systemctl disable firewalld.service #禁用 6、建立ftp账号1useradd -d /path（你的ftp文件夹） -s /sbin/nologin ftpname（用户名）7、修改密码1passwd ftpname8、设置账户权限12chown -R ftpname.ftpname /path（你的ftp路径）chmod 777 /path9、设置路径运行上传12setsebool -P ftp_home_dir onsetsebool allow_ftpd_full_access on10、重启vsftp服务1systemctl restart vsftpd.service]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>vsftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum离线安装rpm包]]></title>
    <url>%2Fpost%2F2f7a9bc9.html</url>
    <content type="text"><![CDATA[CentOS利用yum下载好rpm包，并离线安装 1、联网安装好rpm包，并将下载好的包备好 #yum install –downloadonly –downloaddir=/home/samba samba 其中samba 是要用yum安装的安装包，/home/samba是要存放下载的yum安装包及其依赖包的保存路径 2、离线的机器上，在rpm所在的文件夹内，执行以下脚本 #rpm -Uvh –force –nodeps *.rpm]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[临时和永久关闭Selinux]]></title>
    <url>%2Fpost%2Ffd1fc922.html</url>
    <content type="text"><![CDATA[临时关闭： [root@localhost ~]# getenforceEnforcing [root@localhost ~]# setenforce 0[root@localhost ~]# getenforcePermissive 永久关闭： [root@localhost ~]# vim /etc/sysconfig/selinux SELINUX=enforcing 改为 SELINUX=disabled 重启服务reboot]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb 字符串查找匹配中$regex的用法]]></title>
    <url>%2Fpost%2Fd22b6090.html</url>
    <content type="text"><![CDATA[官网地址：https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-case-insensitive 举个例子来说：现在有以下集合（官网的例子）： { “_id” : 100, “sku” : “abc123”, “description” : “Single line description.” }{ “_id” : 101, “sku” : “abc789”, “description” : “First line\nSecond line” }{ “_id” : 102, “sku” : “xyz456”, “description” : “Many spaces before line” }{ “_id” : 103, “sku” : “xyz789”, “description” : “Multiple\nline description” } db.collection.find( { sku: /adC/i } );等效于下面这种写法db.collection.find( { sku: { $regex: ‘abC’, $options: ‘i’ } } );以上是个简单的应用。 参数介绍：Option ===== Description参数 i ====== 加了这个参数，表示不区分大小写 参数 m ===== 个人理解这个参数是用来匹配value中有换行符(\n)的情形。还有一个情形是：匹配规则中使用了锚,所谓的锚就是^ 开头, $ 结束比如：db.products.find( { description: { $regex: /^S/, $options: ‘m’ } } )上面匹配规则的意思就是匹配description字段的value值中，以大写S开头的value值。匹配后结果是： { “_id” : 100, “sku” : “abc123”, “description” : “Single line description.” }{ “_id” : 101, “sku” : “abc789”, “description” : “First line\nSecond line” } 可以看出，第二条记录中descriptio的值包含\n换行字符，而他之所以能匹配出来就是因为添加了m 参数。假设没有添加m参数，语句就是 db.products.find( { description: { $regex: /^S/} } 此时匹配结果为 { “_id” : 100, “sku” : “abc123”, “description” : “Single line description.” } 再比如我们连锚都不写也就是去掉^符合，语句变成 db.products.find( { description: { $regex: /S/ } } ) 此时结果为： { “_id” : 100, “sku” : “abc123”, “description” : “Single line description.” }{ “_id” : 101, “sku” : “abc789”, “description” : “First line\nSecond line” } 此时可以分析出m参数的使用场景：应该是为了匹配字段value值中以某个字符开头(^)，或者是某个字符结束($).即便value中包含换行符(\n)也能匹配到。从上例最后例子看出，m参数应该是和锚同时使用才有意思，否则直接去匹配也能匹配出来。说明m是在特殊需求下才使用的！ 参数 s ===== 允许点字符（.）匹配所有的字符，包括换行符。 比如语句： db.products.find( { description: { $regex: /m.*line/, $options: ‘si’ } } ) 匹配value中包含m且之后为任意字符包括换行符并且还包含line字符的字符串。不区分大小写结果为： { “_id” : 102, “sku” : “xyz456”, “description” : “Many spaces before line” }{ “_id” : 103, “sku” : “xyz789”, “description” : “Multiple\nline description” } 如果不加s参数时，语句为： db.products.find( { description: { $regex: /m.*line/, $options: ‘i’ } } ) 结果为： { “_id” : 102, “sku” : “xyz456”, “description” : “Many spaces before line” } 参数 x ====== 官网的大意是忽视空白字符。 作者：山鬼谣me来源：CSDN原文：https://blog.csdn.net/u013066244/article/details/51491556版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32 F103 F407 F429 F767对比图]]></title>
    <url>%2Fpost%2F8c839299.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32型号解读]]></title>
    <url>%2Fpost%2F14fdcc28.html</url>
    <content type="text"><![CDATA[ST意法半导体在牵手ARM后可以说是做的非常成功，抓住了从普通MCU到ARM的市场转变的机会。由于ST公司的STM32系列ARM 使用了完善的库开发，作为芯片的应用者不用从底层的寄存器来实现每个功能的语句编程，直接使用ST的库来完成开发，降低了应用开发的门槛和难度以及开发周期，更多的已经由ST公司做成了库文件。ST的ARM从Cortex™-M0 到Cortex™-M4不断地在推出自己新的产品。在所有这些系列里，STM32 F1系列仍然是目前的主流产品，在大部分控制产品里都可以实现便捷的开发应用，而在性价比上又比较有优势，致芯科技在提供STM32解密的时候，遇到最多需求的也是STM32F1解密的。致芯科技在不断地增加解密的型号，随着使用和市场的需求，致芯科技对大多芯片可以提供逆向分析和代码提取服务。STM32F0入门级Cortex™-M0 MCU意法半导体基于ARM® Cortex-M0的STM32 F0系列实现了32位性能，同时传承了STM32系列的重要特性，特别适于成本敏感型应用。STM32 F0 MCU集实时性能、低功耗运算和与STM32平台相关的先进架构及外设于一身。STM32F030 Value系列在传统8位和16位市场极具竞争力，并可使用户免于不同架构平台迁徙和相关开发带来的额外工作。借助于STM32F0x2系列新增产品，STM32 F0系列通过USB 2.0和CAN也提供了丰富的通信接口，使它成为通信网关、智能能源器件或游戏终端的理想选择。STM32 F1系列主流MCUSTM32 F1系列主流MCU满足了工业、医疗和消费类市场的各种应用需求。凭借该产品系列，意法半导体在全球ARM Cortex-M 微控制器领域处于领先地位，同时树立了嵌入式应用的里程碑。该系列利用一流的外设和低功耗、低压操作实现了高性能，同时还以可接受的价格、利用简单的架构和简便易用的工具实现了高集成度。该系列包含五个产品线，它们的引脚、外设和软件均兼容。 超值型STM32F100 - 24 MHz CPU，具有电机控制和CEC功能 基本型STM32F101 - 36 MHz CPU，具有高达1MB的Flash STM32F102 – 48 MHz CPU具备USB FS 增强型STM32F103 - 72 MHz CPU，具有高达1MB的Flash、电机控制、USB和CAN 互联型STM32F105/107 - 72 MHz CPU，具有以太网MAC、CAN和USB 2.0 OTGSTM32 F2系列高性能MCU基于ARM® Cortex™-M3的STM32 F2系列采用意法半导体先进的90 nm NVM制程制造而成，具有创新型自适应实时存储器加速器（ART加速器™）和多层总线矩阵， 实现了前所未有的高性价比。该系列具有集成度高的特点：整合了1MB Flash存储器、128KBSRAM、以太网MAC、USB 2.0 HS OTG、照相机接口、硬件加密支持和外部存储器接口。意法半导体的加速技术使这些MCU能够在主频为120 MHz 下实现高达150 DMIPS/398 CoreMark的性能，这相当于零等待状态执行，同时还能保持极低的动态电流消耗水平（175 μA/MHz）。带有DSP和FPU指令的STM32 F3系列混合信号MCUSTM32 F3系列具有运行于72 MHz的32位ARM Cortex-M4内核（DSP、FPU）并集成多种模拟外设，从而降低应用成本并简化应用设计，它包括： 快速和超快速比较器（&lt;30 ns） 具有可编程增益的运算放大器（PGA） 12位DAC 超快速12位ADC，单通道每秒5 M次采样（交替模式下可达到每秒18 M次采样） 精确的16位sigma-delta ADC（21通道） 144 MHz的快速电机控制定时器（分辨率 &lt; 7 ns） CCM（内核耦合存储区）是在RAM执行时间关键程序所专用的存储器架构，可将性能提升43%STM32 F3系列MCU与STM32F0和F1系列引脚兼容，具有相同的外设。这保证了在为满足应用需要而优化器件性能时，可缩短设计周期，并在设计后续应用时有卓越的灵活性。STM32 F3系列包括： STM32F301、STM32F302通用器件具有多种外设选项，从基本的低价外设，到更多的模拟功能及USB/CAN接口 STM32F303为全功能产品，能够管理双FOC电机控制，具有CCM – 在RAM执行时间关键程序所专用的存储器架构 STM32F373具有16位sigma-delta ADC，能够在生物识别传感器和智能计量等应用中实现高精度测量 STM32F3x8产品线支持1.8V的工作电压带有DSP和FPU指令的STM32 F4系列高性能MCU基于ARM® Cortex™-M4的STM32 F4系列MCU采用了意法半导体的NVM工艺和ART加速器™，在高达180 MHz的工作频率下通过闪存执行时其处理性能达到225 DMIPS/608 CoreMark，这是迄今所有基于Cortex-M内核的微控制器产品所达到的最高基准测试分数。由于采用了动态功耗调整功能，通过闪存执行时的电流消耗范围为STM32F401的128 μA/MHz到STM32F439的260 μA/MHz。STM32 F4系列包括五条互相兼容的数字信号控制器（DSC）产品线，是MCU实时控制功能与DSP信号处理功能的完美结合体。 STM32F401 – 84 MHz CPU/105 DMIPS，尺寸最小、成本最低的解决方案，具有卓越的功耗效率 STM32F405/415 – 168 MHz CPU/210 DMIPS，高达1MB、具有先进连接功能和加密功能的Flash存储器 STM32F407/417 – 168 MHz CPU/210 DMIPS，高达1MB的闪存（Flash），增加了以太网MAC和照相机接口 STM32F427/437 – 180 MHz CPU/225 DMIPS，高达2MB的双区闪存，具有SDRAM接口、Chrom-ART加速器™、串行音频接口，性能更高，静态功耗更低 * STM32F429/439 – 180 MHz CPU/225 DMIPS，高达2MB的双区闪存，增加了LCD-TFT控制器作为普通客户，当有需要STM32解密的时候，怎么知道自己的芯片是哪个系列，又是多大的存储器的芯片呢，在芯片上的型号都代表什么呢，下图会详细告诉你如何认识STM32 的型号。]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流媒体Red5服务自定义媒体文件路径]]></title>
    <url>%2Fpost%2F3a13c96.html</url>
    <content type="text"><![CDATA[4、 创建类实现自定义媒体访问路径 使用bean对自己的项目进行配置,更换默认的视频播放目录和视频录制目录.在0.6版的时候, 我们可以直接在red5-web.properties中写入playbackPath=mypath/来进行目录定义, 但是D5发现在0.7以后的版本,这样写已经不起作用了.因此到网上查了一下,找到了这篇文章. 文章地址 RED5中文件名的产生控制RED5使用scope服务来对其本身的一些功能进行控制.其中一个scope服务是IStreamFilenameGenerator, 它用来产生点播VOD流或录制流的的文件名.我们可以通过自定义该scope来达到改变默认视频目录的目的. 自己的IStreamFilenameGenerator想要自定义视频目录的路径,我们必须implements一个自己的文件产生器,代码如下 123456789101112131415161718192021222324252627282930313233package org.red5.demos.oflaDemo; import org.red5.server.api.scope.IScope; import org.red5.server.api.stream.IStreamFilenameGenerator; public class CustomFilenameGenerator implements IStreamFilenameGenerator &#123; /** Path that will store recorded videos. */ public String recordPath = &quot;recordedStreams/&quot;; /** Path that contains VOD streams. */ public String playbackPath = &quot;videoStreams/&quot;; /** Set if the path is absolute or relative */ public boolean resolvesAbsolutePath = false; public String generateFilename(IScope scope, String name, GenerationType type) &#123; // Generate filename without an extension. return generateFilename(scope, name, null, type); &#125; public String generateFilename(IScope scope, String name, String extension, GenerationType type) &#123; String filename; if (type == GenerationType.RECORD) filename = recordPath + name; else filename = playbackPath + name; if (extension != null) // Add extension filename += extension; System.out.println(&quot;filename: &quot;+filename); return filename; &#125; &#125; 上述代码所构成的文件发生器,将产生类似recordedStreams/red5RecordDemo1234.flv的视频录制文件以及将videoStreams作为VOD点播的默认目录 修改配置文件另我们的文件管理器生效下一步,我们自定义的文件产生器必须通过配置文件来生效,这样才能对我们的应用产生影响.修改你的项目中WEB-INFO/red5-web.xml 请注意,实际上你的CustomFilenameGenerator肯定是在其他的包中,因此这里我们用path.to.your来表示. 你需要用实际的路径来代替它,例如com.D5Power.CustomFilenameGenerator. 这样一来,你就可以通过我们编写的CustomFilenameGenerator来控制你想要的视频播放目录和录制目录了, 但是对于一个项目来说,这样似乎很麻烦,我们要修改目录的时候总是要去修改源代码,并重新进行编译. 我们需要象原来的0.6版程序一样,只通过配置文件就可以进行配置.这样更方便一些.那么,对我们的代码做一些修改吧. 向CustomFilenameGenerator中增加以下三个方法 123456789101112131415&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;public void setRecordPath(String path) &#123;recordPath = path;&#125;public void setPlaybackPath(String path) &#123;playbackPath = path;&#125;public void setAbsolutePath(Boolean absolute) &#123;resolvesAbsolutePath = absolute;&#125;public boolean resolvesToAbsolutePath() &#123;return resolvesAbsolutePath;&#125; 接下来,把我们的bean的配置代码改成下面这样 123456 &lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;bean id=&quot;streamFilenameGenerator&quot; class=&quot;path.to.your.CustomFilenameGenerator&quot;&gt; &lt;property name=&quot;recordPath&quot; value=&quot;recordedStreams/&quot; /&gt; &lt;property name=&quot;playbackPath&quot; value=&quot;videoStreams/&quot; /&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-name&quot;&gt;property &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;absolutePath&quot; &lt;span class=&quot;hljs-attr&quot;&gt;value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot; /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;/bean&gt; 12当然,你还可以把这两个变量的声明移到你的应用中WEB-INF/red5-web.properties文件中,于是上述代码变成了: &lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;bean id=&quot;streamFilenameGenerator&quot; class=&quot;path.to.your.CustomFilenameGenerator&quot;&gt; &lt;property name=&quot;recordPath&quot; value=&quot;${recordPath}&quot; /&gt; &lt;property name=&quot;playbackPath&quot; value=&quot;${playbackPath}&quot; /&gt; &lt;property name=“absolutePath” value=“true” /&gt;**1&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;/bean&gt; 而在red5-web.properties中多出以下两个变量的声明就可以了 recordPath=recordedStreams/ playbackPath=videoStreams/ 如下所示： recordPath=E:/Red5Medias/playbackPath=E:/Red5Medias/ 可以创建一个演示demo的下面的例子]]></content>
      <tags>
        <tag>red5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 使用rsync 实现文件同步]]></title>
    <url>%2Fpost%2F7dba9b02.html</url>
    <content type="text"><![CDATA[一、服务端（192.168.8.81）： 安装软件： yum -y install rsync12342. 创建需同步的目录：&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;mkdir -p /home/root/rsync&lt;/span&gt;&lt;/code&gt; 编辑配置文件：vim /etc/rsyncd.conf motd file = /etc/rsyncd.motd transfer logging = yes log file = /var/log/rsyncd.log port = 873 address = 192.168.8.81 uid = root gid = root use chroot = no read only = no max connections = 10 [common] comment = rsync lee path = /home/lee/rsync/ ignore errors auth users = lee secrets file = /etc/rsyncd.secrets hosts allow = 192.168.8.0/255.255.255.0 hosts deny = * list = false123454. 创建用户密码：&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;root:123456&quot; &gt; /etc/rsyncd.secrets chmod 600 /etc/rsyncd.secrets&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 配置防火墙规则： iptables -I INPUT -p tcp –dport 873 -j ACCEPT123456. 启动服务：&lt;code class=&quot;hljs ruby&quot;&gt; rsync --daemon echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;rsync --daemon&quot; &lt;span class=&quot;hljs-meta&quot;&gt;&gt;&gt; /etc/rc.local&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ### 二、客户端（192.168.8.82）： 1. 安装软件： &lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;yum -y install rsync&lt;/span&gt;&lt;/code&gt;123&lt;/pre&gt;2. 创建需同步的目录：&lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;mkdir -p /home/root/rsync&lt;/span&gt;&lt;/code&gt; &lt;/pre&gt; 3. 创建密码文件（免输入密码）： &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;123456&quot; &gt; /root/passwd chmod 600 /root/passwd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123&lt;/pre&gt;4. 拉取（在客户端（192.168.8.82））：&lt;pre&gt;&lt;code class=&quot;hljs ruby&quot;&gt;rsync -avz --password-file=&lt;span class=&quot;hljs-regexp&quot;&gt;/root/passwd root@192.&lt;span class=&quot;hljs-number&quot;&gt;168.8.&lt;span class=&quot;hljs-number&quot;&gt;81&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;span class=&quot;hljs-symbol&quot;&gt;:common /home/root/rsync/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; &lt;/pre&gt; 5. 推送（在服务端（192.168.8.81））： &lt;pre&gt;&lt;code class=&quot;hljs ruby&quot;&gt;rsync -avz --password-file=&lt;span class=&quot;hljs-regexp&quot;&gt;/root/passwd /home/root/rsync/ root@192.&lt;span class=&quot;hljs-number&quot;&gt;168.8.&lt;span class=&quot;hljs-number&quot;&gt;81&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;span class=&quot;hljs-symbol&quot;&gt;:common&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;``` &lt;/pre&gt; &lt;div&gt; &lt;div&gt; ### 三、实现定时自动同步 &lt;div&gt; 创建一个需要定时执行的脚本文件，如：rsyncd.sh脚本：vi /etc/rsyncd.sh &lt;div&gt; (路径自己设置的)，在此脚本中添加如下内容 &lt;div&gt; ![](http://pangguoming.com/blog/images/cdc781f8-0bb6-4a3a-bd0f-3b93b0d0c43e.jpg) &lt;div&gt; &lt;div&gt; 设置脚本执行的时间：crontab –e，添加如下内容 &lt;div&gt; ![](http://pangguoming.com/blog/images/e68c8f90-5b28-439e-b467-d87131226256.jpg)&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码常见的十种错误]]></title>
    <url>%2Fpost%2F9613628.html</url>
    <content type="text"><![CDATA[每一个程序员在编写代码的过程中都免不了出现错误或是小的失误，这些小的错误和失误往往使得程序员还得返工。那么，如何才能尽量避免这些错误的发生呢？笔者总结只有在日常的编写代码中总结出经验，在这篇文章中，笔者列出了10个Java编程中常见的错误，你可以把这些错误添加到你的代码审查的检查列表中，这样在经过代码审查后，你可以确信你的代码中不再存在这类错误了。 一、常见错误1：多次拷贝字符串 测试所不能发现的一个错误是生成不可变(immutable)对象的多份拷贝。不可变对象是不可改变的，因此不需要拷贝它。最常用的不可变对象是String。 如果你必须改变一个String对象的内容，你应该使用StringBuffer。下面的代码会正常工作： String s = new String (“Text here”); 但是，这段代码性能差，而且没有必要这么复杂。你还可以用以下的方式来重写上面的代码： String temp = “Text here”; String s = new String (temp); 但是这段代码包含额外的String，并非完全必要。更好的代码为： String s = “Text here”; 二、常见错误2：没有克隆(clone)返回的对象 封装(encapsulation)是面向对象编程的重要概念。不幸的是，Java为不小心打破封装提供了方便——Java允许返回私有数据的引用(reference)。下面的代码揭示了这一点： import java.awt.Dimension; /Example class.The x and y values should neverbe negative./ public class Example{ private Dimension d = new Dimension (0, 0); public Example (){ } / Set height and width. Both height and width must be nonnegative or an exception is thrown./ public synchronized void setValues (int height,int width) throws IllegalArgumentException{ if (height &lt;0 || width &lt;0) throw new IllegalArgumentException(); d.height = height; d.width = width; } public synchronized Dimension getValues(){ // Ooops! Breaks encapsulation return d; } } Example类保证了它所存储的height和width值永远非负数，试图使用setValues()方法来设置负值会触发异常。不幸的是，由于getValues()返回d的引用，而不是d的拷贝，你可以编写如下的破坏性代码： Example ex = new Example(); Dimension d = ex.getValues(); d.height = -5; d.width = -10; 现在，Example对象拥有负值了!如果getValues() 的调用者永远也不设置返回的Dimension对象的width 和height值，那么仅凭测试是不可能检测到这类的错误。 不幸的是，随着时间的推移，客户代码可能会改变返回的Dimension对象的值，这个时候，追寻错误的根源是件枯燥且费时的事情，尤其是在多线程环境中。 更好的方式是让getValues()返回拷贝： public synchronized Dimension getValues(){ return new Dimension (d.x, d.y); } 现在，Example对象的内部状态就安全了。调用者可以根据需要改变它所得到的拷贝的状态，但是要修改Example对象的内部状态，必须通过setValues()才可以。 三、常见错误3：不必要的克隆 我们现在知道了get方法应该返回内部数据对象的拷贝，而不是引用。但是，事情没有绝对： / Example class.The value should never be negative./ public class Example{ private Integer i = new Integer (0); public Example (){ } / Set x. x must be nonnegative or an exception will be thrown/ public synchronized void setValues (int x) throws IllegalArgumentException{ if (x &lt;0) throw new IllegalArgumentException(); i = new Integer (x); } public synchronized Integer getValue(){ // We can’t clone Integers so we makea copy this way. return new Integer (i.intValue()); } } 这段代码是安全的，但是就象在错误1#那样，又作了多余的工作。Integer对象，就象String对象那样，一旦被创建就是不可变的。因此，返回内部Integer对象，而不是它的拷贝，也是安全的。 方法getValue()应该被写为： public synchronized Integer getValue(){ // ’i’ is immutable, so it is safe to return it instead of a copy. return i; } Java程序比C++程序包含更多的不可变对象。JDK 所提供的若干不可变类包括： ·Boolean ·Byte ·Character ·Class ·Double ·Float ·Integer ·Long ·Short ·String ·大部分的Exception的子类 四、常见错误4：自编代码来拷贝数组 Java允许你克隆数组，但是开发者通常会错误地编写如下的代码，问题在于如下的循环用三行做的事情，如果采用Object的clone方法用一行就可以完成： public class Example{ private int[] copy; /** Save a copy of ’data’. ’data’ cannot be null./ public void saveCopy (int[] data){ copy = new int[data.length]; for (int i = 0; i copy[i] = data[i]; } } 这段代码是正确的，但却不必要地复杂。saveCopy()的一个更好的实现是： void saveCopy (int[] data){ try{ copy = (int[])data.clone(); }catch (CloneNotSupportedException e){ // Can’t get here. } } 如果你经常克隆数组，编写如下的一个工具方法会是个好主意： static int[] cloneArray (int[] data){ try{ return(int[])data.clone(); }catch(CloneNotSupportedException e){ // Can’t get here. } } 这样的话，我们的saveCopy看起来就更简洁了： void saveCopy (int[] data){ copy = cloneArray ( data); } 五、常见错误5：拷贝错误的数据 有时候程序员知道必须返回一个拷贝，但是却不小心拷贝了错误的数据。由于仅仅做了部分的数据拷贝工作，下面的代码与程序员的意图有偏差： import java.awt.Dimension; / Example class. The height and width values should never be negative. / public class Example{ static final public int TOTAL_VALUES = 10; private Dimension[] d = new Dimension[TOTAL_VALUES]; public Example (){ } / Set height and width. Both height and width must be nonnegative or an exception will be thrown. / public synchronized void setValues (int index, int height, int width) throws IllegalArgumentException{ if (height &lt;0 || width &lt;0) throw new IllegalArgumentException(); if (d[index] == null) d[index] = new Dimension(); d[index].height = height; d[index].width = width; } public synchronized Dimension[] getValues() throws CloneNotSupportedException{ return (Dimension[])d.clone(); } } 这儿的问题在于getValues()方法仅仅克隆了数组，而没有克隆数组中包含的Dimension对象，因此，虽然调用者无法改变内部的数组使其元素指向不同的Dimension对象，但是调用者却可以改变内部的数组元素(也就是Dimension对象)的内容。方法getValues()的更好版本为： public synchronized Dimension[] getValues() throws CloneNotSupportedException{ Dimension[] copy = (Dimension[])d.clone(); for (int i = 0; i // NOTE: Dimension isn’t cloneable. if (d != null) copy[i] = new Dimension (d[i].height, d[i].width); } return copy; } 在克隆原子类型数据的多维数组的时候，也会犯类似的错误。原子类型包括int,float等。简单的克隆int型的一维数组是正确的，如下所示： public void store (int[] data) throws CloneNotSupportedException{ this.data = (int[])data.clone(); // OK } 拷贝int型的二维数组更复杂些。Java没有int型的二维数组，因此一个int型的二维数组实际上是一个这样的一维数组：它的类型为int[]。简单的克隆int[][]型的数组会犯与上面例子中getValues()方法第一版本同样的错误，因此应该避免这么做。下面的例子演示了在克隆int型二维数组时错误的和正确的做法： public void wrongStore (int[][] data) throws CloneNotSupportedException{ this.data = (int[][])data.clone(); // Not OK! } public void rightStore (int[][] data){ // OK! this.data = (int[][])data.clone(); for (int i = 0; i if (data != null) this.data[i] = (int[])data[i].clone(); } } 六、常见错误6：检查new 操作的结果是否为null Java编程新手有时候会检查new操作的结果是否为null。可能的检查代码为： Integer i = new Integer (400); if (i == null) throw new NullPointerException(); 检查当然没什么错误，但却不必要，if和throw这两行代码完全是浪费，他们的唯一功用是让整个程序更臃肿，运行更慢。 C/C++程序员在开始写java程序的时候常常会这么做，这是由于检查C中malloc()的返回结果是必要的，不这样做就可能产生错误。检查C++中new操作的结果可能是一个好的编程行为，这依赖于异常是否被使能(许多编译器允许异常被禁止，在这种情况下new操作失败就会返回null)。在java 中，new 操作不允许返回null，如果真的返回null，很可能是虚拟机崩溃了，这时候即便检查返回结果也无济于事。 七、常见错误7：用== 替代.equals 在Java中，有两种方式检查两个数据是否相等：通过使用==操作符，或者使用所有对象都实现的.equals方法。原子类型(int, flosat, char 等)不是对象，因此他们只能使用==操作符，如下所示： int x = 4; int y = 5; if (x == y) System.out.println (“Hi”); // This ’if’ test won’t compile. if (x.equals (y)) System.out.println (“Hi”); 对象更复杂些，==操作符检查两个引用是否指向同一个对象，而equals方法则实现更专门的相等性检查。 更显得混乱的是由java.lang.Object 所提供的缺省的equals方法的实现使用==来简单的判断被比较的两个对象是否为同一个。 许多类覆盖了缺省的equals方法以便更有用些，比如String类，它的equals方法检查两个String对象是否包含同样的字符串，而Integer的equals方法检查所包含的int值是否相等。 大部分时候，在检查两个对象是否相等的时候你应该使用equals方法，而对于原子类型的数据，你用该使用==操作符。 八、常见错误8：混淆原子操作和非原子操作 Java保证读和写32位数或者更小的值是原子操作，也就是说可以在一步完成，因而不可能被打断，因此这样的读和写不需要同步。以下的代码是线程安全(thread safe)的： public class Example{ private int value; // More code here… public void set (int x){ // NOTE: No synchronized keyword this.value = x; } } 不过，这个保证仅限于读和写，下面的代码不是线程安全的： public void increment (){ // This is effectively two or three instructions: // 1) Read current setting of ’value’. // 2) Increment that setting. // 3) Write the new setting back. ++this.value; } 在测试的时候，你可能不会捕获到这个错误。首先，测试与线程有关的错误是很难的，而且很耗时间。其次，在有些机器上，这些代码可能会被翻译成一条指令，因此工作正常，只有当在其它的虚拟机上测试的时候这个错误才可能显现。因此最好在开始的时候就正确地同步代码： public synchronized void increment (){ ++this.value; } 九、常见错误9：在catch 块中作清除工作 一段在catch块中作清除工作的代码如下所示： OutputStream os = null; try{ os = new OutputStream (); // Do something with os here. os.close(); }catch (Exception e){ if (os != null) os.close(); } 尽管这段代码在几个方面都是有问题的，但是在测试中很容易漏掉这个错误。下面列出了这段代码所存在的三个问题： 1.语句os.close()在两处出现，多此一举，而且会带来维护方面的麻烦。 2.上面的代码仅仅处理了Exception，而没有涉及到Error。但是当try块运行出现了Error，流也应该被关闭。 3.close()可能会抛出异常。 上面代码的一个更优版本为： OutputStream os = null; try{ os = new OutputStream (); // Do something with os here. }finally{ if (os != null) os.close(); } 这个版本消除了上面所提到的两个问题：代码不再重复，Error也可以被正确处理了。但是没有好的方法来处理第三个问题，也许最好的方法是把close()语句单独放在一个try/catch块中。 十、常见错误10： 增加不必要的catch 块 一些开发者听到try/catch块这个名字后，就会想当然的以为所有的try块必须要有与之匹配的catch块。 C++程序员尤其是会这样想，因为在C++中不存在finally块的概念，而且try块存在的唯一理由只不过是为了与catch块相配对。 增加不必要的catch块的代码就象下面的样子，捕获到的异常又立即被抛出： try{ // Nifty code here }catch(Exception e){ throw e; }finally{ // Cleanup code here } 不必要的catch块被删除后，上面的代码就缩短为： try{ // Nifty code here }finally{ // Cleanup code here } 作者：dumb_man来源：CSDN原文：https://blog.csdn.net/dahailantian1/article/details/78584662?utm_source=copy版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程最差实践（常见编程错误典范）]]></title>
    <url>%2Fpost%2Fa66057ed.html</url>
    <content type="text"><![CDATA[转载自 http://macrochen.iteye.com/blog/1393502 每天在写Java程序，其实里面有一些细节大家可能没怎么注意，这不，有人总结了一个我们编程中常见的问题。虽然一般没有什么大问题，但是最好别这样做。另外这里提到的很多问题其实可以通过Findbugs( http://findbugs.sourceforge.net/ )来帮我们进行检查出来。 字符串连接误用 错误的写法： String s = “”; for (Person p : persons) { s += “, “ + p.getName(); } s = s.substring(2); //remove first comma 正确的写法： StringBuilder sb = new StringBuilder(persons.size() * 16); // well estimated buffer for (Person p : persons) { if (sb.length() &gt; 0) sb.append(“, “); sb.append(p.getName); } 错误的使用StringBuffer 错误的写法： StringBuffer sb = new StringBuffer(); sb.append(“Name: “); sb.append(name + ‘\n’); sb.append(“!”); … String s = sb.toString(); 问题在第三行，append char比String性能要好，另外就是初始化StringBuffer没有指定size，导致中间append时可能重新调整内部数组大小。如果是 JDK1.5最好用StringBuilder取代StringBuffer，除非有线程安全的要求。还有一种方式就是可以直接连接字符串。缺点就是无法 初始化时指定长度。 正确的写法： StringBuilder sb = new StringBuilder(100); sb.append(“Name: “); sb.append(name); sb.append(“\n!”); String s = sb.toString(); 或者这样写： String s = “Name: “ + name + “\n!”; 测试字符串相等性 错误的写法： if (name.compareTo(“John”) == 0) … if (name == “John”) … if (name.equals(“John”)) … if (“”.equals(name)) … 上面的代码没有错，但是不够好。compareTo不够简洁，==原义是比较两个对象是否一样。另外比较字符是否为空，最好判断它的长度。 正确的写法： if (“John”.equals(name)) … if (name.length() == 0) … if (name.isEmpty()) … 数字转换成字符串 错误的写法： “” + set.size() new Integer(set.size()).toString() 正确的写法： String.valueOf(set.size()) 利用不可变对象(Immutable) 错误的写法： zero = new Integer(0); return Boolean.valueOf(“true”); 正确的写法： zero = Integer.valueOf(0); return Boolean.TRUE; 请使用XML解析器 错误的写法： int start = xml.indexOf(““) + ““.length(); int end = xml.indexOf(““); String name = xml.substring(start, end); 正确的写法： SAXBuilder builder = new SAXBuilder(false); Document doc = doc = builder.build(new StringReader(xml)); String name = doc.getRootElement().getChild(“name”).getText(); 请使用JDom组装XML 错误的写法： String name = … String attribute = … String xml = ““ +“&lt;name att=\””+ attribute +“\”&gt;”+ name +““ +““; 正确的写法： Element root = new Element(“root”); root.setAttribute(“att”, attribute); root.setText(name); Document doc = new Documet(); doc.setRootElement(root); XmlOutputter out = new XmlOutputter(Format.getPrettyFormat()); String xml = out.outputString(root); XML编码陷阱 错误的写法： String xml = FileUtils.readTextFile(“my.xml”); 因为xml的编码在文件中指定的，而在读文件的时候必须指定编码。另外一个问题不能一次就将一个xml文件用String保存，这样对内存会造成不必要的浪费，正确的做法用InputStream来边读取边处理。为了解决编码的问题, 最好使用XML解析器来处理。 未指定字符编码 错误的写法： Reader r = new FileReader(file); Writer w = new FileWriter(file); Reader r = new InputStreamReader(inputStream); Writer w = new OutputStreamWriter(outputStream); String s = new String(byteArray); // byteArray is a byte[] byte[] a = string.getBytes(); 这样的代码主要不具有跨平台可移植性。因为不同的平台可能使用的是不同的默认字符编码。 正确的写法： Reader r = new InputStreamReader(new FileInputStream(file), “ISO-8859-1”); Writer w = new OutputStreamWriter(new FileOutputStream(file), “ISO-8859-1”); Reader r = new InputStreamReader(inputStream, “UTF-8”); Writer w = new OutputStreamWriter(outputStream, “UTF-8”); String s = new String(byteArray, “ASCII”); byte[] a = string.getBytes(“ASCII”); 未对数据流进行缓存 错误的写法： InputStream in = new FileInputStream(file); int b; while ((b = in.read()) != -1) { … } 上面的代码是一个byte一个byte的读取，导致频繁的本地JNI文件系统访问，非常低效，因为调用本地方法是非常耗时的。最好用 BufferedInputStream包装一下。曾经做过一个测试，从/dev/zero下读取1MB，大概花了1s，而用 BufferedInputStream包装之后只需要60ms，性能提高了94%! 这个也适用于output stream操作以及socket操作。 正确的写法： InputStream in = new BufferedInputStream(new FileInputStream(file)); 无限使用heap内存 错误的写法： byte[] pdf = toPdf(file); 这里有一个前提，就是文件大小不能讲JVM的heap撑爆。否则就等着OOM吧，尤其是在高并发的服务器端代码。最好的做法是采用Stream的方式边读取边存储(本地文件或database)。 正确的写法： File pdf = toPdf(file); 另外，对于服务器端代码来说，为了系统的安全，至少需要对文件的大小进行限制。 不指定超时时间 错误的代码： Socket socket = … socket.connect(remote); InputStream in = socket.getInputStream(); int i = in.read(); 这种情况在工作中已经碰到不止一次了。个人经验一般超时不要超过20s。这里有一个问题，connect可以指定超时时间，但是read无法指定超时时间。但是可以设置阻塞(block)时间。 正确的写法： Socket socket = … socket.connect(remote, 20000); // fail after 20s InputStream in = socket.getInputStream(); socket.setSoTimeout(15000); int i = in.read(); 另外，文件的读取(FileInputStream, FileChannel, FileDescriptor, File)没法指定超时时间, 而且IO操作均涉及到本地方法调用, 这个更操作了JVM的控制范围，在分布式文件系统中，对IO的操作内部实际上是网络调用。一般情况下操作60s的操作都可以认为已经超时了。为了解决这些 问题，一般采用缓存和异步/消息队列处理。 频繁使用计时器 错误代码： for (…) { long t = System.currentTimeMillis(); long t = System.nanoTime(); Date d = new Date(); Calendar c = new GregorianCalendar(); } 每次new一个Date或Calendar都会涉及一次本地调用来获取当前时间(尽管这个本地调用相对其他本地方法调用要快)。如果对时间不是特别敏感，这里使用了clone方法来新建一个Date实例。这样相对直接new要高效一些。 正确的写法： Date d = new Date(); for (E entity : entities) { entity.doSomething(); entity.setUpdated((Date) d.clone()); } 如果循环操作耗时较长(超过几ms)，那么可以采用下面的方法，立即创建一个Timer，然后定期根据当前时间更新时间戳，在我的系统上比直接new一个时间对象快200倍： private volatile long time; Timer timer = new Timer(true); try { time = System.currentTimeMillis(); timer.scheduleAtFixedRate(new TimerTask() { public void run() { time = System.currentTimeMillis(); } }, 0L, 10L); // granularity 10ms for (E entity : entities) { entity.doSomething(); entity.setUpdated(new Date(time)); } } finally { timer.cancel(); } 捕获所有的异常 错误的写法： Query q = … Person p; try { p = (Person) q.getSingleResult(); } catch(Exception e) { p = null; } 这是EJB3的一个查询操作，可能出现异常的原因是：结果不唯一；没有结果；数据库无法访问，而捕获所有的异常，设置为null将掩盖各种异常情况。 正确的写法： Query q = … Person p; try { p = (Person) q.getSingleResult(); } catch(NoResultException e) { p = null; } 忽略所有异常 错误的写法： try { doStuff(); } catch(Exception e) { log.fatal(“Could not do stuff”); } doMoreStuff(); 这个代码有两个问题, 一个是没有告诉调用者, 系统调用出错了. 第二个是日志没有出错原因, 很难跟踪定位问题。 正确的写法： try { doStuff(); } catch(Exception e) { throw new MyRuntimeException(“Could not do stuff because: “+ e.getMessage, e); } 重复包装RuntimeException 错误的写法： try { doStuff(); } catch(Exception e) { throw new RuntimeException(e); } 正确的写法： try { doStuff(); } catch(RuntimeException e) { throw e; } catch(Exception e) { throw new RuntimeException(e.getMessage(), e); } try { doStuff(); } catch(IOException e) { throw new RuntimeException(e.getMessage(), e); } catch(NamingException e) { throw new RuntimeException(e.getMessage(), e); } 不正确的传播异常 错误的写法： try { } catch(ParseException e) { throw new RuntimeException(); throw new RuntimeException(e.toString()); throw new RuntimeException(e.getMessage()); throw new RuntimeException(e); } 主要是没有正确的将内部的错误信息传递给调用者. 第一个完全丢掉了内部错误信息, 第二个错误信息依赖toString方法, 如果没有包含最终的嵌套错误信息, 也会出现丢失, 而且可读性差. 第三个稍微好一些, 第四个跟第二个一样。 正确的写法： try { } catch(ParseException e) { throw new RuntimeException(e.getMessage(), e); } 用日志记录异常 错误的写法： try { … } catch(ExceptionA e) { log.error(e.getMessage(), e); throw e; } catch(ExceptionB e) { log.error(e.getMessage(), e); throw e; } 一般情况下在日志中记录异常是不必要的, 除非调用方没有记录日志。 异常处理不彻底 错误的写法： try { is = new FileInputStream(inFile); os = new FileOutputStream(outFile); } finally { try { is.close(); os.close(); } catch(IOException e) { / we can’t do anything / } } is可能close失败, 导致os没有close 正确的写法： try { is = new FileInputStream(inFile); os = new FileOutputStream(outFile); } finally { try { if (is != null) is.close(); } catch(IOException e) {/ we can’t do anything /} try { if (os != null) os.close(); } catch(IOException e) {/ we can’t do anything /} } 捕获不可能出现的异常 错误的写法： try { … do risky stuff … } catch(SomeException e) { // never happens } … do some more … 正确的写法： try { … do risky stuff … } catch(SomeException e) { // never happens hopefully throw new IllegalStateException(e.getMessage(), e); // crash early, passing all information } … do some more … transient的误用 错误的写法： public class A implements Serializable { private String someState; private transient Log log = LogFactory.getLog(getClass()); public void f() { log.debug(“enter f”); … } } 这里的本意是不希望Log对象被序列化. 不过这里在反序列化时, 会因为log未初始化, 导致f()方法抛空指针, 正确的做法是将log定义为静态变量或者定位为具备变量。 正确的写法： public class A implements Serializable { private String someState; private static final Log log = LogFactory.getLog(A.class); public void f() { log.debug(“enter f”); … } } public class A implements Serializable { private String someState; public void f() { Log log = LogFactory.getLog(getClass()); log.debug(“enter f”); … } } 不必要的初始化 错误的写法： public class B { private int count = 0; private String name = null; private boolean important = false; } 这里的变量会在初始化时使用默认值:0, null, false, 因此上面的写法有些多此一举。 正确的写法： public class B { private int count; private String name; private boolean important; } 最好用静态final定义Log变量 private static final Log log = LogFactory.getLog(MyClass.class); 这样做的好处有三： 可以保证线程安全 静态或非静态代码都可用 不会影响对象序列化 选择错误的类加载器 错误的代码： Class clazz = Class.forName(name); Class clazz = getClass().getClassLoader().loadClass(name); 这里本意是希望用当前类来加载希望的对象, 但是这里的getClass()可能抛出异常, 特别在一些受管理的环境中, 比如应用服务器, web容器, Java WebStart环境中, 最好的做法是使用当前应用上下文的类加载器来加载。 正确的写法： ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (cl == null) cl = MyClass.class.getClassLoader(); // fallback Class clazz = cl.loadClass(name); 反射使用不当 错误的写法： Class beanClass = … if (beanClass.newInstance() instanceof TestBean) … 这里的本意是检查beanClass是否是TestBean或是其子类, 但是创建一个类实例可能没那么简单, 首先实例化一个对象会带来一定的消耗, 另外有可能类没有定义默认构造函数. 正确的做法是用Class.isAssignableFrom(Class) 方法。 正确的写法： Class beanClass = … if (TestBean.class.isAssignableFrom(beanClass)) … 不必要的同步 错误的写法： Collection l = new Vector(); for (…) { l.add(object); } Vector是ArrayList同步版本。 正确的写法： Collection l = new ArrayList(); for (…) { l.add(object); } 错误的选择List类型 根据下面的表格数据来进行选择 ArrayListLinkedListadd (append)O(1) or ~O(log(n)) if growingO(1)insert (middle)O(n) or ~O(n*log(n)) if growingO(n)remove (middle)O(n) (always performs complete copy)O(n)iterateO(n)O(n)get by indexO(1)O(n) HashMap size陷阱 错误的写法： Map map = new HashMap(collection.size()); for (Object o : collection) { map.put(o.key, o.value); } 这里可以参考guava的Maps.newHashMapWithExpectedSize的实现. 用户的本意是希望给HashMap设置初始值, 避免扩容(resize)的开销. 但是没有考虑当添加的元素数量达到HashMap容量的75%时将出现resize。 正确的写法： Map map = new HashMap(1 + (int) (collection.size() / 0.75)); 对Hashtable, HashMap 和 HashSet了解不够 这里主要需要了解HashMap和Hashtable的内部实现上, 它们都使用Entry包装来封装key/value, Entry内部除了要保存Key/Value的引用, 还需要保存hash桶中next Entry的应用, 因此对内存会有不小的开销, 而HashSet内部实现其实就是一个HashMap. 有时候IdentityHashMap可以作为一个不错的替代方案. 它在内存使用上更有效(没有用Entry封装, 内部采用Object[]). 不过需要小心使用. 它的实现违背了Map接口的定义. 有时候也可以用ArrayList来替换HashSet. 这一切的根源都是由于JDK内部没有提供一套高效的Map和Set实现。 对List的误用 建议下列场景用Array来替代List: list长度固定，比如一周中的每一天 对list频繁的遍历，比如超过1w次 需要对数字进行包装(主要JDK没有提供基本类型的List) 比如下面的代码。 错误的写法： List codes = new ArrayList(); codes.add(Integer.valueOf(10)); codes.add(Integer.valueOf(20)); codes.add(Integer.valueOf(30)); codes.add(Integer.valueOf(40)); 正确的写法： int[] codes = { 10, 20, 30, 40 }; 错误的写法： // horribly slow and a memory waster if l has a few thousand elements (try it yourself!) List l = …; for (int i=0; i &lt; l.size()-1; i++) { Mergeable one = l.get(i); Iterator j = l.iterator(i+1); // memory allocation! while (j.hasNext()) { Mergeable other = l.next(); if (one.canMergeWith(other)) { one.merge(other); other.remove(); } } } 正确的写法： // quite fast and no memory allocation Mergeable[] l = …; for (int i=0; i &lt; l.length-1; i++) { Mergeable one = l[i]; for (int j=i+1; j &lt; l.length; j++) { Mergeable other = l[j]; if (one.canMergeWith(other)) { one.merge(other); l[j] = null; } } } 实际上Sun也意识到这一点, 因此在JDK中, Collections.sort()就是将一个List拷贝到一个数组中然后调用Arrays.sort方法来执行排序。 用数组来描述一个结构 错误用法： /** * @returns [1]: Location, [2]: Customer, [3]: Incident */ Object[] getDetails(int id) {… 这里用数组+文档的方式来描述一个方法的返回值. 虽然很简单, 但是很容易误用, 正确的做法应该是定义个类。 正确的写法： Details getDetails(int id) {…} private class Details { public Location location; public Customer customer; public Incident incident; } 对方法过度限制 错误用法： public void notify(Person p) { … sendMail(p.getName(), p.getFirstName(), p.getEmail()); … } class PhoneBook { String lookup(String employeeId) { Employee emp = … return emp.getPhone(); } } 第一个例子是对方法参数做了过多的限制, 第二个例子对方法的返回值做了太多的限制。 正确的写法： public void notify(Person p) { … sendMail(p); … } class EmployeeDirectory { Employee lookup(String employeeId) { Employee emp = … return emp; } } 对POJO的setter方法画蛇添足 错误的写法： private String name; public void setName(String name) { this.name = name.trim(); } public void String getName() { return this.name; } 有时候我们很讨厌字符串首尾出现空格, 所以在setter方法中进行了trim处理, 但是这样做的结果带来的副作用会使getter方法的返回值和setter方法不一致, 如果只是将JavaBean当做一个数据容器, 那么最好不要包含任何业务逻辑. 而将业务逻辑放到专门的业务层或者控制层中处理。 正确的做法： person.setName(textInput.getText().trim()); 日历对象(Calendar)误用 错误的写法： Calendar cal = new GregorianCalender(TimeZone.getTimeZone(“Europe/Zurich”)); cal.setTime(date); cal.add(Calendar.HOUR_OF_DAY, 8); date = cal.getTime(); 这里主要是对date, time, calendar和time zone不了解导致. 而在一个时间上增加8小时, 跟time zone没有任何关系, 所以没有必要使用Calendar, 直接用Date对象即可, 而如果是增加天数的话, 则需要使用Calendar, 因为采用不同的时令制可能一天的小时数是不同的(比如有些DST是23或者25个小时) 正确的写法： date = new Date(date.getTime() + 8L 3600L 1000L); // add 8 hrs TimeZone的误用 错误的写法： Calendar cal = new GregorianCalendar(); cal.setTime(date); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); Date startOfDay = cal.getTime(); 这里有两个错误, 一个是没有没有将毫秒归零, 不过最大的错误是没有指定TimeZone, 不过一般的桌面应用没有问题, 但是如果是服务器端应用则会有一些问题, 比如同一时刻在上海和伦敦就不一样, 因此需要指定的TimeZone. 正确的写法： Calendar cal = new GregorianCalendar(user.getTimeZone()); cal.setTime(date); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); Date startOfDay = cal.getTime(); 时区(Time Zone)调整的误用 错误的写法： public static Date convertTz(Date date, TimeZone tz) { Calendar cal = Calendar.getInstance(); cal.setTimeZone(TimeZone.getTimeZone(“UTC”)); cal.setTime(date); cal.setTimeZone(tz); return cal.getTime(); } 这个方法实际上没有改变时间, 输入和输出是一样的. 关于时间的问题可以参考这篇文章: http://www.odi.ch/prog/design/datetime.php 这里主要的问题是Date对象并不包含Time Zone信息. 它总是使用UTC(世界统一时间). 而调用Calendar的getTime/setTime方法会自动在当前时区和UTC之间做转换。 Calendar.getInstance()的误用 错误的写法： Calendar c = Calendar.getInstance(); c.set(2009, Calendar.JANUARY, 15); Calendar.getInstance()依赖local来选择一个Calendar实现, 不同实现的2009年是不同的, 比如有些Calendar实现就没有January月份。 正确的写法： Calendar c = new GregorianCalendar(timeZone); c.set(2009, Calendar.JANUARY, 15); Date.setTime()的误用 错误的写法： account.changePassword(oldPass, newPass); Date lastmod = account.getLastModified(); lastmod.setTime(System.currentTimeMillis()); 在更新密码之后, 修改一下最后更新时间, 这里的用法没有错,但是有更好的做法: 直接传Date对象. 因为Date是Value Object, 不可变的. 如果更新了Date的值, 实际上是生成一个新的Date实例. 这样其他地方用到的实际上不在是原来的对象, 这样可能出现不可预知的异常. 当然这里又涉及到另外一个OO设计的问题, 对外暴露Date实例本身就是不好的做法(一般的做法是在setter方法中设置Date引用参数的clone对象). 另外一种比较好的做法就是直接保存long类型的毫秒数。 正确的做法： account.changePassword(oldPass, newPass); account.setLastModified(new Date()); SimpleDateFormat非线程安全误用 错误的写法： public class Constants { public static final SimpleDateFormat date = new SimpleDateFormat(“dd.MM.yyyy”); } SimpleDateFormat不是线程安全的. 在多线程并行处理的情况下, 会得到非预期的值. 这个错误非常普遍! 如果真要在多线程环境下公用同一个SimpleDateFormat, 那么做好做好同步(cache flush, lock contention), 但是这样会搞得更复杂, 还不如直接new一个实在。 使用全局参数配置常量类/接口 public interface Constants { String version = “1.0”; String dateFormat = “dd.MM.yyyy”; String configFile = “.apprc”; int maxNameLength = 32; String someQuery = “SELECT * FROM …”; } 很多应用都会定义这样一个全局常量类或接口, 但是为什么这种做法不推荐? 因为这些常量之间基本没有任何关联, 只是因为公用才定义在一起. 但是如果其他组件需要使用这些全局变量, 则必须对该常量类产生依赖, 特别是存在server和远程client调用的场景。 比较好的做法是将这些常量定义在组件内部. 或者局限在一个类库内部。 忽略造型溢出(cast overflow) 错误的写法： public int getFileSize(File f) { long l = f.length(); return (int) l; } 这个方法的本意是不支持传递超过2GB的文件. 最好的做法是对长度进行检查, 溢出时抛出异常。 正确的写法： public int getFileSize(File f) { long l = f.length(); if (l &gt; Integer.MAX_VALUE) throw new IllegalStateException(“int overflow”); return (int) l; } 另一个溢出bug是cast的对象不对, 比如下面第一个println. 正确的应该是下面的那个。 long a = System.currentTimeMillis(); long b = a + 100; System.out.println((int) b-a); System.out.println((int) (b-a)); 对float和double使用==操作 错误的写法： for (float f = 10f; f!=0; f-=0.1) { System.out.println(f); } 上面的浮点数递减只会无限接近0而不会等于0, 这样会导致上面的for进入死循环. 通常绝不要对float和double使用==操作. 而采用大于和小于操作. 如果java编译器能针对这种情况给出警告. 或者在java语言规范中不支持浮点数类型的==操作就最好了。 正确的写法： for (float f = 10f; f&gt;0; f-=0.1) { System.out.println(f); } 用浮点数来保存money 错误的写法： float total = 0.0f; for (OrderLine line : lines) { total += line.price * line.count; } double a = 1.14 * 75; // 85.5 将表示为 85.4999… System.out.println(Math.round(a)); // 输出值为85 BigDecimal d = new BigDecimal(1.14); //造成精度丢失 这个也是一个老生常谈的错误. 比如计算100笔订单, 每笔0.3元, 最终的计算结果是29.9999971. 如果将float类型改为double类型, 得到的结果将是30.000001192092896. 出现这种情况的原因是, 人类和计算的计数方式不同. 人类采用的是十进制, 而计算机是二进制.二进制对于计算机来说非常好使, 但是对于涉及到精确计算的场景就会带来误差. 比如银行金融中的应用。 因此绝不要用浮点类型来保存money数据. 采用浮点数得到的计算结果是不精确的. 即使与int类型做乘法运算也会产生一个不精确的结果.那是因为在用二进制存储一个浮点数时已经出现了精度丢失. 最好的做法就是用一个string或者固定点数来表示. 为了精确, 这种表示方式需要指定相应的精度值.BigDecimal就满足了上面所说的需求. 如果在计算的过程中精度的丢失超出了给定的范围, 将抛出runtime exception. 正确的写法： BigDecimal total = BigDecimal.ZERO; for (OrderLine line : lines) { BigDecimal price = new BigDecimal(line.price); BigDecimal count = new BigDecimal(line.count); total = total.add(price.multiply(count)); // BigDecimal is immutable! } total = total.setScale(2, RoundingMode.HALF_UP); BigDecimal a = (new BigDecimal(“1.14”)).multiply(new BigDecimal(75)); // 85.5 exact a = a.setScale(0, RoundingMode.HALF_UP); // 86 System.out.println(a); // correct output: 86 BigDecimal a = new BigDecimal(“1.14”); 不使用finally块释放资源 错误的写法： public void save(File f) throws IOException { OutputStream out = new BufferedOutputStream(new FileOutputStream(f)); out.write(…); out.close(); } public void load(File f) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(f)); in.read(…); in.close(); } 上面的代码打开一个文件输出流, 操作系统为其分配一个文件句柄, 但是文件句柄是一种非常稀缺的资源, 必须通过调用相应的close方法来被正确的释放回收. 而为了保证在异常情况下资源依然能被正确回收, 必须将其放在finally block中. 上面的代码中使用了BufferedInputStream将file stream包装成了一个buffer stream, 这样将导致在调用close方法时才会将buffer stream写入磁盘. 如果在close的时候失败, 将导致写入数据不完全. 而对于FileInputStream在finally block的close操作这里将直接忽略。 如果BufferedOutputStream.close()方法执行顺利则万事大吉, 如果失败这里有一个潜在的bug(http://bugs.sun.com/view_bug.do?bug_id=6335274): 在close方法内部调用flush操作的时候, 如果出现异常, 将直接忽略. 因此为了尽量减少数据丢失, 在执行close之前显式的调用flush操作。 下面的代码有一个小小的瑕疵: 如果分配file stream成功, 但是分配buffer stream失败(OOM这种场景), 将导致文件句柄未被正确释放. 不过这种情况一般不用担心, 因为JVM的gc将帮助我们做清理。 // code for your cookbook public void save() throws IOException { File f = … OutputStream out = new BufferedOutputStream(new FileOutputStream(f)); try { out.write(…); out.flush(); // don’t lose exception by implicit flush on close } finally { out.close(); } } public void load(File f) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(f)); try { in.read(…); } finally { try { in.close(); } catch (IOException e) { } } } 数据库访问也涉及到类似的情况： Car getCar(DataSource ds, String plate) throws SQLException { Car car = null; Connection c = null; PreparedStatement s = null; ResultSet rs = null; try { c = ds.getConnection(); s = c.prepareStatement(“select make, color from cars where plate=?”); s.setString(1, plate); rs = s.executeQuery(); if (rs.next()) { car = new Car(); car.make = rs.getString(1); car.color = rs.getString(2); } } finally { if (rs != null) try { rs.close(); } catch (SQLException e) { } if (s != null) try { s.close(); } catch (SQLException e) { } if (c != null) try { c.close(); } catch (SQLException e) { } } return car; } finalize方法误用 错误的写法： public class FileBackedCache { private File backingStore; … protected void finalize() throws IOException { if (backingStore != null) { backingStore.close(); backingStore = null; } } } 这个问题Effective Java这本书有详细的说明. 主要是finalize方法依赖于GC的调用, 其调用时机可能是立马也可能是几天以后, 所以是不可预知的. 而JDK的API文档中对这一点有误导：建议在该方法中来释放I/O资源。 正确的做法是定义一个close方法, 然后由外部的容器来负责调用释放资源。 public class FileBackedCache { private File backingStore; … public void close() throws IOException { if (backingStore != null) { backingStore.close(); backingStore = null; } } } 在JDK 1.7 (Java 7)中已经引入了一个AutoClosable接口. 当变量(不是对象)超出了try-catch的资源使用范围, 将自动调用close方法。 try (Writer w = new FileWriter(f)) { // implements Closable w.write(“abc”); // w goes out of scope here: w.close() is called automatically in ANY case } catch (IOException e) { throw new RuntimeException(e.getMessage(), e); } Thread.interrupted方法误用 错误的写法： try { Thread.sleep(1000); } catch (InterruptedException e) { // ok } or while (true) { if (Thread.interrupted()) break; } 这里主要是interrupted静态方法除了返回当前线程的中断状态, 还会将当前线程状态复位。 正确的写法： try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } or while (true) { if (Thread.currentThread().isInterrupted()) break; } 在静态变量初始化时创建线程 错误的写法： class Cache { private static final Timer evictor = new Timer(); } Timer构造器内部会new一个thread, 而该thread会从它的父线程(即当前线程)中继承各种属性。比如context classloader, threadlocal以及其他的安全属性(访问权限)。 而加载当前类的线程可能是不确定的，比如一个线程池中随机的一个线程。如果你需要控制线程的属性，最好的做法就是将其初始化操作放在一个静态方法中，这样 初始化将由它的调用者来决定。 正确的做法： class Cache { private static Timer evictor; public static setupEvictor() { evictor = new Timer(); } } 已取消的定时器任务依然持有状态 错误的写法： final MyClass callback = this; TimerTask task = new TimerTask() { public void run() { callback.timeout(); } }; timer.schedule(task, 300000L); try { doSomething(); } finally { task.cancel(); } 上面的task内部包含一个对外部类实例的应用, 这将导致该引用可能不会被GC立即回收. 因为Timer将保留TimerTask在指定的时间之后才被释放. 因此task对应的外部类实例将在5分钟后被回收。 正确的写法： TimerTask task = new Job(this); timer.schedule(task, 300000L); try { doSomething(); } finally { task.cancel(); } static class Job extends TimerTask { private MyClass callback; public Job(MyClass callback) { this.callback = callback; } public boolean cancel() { callback = null; return super.cancel(); } public void run() { if (callback == null) return; callback.timeout(); } }]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出现System.web.mvc冲突的原因及解决方法CS0433]]></title>
    <url>%2Fpost%2F591c6d16.html</url>
    <content type="text"><![CDATA[1.问题描述 CS0433：类型“System.Web.Mvc.WebViewPage”同时存在于URL1和URL2中 2.解决方案 找到Web.config文件中的&lt;System.web&gt;&lt;system.web&gt;1&lt;pre&gt; &lt;span class=&quot;kwrd&quot;&gt;&lt;&lt;span class=&quot;html&quot;&gt;compilation &lt;span class=&quot;attr&quot;&gt;debug&lt;span class=&quot;kwrd&quot;&gt;=&quot;true&quot; &lt;span class=&quot;attr&quot;&gt;targetFramework&lt;span class=&quot;kwrd&quot;&gt;=&quot;4.0&quot;&lt;span class=&quot;kwrd&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;assemblies&gt;1&lt;pre&gt; &lt;span class=&quot;kwrd&quot;&gt;&lt;&lt;span class=&quot;html&quot;&gt;add &lt;span class=&quot;attr&quot;&gt;assembly&lt;span class=&quot;kwrd&quot;&gt;=&quot;System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35&quot; &lt;span class=&quot;kwrd&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;add assembly=”System.Web.Helpers, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35” /&gt;1&lt;pre&gt; &lt;span class=&quot;kwrd&quot;&gt;&lt;&lt;span class=&quot;html&quot;&gt;add &lt;span class=&quot;attr&quot;&gt;assembly&lt;span class=&quot;kwrd&quot;&gt;=&quot;System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35&quot; &lt;span class=&quot;kwrd&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;]]></content>
      <tags>
        <tag>.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看完此文还不懂NB-IoT，你就过来掐死我吧...]]></title>
    <url>%2Fpost%2F24780f3a.html</url>
    <content type="text"><![CDATA[看完此文还不懂NB-IoT，你就过来掐死我吧……. 1 1G-2G-3G-4G-5G 不解释，看图，看看NB-IoT在哪里？ 2 NB-IoT标准化历程 3GPP NB-IoT的标准化始于2015年9月，于2016年7月R13 NB-IoT标准完成。 3 NB-IoT设计目标和用例 NB-IoT主要面向大规模物联网连接应用，其设计目标： •低成本、低复杂性：模块成本小于5美元，2020年目标2-3美元 •增强覆盖：164 dB MCL，比GPRS强20dB •电池寿命：10年 •容量：约55000连接设备/小区 •上行报告时延：小于10S 4 NB-IoT关键技术 如何增强覆盖？ 什么叫覆盖？就是最大耦合损耗(Maximum Coupling Loss，MCL），从基站天线端口到终端天线端口的路径损耗。 简单定义： 上行MCL=上行最大发射功率-基站接收灵敏度。 下行MCL=下行最大发射功率-终端接收灵敏度。 NB-IoT的MCL为164 dB。 ①提升上行功率谱密度 上下行控制信息与业务信息在更窄的LTE带宽中发送，相同发射功率下的PSD（Power Spectrum Density）增益更大，降低接收方的解调要求。 NB-IoT上行功率谱密度增强17dB，考虑GSM终端发射功率最大可以到33dBm，NB-IoT发射功率最大23dBm，所以实 际NB-IoT终端比GSM终端功率谱密度高7dB。 ②重传 重传就是在多个子帧传送一个传输块。Repetition Gain=10log Repetition Times，也就是说重传2次，就可以提升3dB啊。NB-IoT最大可支持下行2048次重传，上行128次重传。 另：接收端无需译码处理增益（约 3-4dB）。 如何降低成本？ ①减少协议栈处理开销 如上图所示，NB-IoT舍弃了LTE物理层的上行共享信道(Physical Uplink Control Channel, PUCCH)、物理混合自动重传请求或指示信道(Physical Hybrid ARQ Indicator Channel, PHICH)等。 ②减少不必要的硬件 单天线和FDD半双工模式，降低RF成本。 Release 13 NB-IoT仅支持FDD 半双工模式，意味着不必同时处理发送和接收，比起全双工成本更低廉，更省电。 另：低速率和低带宽本身意味着芯片处理复杂度降低。 如何省电？ ①PSM（power saving mode） 怎样最省电？当然是“关机”最省电啊。 手机需要时刻待命，不然有人打电话给你找不到怎么办？但这意味着手机需不时监听网络，这是要耗电的。 但物联网终端不同于手机，绝大部分时间在睡觉，每天甚至每周就上报一两条消息，完事后就睡觉。所以它不必随时监听网络，PSM就是让物联网终端发完数据就进入休眠状态，类似于关机，不进行任何通信活动。 ②eDRX DRX(Discontinuous Reception)，即不连续接收。eDRX就是扩展的不连续接收。 手机可以断断续续的接收信号以达到省电的目的。NB-IoT扩展了这个断续间隔，可扩展至2.91小时，更加省电。 此外，NB-IoT只支持小区重选，不支持切换，这减少了测量开销；对空口信令简化, 减小了单次数传功耗。 5 NB-IoT与LTE有什么不同？ 先来简单回忆一下LTE… 无线帧长10ms，子帧1ms，时隙0.5ms，每无线帧内10个子帧，一个子帧2时隙，下行采用正交频分多址(OFDMA)技术，子载波间隔15kHz…多么熟悉的身影。 NB-IoT也是一样的。NB-IoT是基于FDD LTE技术改造而来，包括帧结构、下行OFDMA、上行SC-FDMA、信道编码、交织等大部分沿用LTE技术，可以理解为一种简化版的FDD LTE技术。 这正是NB-IoT被号称为史上最快完成的通信标准的主要原因（半年多就完成），这带来的另一个好处是与现有LTE相容，减少NB-IoT的设备和软件投入，以快速抢占物联网风口。 但也有不同之处。以下章节我们一边介绍NB-IoT，一边对比LTE。 5.1 传输方案 下行传输方案 NB-IoT下行与LTE一致，采用正交频分多址(OFDMA)技术，子载波间隔15kHz，时隙、子帧和无线帧长分别为0.5ms、1ms和10ms，包括每时隙的OFDM符号数和循环前缀（cyclic prefix）都是与LTE一样的。 NB-IoT载波带宽为180KHz，相当于LTE一个PRB(Physical Resource Block)的频宽，即12个子载波*15KHz/子载波=180KHz，这确保了下行与LTE的相容性。比如，在采用LTE载波带内部署时，可保持下行NB-IoT PRB与其它LTE PRB的正交性。 上行传输方案 NB-IoT上行支持多频传输（multi-tone）和单频（single- tone）传输。 多频传输基于SC-FDMA，子载波间隔为15kHz，0.5ms时隙，1ms子帧（与LTE一样）。单频传输子载波间隔可为15KHz以及3.75KHz，其中15KHz与LTE一样，以保持两者在上行的相容性；其中当子载波为3.75KHz时，其帧结构中一个时隙为2ms长（包含7个符号），15KHz为3.75KHz的整数倍，所以对LTE系统有较小的干扰。 与下行一样，NB-IoT上行总系统带宽为180KHz。 5.2 部署方式 众所周知，NB-IoT分为三种部署方式：独立部署（Stand alone）、保护带部署（Guard band）和带内部署（In-band）。独立部署适用于重耕GSM频段，GSM的信道带宽为200KHz，这刚好为NB-IoT 180KHz带宽辟出空间，且两边还有10KHz的保护间隔。保护带部署利用LTE边缘保护频带中未使用的180KHz带宽的资源块。带内部署利用LTE载波中间的任何资源块。 不过，上一段的最后一句话是错误的。在带内部署模式下，有些PRB，NB-IoT是不能占用的。 与LTE一样，NB-IoT终端在开机并搜索载波（小区）时，会在可能的频率范围内重复PSS/SSS的搜索和检测过程，直至搜索到相应的载波（NB-IoT锚定载波），频率扫描的栅格（raster）大小为100kHz。 所谓栅格（raster）也是用于调整LTE载波频率位置的最小单位，表示各个频点间的间隔应该是100KHz的整数倍，相当于一条高速路划分为若干车道，两个车道之间的中心距离为100KHz的整数倍。手机终端在频率扫描是就是按100KHz整数倍来扫描的。 这个100KHz的频率扫描栅格（raster）意味着在带内部署时，NB-IoT锚定载波必须位于确定的PRB中。例如，对于10MHz带宽的LTE,NB-IOT既不能占用同步和广播信道所在的PRB,又要满足100kHz raster要求, 因此其带内NB-IoT只能位于4, 9, 14, 19, 30, 35, 40, 45号PRB。 另外，还要做2.5kHz offset。（还真特么麻烦） 如上图，以NB-IoT带内部署于10MHz LTE带宽为例，DC子载波右边的PRB为#25，其中心频率为97.5kHz（相当于6个子载波），这就与最近的100KHz栅格有2.5KHz的偏差。 由于DC子载波之上的两个相邻PRB的中心频率间隔为180KHz，因此，#30、#35、#40和#45 PRB的中心频率均为离最近的100KHz栅格有2.5KHz的偏差。（只要做了2.5KHz偏差，就可以满足100KHz栅格要求）。 再看上图，对于10MHz和20MHz LTE载波，有一些PRB满足离最近的100KHz栅格有2.5KHz偏差。然而，对于3MHz，5MHz和15MHz的LTE载波带宽，这些PRB离最近的100KHz栅格偏差至少为7.5kHz。 所以，这里留一道作业题，像联通900M只有6M带宽这种情况，怎么办？ 与带内部署模式相似，保护带部署模式下，NB-IoT的锚定载波也需满足其中心频率与最近的100KHz栅格不超过7.5KHz偏差，因为终端在小区搜索时，其栅格偏差需满足7.5KHz以下，才能完成网络同步。 NB-IoT支持多载波配置，其载波可分为两类：Anchor Carrier（锚定载波）和Non-Anchor Carrier（非锚定载波），对于非锚定载波，不必满足100KHz栅格偏差。 可是，有些PRB（比如#25)也满足离最近的100KHz栅格有2.5KHz偏差，为啥就不能部署带内NB-IoT的PRB呢？ 答案是，NB-IoT不能使用LTE载波中间的6个PRB，这些PRB要用于LTE同步和广播信道。 5.3 物理信道 NB-IoT物理信道的设计在很大程度上也是基于LTE，本文我们主要介绍两者之间的差别。 1）下行 对于下行链路，NB-IoT定义了三种物理信道： ①NPBCH，窄带物理广播信道 ②NPDCCH，窄带物理下行控制信道 ③NPDSCH，窄带物理下行共享信道 还定义了两种物理信号： ①NRS，窄带参考信号 ②NPSS和NSSS，主同步信号和辅同步信号 与LTE不同，由于NB-IoT频率带宽最多只有1个PRB，因此，这些下行物理信道间采用时分复用模式，也就是在不同的时间上轮流出现。 ▲NB-IoT下行物理信道和信号之间的时分复用 如上图，NB-IoT子帧被分配给了不同的物理信道和信号，每一个NB-IoT子帧在频域上是一个PRB（12个子载波），在时域上为1ms。 NPSS和NSSS NPSS和NSSS用于NB-IoT终端执行小区搜索，包括时间、频率同步和侦测Cell ID。因为LTE的同步序列占用6个PRB，NB-IoT不能占用这6个PRB。为避免冲突，NB-IoT需要重新设计。 NPSS位于每10ms无线帧中5号子帧（＃5），周期为10ms，使用每子帧中的最后11个OFDM符号（如下图）。 对于NB-IoT终端来讲，执行NPSS检测是一项计算复杂的过程，有违于其设计简单化的目标，因此，NPSS的设计为短的ZC(Zadoff-Chu)序列。 NSSS位于子帧#9，周期为20ms，仅出现于偶数帧，同样使用每子帧中的最后11个OFDM符号。 NPSS为NB-IoT终端提供时间和频率同步参考信号，与LTE不同的是，NPSS中不携带任何小区信息，NSSS带有PCI。 NPBCH NPBCH位于每无线帧中的子帧#0，TTI为640ms，承载MIB-NB（Narrowband Master Information Block），其余系统信息如SIB1-NB等承载于NPDSCH中。 NPDCCH和NPDSCH NPDCCH承载上行和下行数据信道的调度信息，包括上行数据信道的HARQ确认信息、寻呼指示和随机接入响应调度信息、来自更高层的数据信息、寻呼消息、系统消息和随机接入响应消息等。 如以上NB-IoT物理信道时分复用图所示，很多子帧被分配给NPDCCH和NPDSCH。 为降低终端复杂性，所有下行信道采用LTE的TBCC码。另外，NPDSCH的最大传输块大小（TBS）为680 bits，而无空间复用的LTE支持的最大TBS大于70000 bits。 NRS NRS（窄带参考信号），也称为导频信号，主要作用是下行信道质量测量估计，用于终端的相干检测和解调。在用于广播和下行专用信道时，所有下行子帧都要传输NRS，无论有无数据传送。 NRS与承载NPBCH、NPDCCH和NPDSCH的子帧中的信息承载符号时频复用，每天线端口每子帧使用8个RE。 上行 对于上行链路，NB-IoT定义了两种物理信道： ①NPUSCH，窄带物理上行共享信道。 ②NPRACH，窄带物理随机接入信道。 还有DMRS，上行解调参考信号。 NPRACH 由于LTE的PRACH信道带宽为1.08MHz，这远远高于NB-IoT上行带宽，因此需重新设计。 和LTE的Random Access Preamble使用ZC序列不同，NB-IoT的Random Access Preamble是单频传输（3.75KHz子载波），且使用的Symbol为一定值。一次的Random Access Preamble传送包含四个Symbol Group，一个Symbol Group是5个Symbol加上一CP（如下图）。 一个NPRACH preamble（前导码）由四个Symbol Group组成。每个Symbol Group之间会有跳频。选择传送的Random Access Preamble即是选择起始的子载波。 ▲NPRACH跳频 当CP长度为66.67s (Format 0) 时，小区覆盖半径达10公里。当CP长度为266.7s (Format 1) ，覆盖半径达40公里。为了扩展覆盖，NPRACH preamble可重复128次。 NPUSCH NPUSCH用来传送上行数据以及上行控制信息，传输可使用单频或多频传输（前面介绍过）。 NPUSCH定义了两种格式：Format 1和Format 2。 Format 1为UL-SCH上的上行信道数据而设计，使用与LTE相同的Turbo码纠错，其资源块大小远低于LTE，不大于1000 bits。 Format 2用于NPDSCH的HARQ确认信令，传送上行控制信息（UCI），使用重复码来纠错。 映射到传输快的最小单元叫资源单元（RU，resource unit），它由NPUSCH格式和子载波空间决定。 有别于LTE系统中的资源分配的基本单位为子帧，NB-IoT根据子载波和时隙数目来作为资源分配的基本单位，如下表所示： 对于NPUSCH format 1，当子载波空间为3.75 kHz时，只支持单频传输，一个RU在频域上包含1个子载波，在时域上包含16个时隙，所以，一个RU的长度为32ms。 当子载波空间为15kHz时，支持单频传输和多频传输，一个RU包含1个子载波和16个时隙，长度为8ms；当一个RU包含12个子载波时，则有2个时隙的时间长度，即1ms，此资源单位刚好是LTE系统中的一个子帧。资源单位的时间长度设计为2的幂次方，是为了更有效的运用资源，避免产生资源空隙而造成资源浪费。 对于NPUSCH format 2，RU总是由1个子载波和4个时隙组成，所以，当子载波空间为3.75 kHz时，一个RU时长为8ms；当子载波空间为15kHz时，一个RU时长为2ms。 NPUSCH format 2调制方式为BPSK。 NPUSCH format 1调制方式分为以下两种情况： ●包含一个子载波的RU，采用BPSK和QPSK。 ●其它情况下，采用QPSK。 这地方有点绕，换句话来理解： ①NPUSCH支持15 kHz或3.75 kHz单频传输，为了降低峰均功率比（PAPR），单频传输则使用π/2 BPSK或π/4 QPSK。 ②NPUSCH若支持多频传输，则使用QPSK。 （补充：NB-IoT下行调制采用QPSK，下行信道编码采用TBCC，上行信道编码为Turbo码） DMRS DMRS用于信道估计。NPUSCH Format 1格式与LTE PUSCH时隙结构相同，每时隙7个OFDM符号，中间一个符号作为DMRS。Format 2格式同样为每时隙7个OFDM符号，但将中间3个符号用作DMRS。 5.4 资源映射 在本节中，我们将描述NB-IoT资源映射如何部署在LTE载波中，以确保与LTE的最佳共存性能。实质上，通过避免将NB-IoT信号映射到已经由传统LTE信号已经使用的资源元素来保持与LTE信号的正交性。 为了确保与LTE系统共存，必须避免NB-IoT信号映射到LTE已使用的RE（Resource Element，LTE物理资源中最小的资源单位），以保持两者间的正交性。 如上图所示，每一列表明一个OFDM符号中的RE，每个OFDM符号有12个RE（对应12个子载波）。 对于独立部署和保护带部署模式，不需要保护LTE资源。因此，NPDCCH, NPDSCH和NRS可以使用PRB中的所有资源。 对于带内部署模式，NPDCCH, NPDSCH和NRS不能映射到已被LTE CRS和PDCCH占用的RE上。 NB-IoT终端通过小区搜索来获知部署模式（带内/保护带/独立部署）和CI，然后确定哪些RE被LTE使用，终端再映射NPDCCH和NPDSCH符号到可用RE。NPSS，NSSS和NPBCH在初始同步和获取主系统信息时，并不知道部署模式，为此，NPSS，NSSS和NPBCH避免使用每一子帧的前三个OFDM符号，因为这些资源可能会被LTE PDCCH使用。 5.5 同步 同步是蜂窝通信系统中一个重要环节。当终端第一次开机后，需要检测一个”合适的小区”(suitable cell)来驻留，然后获取符号、子帧、帧定时以及与载波频率同步。为了频率同步，终端需要从基站获取同步信息，同步调校，以纠正因本地振荡器不精准而引起的频率偏差。另外，由于存在多个小区，终端需基于NB-PCID识别其指定小区。 因此，整个同步过程实际包括时间同步校准，频偏校正，获取CI和子帧和帧号参考。 NB-IoT的特点是低成本和强覆盖。低成本意味着NB-IoT终端配置低成本的晶振，其初始载波频偏可高达20 ppm。加之我们前文所述的带内和保护带部署模式下会引入额外的2.5KHz或7.5KHz栅格偏移，这会进一步加大载波频偏。对于NB-IoT的另一个特点———增强覆盖，意味着很多终端位于地下室一类的非常低的SNR网络环境。 如何在载波频偏和低SNR环境下完成精准的同步呢？尽管NB-IoT的同步过程和LTE相似，但为了解决上述两个问题，NB-IoT对同步序列进行了改动。 如前所述，NPSS和NSSS被用来完成同步，NPSS占用每帧的子帧＃5，NSSS占用每个偶数帧的子帧＃9。 NPSS用于获取符号定时和载波频偏，NSSS用于获取NB-PCID，时长为80ms块。对于超低SNR环境下的终端，要完成检测，单个10ms时间是不够的，需要一个累计的过程，多个10ms才行。NPSS就是基于这样的时间累计来设计的，其原理就是用时间来换精确性，用加权累积过程来纠正频偏。覆盖信号越差的终端，需要的累加次数越高。 NPSS和NSSS同步完成后，终端获取了符号定时、载波频偏和NB-PCID等信息。然后，终端获取MIB信息，其通过位于每帧中的子帧#0的NPBCH信道广播。NPBCH由8个自解码子块组成，每个子块重复8次，每个子块占用8个连续帧的子帧＃0，这样设计的目的就是为了让处于深度覆盖的终端成功获取信息。 通过以上设计，NB-IoT有效的补偿了载波频偏，并完成NPSS和NSSS同步、获取MIB信息。至于栅格偏移，尤其是7.5KHz的偏移，有点不好解决。 7.5kHz栅格偏移会导致5.33秒（假设载波频率为900 MHz）的符号定时漂移，这大于了循环前缀的持续时间，会破坏OFDM的下行链路的正交性。唯一的办法就是牺牲成本，提升计算复杂度，以提高检测性能。 所以，这里解决了那道作业题“联通900M只有6M带宽这种情况，怎么办？”。 至于较小的栅格偏移，由于每10个子帧中只有一个NPBCH子帧，是可实现的。 5.6 随机接入 当需建立无线链路和调度请求时，NB-IoT会执行随机接入。随机接入的一个主要目的是实现上行链路同步，以保持上行正交性。 类似于LTE，NB-IoT基于竞争的随机接入包括四个步骤： （1）UE发送随机接入前导码 （2）网络发送随机接入响应（包含TA命令和将在第三步使用的上行链路资源调度） （3）UE使用调度资源，并向网络回应身份标识 （4）网络发送消息，解决多UE竞争接入问题。 为了满足不同的覆盖范围，系统可以在小区内配置最多三个NPRACH资源配置，每个配置指定随机接入前导码的重复值。终端会根据其测量的下行信号强度来估计覆盖水平（CE Level），并使用根据覆盖水平配置的NPRACH资源来发送发送随机接入前导码。 NB-IoT允许使用以下参数在时、频上灵活配置NPRACH资源： 时域：NPRACH资源的周期性，NPRACH资源的开始时间。 频域：频率位置（基于子载波偏移）和子载波数。 总之，终端通过测量下行信号强度来决定CE Level，并使用该CE Level指定的NPRACH资源，发送随机接入前导码。一旦随机接入前导码传送失败，NB-IoT终端会在升级CE Level重新尝试，直到尝试完所有CE Level的NPRACH资源为止（如下图）。 NB-IoT的随机接入过程和LTE非常相似，不再多述。 5.7 调度和HARQ 由于资源有限且支持重复传送，若上行采用同步自适应HARQ会导致上行资源运用更加困难，因此，NB-IoT的上下行都采用异步自适应HARQ，即根据新接收到的DCI（Downlink Control Information）来决定重传。另外，为了降低终端的复杂度，NB-IoT只支持一个HARQ过程，并且允许NPDCCH和NPDSCH更长的UE解码时间。 以上图为例，调度命令通过承载于NPDCH的DCI传送，NPDCH使用AL（aggregation levels）1或AL2传送DCI。对于AL1，两个DCI复用于一个子帧，否则一个子帧仅携带一个DCI（即AL-2），以降低编码率和提升覆盖。通过重传增强覆盖，每次重传占用一个子帧。 DCI可以用于调度下行数据或上行数据。 对于调度下行数据，在DCI中指示NPDCCH与相关联的NPDSCH之间的精确时间偏移。考虑物联网设备有限的计算能力，NPDCCH结束与相关NPDSCH的开始之间的时间偏移至少为4ms。 在接收到NPDSCH之后，终端需使用NPUSCH Format 2反馈HARQ确认。DCI中指示携带HARQ确认消息的NPUSCH的资源。考虑物联网设备有限的计算能力，NPDSCH结束与相关HARQ确认开始之间的时间偏移至少为12ms。 对于上行链路调度和HARQ操作，NPDCCH结束与相关NPUSCH开始之间的时间偏移至少为8ms。在完成NPUSCH传送之后，UE监视NPDCCH，以确认基站是否正确接收到NPUSCH，还是需要进行重传。 6 总结 最后，我们再总结一下NB-IoT的一些性能。 1）峰值数据速率 一个最大的TBS为680bits，时长为3ms，因此，NDSCH峰值物理层速率为680bits/3ms=226.7 kbps。同理，NPUSCH峰值数据速率为1000 bits/4ms=250kbps。然而，考虑DCI，NPDSCH / NPUSCH和HARQ确认之间的时间偏移，下行和上行的峰值吞吐量都低于上述数值。 2）覆盖 NB-IoT达到比LTE Rel-12高20 dB的最大耦合损耗（MCL）。覆盖范围的增强是通过增加重传次数来减少数据速率而实现的。通过引入单个子载波NPUSCH传输和 π/2-BPSK调制来保持接近于0dB的PAPR，从而减小由于功率放大器（PA）功率回退引起的覆盖影响，确保覆盖增强。15kHz单频NPUSCH若配置最大重传（128）和最低调制和编码方案时，物理层速率约20bps。而NPDSCH配置最大重传（512）和最低调制和编码方案时，物理层速率可到35bps。这些配置接近170dB耦合损耗，而LTE R12最高约142dB。 3）设备复杂性 为了降低终端复杂性，NB-IoT设计如下： ●下行和上行的传输块大小明显减少 ●下行只支持一个冗余版本 ●上下行仅支持单流传输 ●终端仅需单天线 ●上下行仅支持单HARQ过程 ●终端无需turbo解码器 ●无连接模式下的移动性测量，终端只需执行空闲模式下的移动性测量 ●低带宽，低采样率 ●仅支持FDD半双工 4）时延和电池寿命 NB-IoT主要针对时延不敏感的应用，不过，对于像发送告警信号等应用，NB-IoT支持10秒以下时延。对于164dB耦合损耗，终端平均每天传送200字节数据，电池寿命可达10年。 5）容量 仅有一个PRB资源的NB-IoT单小区支持连接52500终端。此外，NB-IoT支持多载波操作。因此，可以通过添加NB-IoT载波的方式来增加容量。 好了，来吧，掐死我…. 参考文献： NB-IOT，Antti Ratilainen A Primer on 3GPP Narrowband Internet of Things (NB-IoT)，Y.-P. Eric Wang, Xingqin Lin, Ansuman Adhikary, Asbjörn Grövlen, Yutao Sui, Yufei Blankenship, Johan Bergman, and Hazhir S. Razaghi，Ericsson Research, Ericsson AB LoRa and NB-IoT，Gagan Gupta, Darshan Patil NB-IoT解决方案，华为 LTE Signaling for IoT，Anhar Al-Ansi 部分图片来源：ROHDE&amp;SCHWARZ，中国移动，华为，Intel，AT&amp;T，NTT 网优雇佣军投稿邮箱：wywd11@126.com]]></content>
      <tags>
        <tag>nb-iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5调用手机陀螺仪实现方向辨识]]></title>
    <url>%2Fpost%2F3b49ffc0.html</url>
    <content type="text"><![CDATA[获取移动设备的陀螺仪，需要知道陀螺仪包含什么。 我们可以让document监听deviceorientation 来获取相关的数据，里面包括3个值 alpha、beta和gamma。 这三个值分别代表： （1）alpha： 移动设备水平放置时，绕z轴旋转的角度，数值为0度到360度。 （2）beta： 移动设备水平放置时，绕X轴旋转的角度，数值为-180度到180度。 （3）gamma： 移动设备水平放置时，绕Y轴旋转的角度，数值为-90度到90度。 案例： 1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; alpha:&lt;span id=&quot;alpha&quot;&gt;&lt;/span&gt;&lt;br/&gt; beta:&lt;span id=&quot;beta&quot;&gt;&lt;/span&gt;&lt;br/&gt; gamma:&lt;span id=&quot;gamma&quot;&gt;&lt;/span&gt;&lt;br/&gt; &lt;/body&gt; &lt;script&gt; if (window.DeviceOrientationEvent) &#123; window.addEventListener(&apos;deviceorientation&apos;, function (event) &#123; var a = document.getElementById(&apos;alpha&apos;), b = document.getElementById(&apos;beta&apos;), g = document.getElementById(&apos;gamma&apos;), alpha = event.alpha, beta = event.beta, gamma = event.gamma; a.innerHTML = Math.round(alpha); b.innerHTML = Math.round(beta); g.innerHTML = Math.round(gamma); &#125;, false); &#125; else &#123; document.querySelector(&apos;body&apos;).innerHTML = &apos;你的浏览器不支持陀螺仪&apos;; &#125; &lt;/script&gt; &lt;/html&gt; 效果： 兼容： 兼容具体没有测试，ios和android两家的系统有一些区别，而且不同的内核也有一定的偏差。 判断是否是ios可以使用一个webkitCompassHeading属性来判断，ios上面会有这个属性，来表示 手机与地球正北方的夹角。 如果dom里面含有这个属性，我们就需要通过这个属性进行加减来计算出来当前所处于的地区的水平位置。 ——————— 本文来自 专注前端30年 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qq_30100043/article/details/73323617?utm_source=copy]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试和白盒测试的区别]]></title>
    <url>%2Fpost%2F2bcad83.html</url>
    <content type="text"><![CDATA[一. 软件测试方法 软件测试方法：白盒测试、黑盒测试、灰盒测试、静态测试、动态测试 白盒测试：是一种测试用例设计方法，在这里盒子指的是被测试的软件，白盒，顾名思义即盒子是可视的，你可以清楚盒子内部的东西以及里面是如何运作的，因此白盒测试需要你对系统内部的结构和工作原理有一个清楚的了解，并且基于这个知识来设计你的用例。 白盒测试技术一般可被分为静态分析和动态分析两类技术。 静态分析主要有：控制流分析技术、数据流分析技术、信息流分析技术。 动态分析主要有：逻辑覆盖率测试(分支测试、路径测试等)，程序插装等。 白盒测试优点：迫使测试人员去仔细的思考软件的实现；可以检测代码中的每条分支和路径；揭示隐藏在代码中的错误；对代码的测试比较彻底；最优化。 白盒测试缺点：昂贵；无法检测代码中遗漏的路径和数据敏感性错误；不验证规格的正确性。 黑盒测试又叫功能测试，这是因为在黑盒测试中主要关注被测软件的功能实现，而不是内部逻辑。在黑盒测试中，被测对象的内部结构，运作情况对测试人员是不可见的，测试人员对被测产品的验证主要是根据其规格，验证其与规格的一致性。 在绝大多数没有用户参与的黑盒测试中，最常见的测试有：功能性测试、容量测试、安全性测试、负载测试、恢复性测试、标杆测试、稳定性测试、可靠性测试等。 灰盒测试：白盒测试和黑盒测试往往不是决然分开的，一般在白盒测试中交叉使用黑盒测试的方法，在黑盒测试中交叉使用白盒测试的方法。灰盒测试就是这类界于白盒测试和黑盒测试之间的测试。 最常见的灰盒测试是集成测试。 静态测试：是一种不通过执行程序而进行测试的技术。它的关键功能是检查软件的表示和描述是否一致，没有冲突或者没有歧义。 动态测试：包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。 单元测试属于白盒测试范畴；集成测试属于灰盒测试范畴；系统测试属于黑盒测试范畴。 二. 单元测试 概念：单元测试(Unit Testing)是对软件基本组成单元进行的测试，如函数或是一个类的方法。这里的单元，就是软件设计的最小单位。 单元测试的两个步骤：人工静态检查法与动态执行跟踪法。 人工静态检查是测试的第一步，这个阶段工作主要是保证代码算法的逻辑正确性（尽量通过人工检查发现代码的逻辑错误）、清晰性、规范性、一致性、算法高效性，并尽可能的发现程序中没有发现的错误。 第二步是通过设计测试用例，执行待测程序来跟踪比较实际结果与预期结果来发现错误。 人工检查： (1)、检查算法的逻辑正确性：确定所编写的代码算法、数据结构定义（如：队列、堆栈等）是否实现了模块或方法所要求的功能。 (2)、模块接口的正确性检查：确定形式参数个数、数据类型、顺序是否正确；确定返回值类型及返回值的正确性。 (3)、输入参数有没有作正确性检查：如果没有作正确性检查，确定该参数是否的确无需做参数正确性检查，否则请添加上参数的正确性检查。 (4)、调用其他方法接口的正确性：检查实参类型正确与否、传入的参数值正确与否、个数正确与否，特别是具有多态的方法。返回值正确与否，有没有误解返回值所表示的意思。最好对每个被调用的方法的返回值用显示代码作正确性检查，如果被调用方法出现异常或错误程序应该给予反馈，并添加适当的出错处理代码。 (5)、出错处理：模块代码要求能预见出错的条件，并设置适当的出错处理，以便一旦程序出错时，能对出错程序重做安排，保证其逻辑的正确性，这种出错处理应当是模块功能的一部分。若出现下列情况之一，则表明模块的错误处理功能包含有错误或缺陷：出错的描述难以理解；出错的描述不足以对错误定位，不足以确定出错的原因；显示的错误信息与实际的错误原因不符；对错误条件的处理不正确；在对错误进行处理之前，错误条件已经引起系统的干预等。 (6)、保证表达式、SQL语句的正确性：检查所编写的SQL语句的语法、逻辑的正确性。对表达式应该保证不含二义性，对于容易产生歧义的表达式或运算符优先级（如：&lt;、=、 &gt;、 &amp;&amp;、||、++、 –等）可以采用扩号“（）”运算符避免二义性，这样一方面能够保证代码的正确可靠，同时也能够提高代码的可读性。 (7)、检查常量或全局变量使用的正确性：确定所使用的常量或全局变量的取值和数值、数据类型；保证常量每次引用同它的取值、数值和类型的一致性。 (8)、表示符定义的规范一致性：保证变量命名能够见名知意，并且简洁但不宜过长或过短、规范、容易记忆、最好能够拼读。并尽量保证用相同的表示符代表相同功能，不要将不同的功能用相同的表示符表示；更不要用相同的表示符代表不同的功能意义。 (9)、程序风格的一致性、规范性：代码必须能保证符合企业规范，保证所有成员的代码风格一致、规范、工整。例如对数组做循环，不要一会儿采用下标变量从下到上的方式（如:for(i=0;i++;i&lt;10)），一会儿又采用从上到下的方式(如:for(i=10;i–;i&gt;0))；应该尽量采用统一的方式，或则统一从下到上，或则统一从上到下。建议采用for循环和While循环，不要采用do{}while循环等。 (10)、检查程序中使用到的神秘数字是否采用了表示符定义：神秘的数字包括各种常数、数组的大小、字符位置、变换因子以及程序中出现的其他以文字形式写出的数值。在程序源代码里，一个具有原本形式的数对其本身的重要性或作用没提供任何指示性信息，它们也导致程序难以理解和修改。对于这类神秘数字必须采用相应的标量来表示；如果该数字在整个系统中都可能使用到务必将它定义为全局常量；如果该神秘数字在一个类中使用可将其定义为类的属性（Attribute）,如果该神秘数字只在一个方法中出现务必将其定义为局部变量或常量。 (11)、检查代码是否可以优化、算法效率是否最高：如：SQL语句是否可以优化，是否可以用1条SQL语句代替程序中的多条SQL语句的功能，循环是否必要，循环中的语句是否可以抽出到循环之外等。 (12)、检查您的程序是否清晰简洁容易理解：注意：冗长的程序并不一定不是清晰的。 (13)、检查方法内部注释是否完整：是否清晰简洁；是否正确的反映了代码的功能，错误的注释比没有注释更糟；是否做了多余的注释；对于简单的一看就懂的代码没有必要注释。 (14)、检查注释文档是否完整：对包、类、属性、方法功能、参数、返回值的注释是否正确且容易理解；是否会落了或多了某个参数的注释，参数类型是否正确，参数的限定值是否正确。特别是对于形式参数与返回值中关于神秘数值的注释，如：类型参数 应该指出 1.代表什么，2.代表什么，3.代表什么等。对于返回结果集(Result Set)的注释，应该注释结果集中包含那些字段及字段类型、字段顺序等。 动态执行跟踪：动态执行测试通常分为黑盒测试与白盒测试。对于单元测试来说主要应该采用白盒测试法对每个模块的内部作跟踪检查测试。对于单元白盒测试，应该对程序模块进行如下检查：(1)、对模块内所有独立的执行路径至少测试一次；(2)、对所有的逻辑判定，取“真”与“假”的两种情况都至少执行一次；(3)、在循环的边界和运行界限内执行循环体；(4)、测试内部数据的有效性等等。 单元测试的目的：在于发现各模块内部可能存在的各种错误，主要是基于白盒测试。 单元测试的目的主要有3方面：验证单元代码和详细设计文档的一致性；跟踪详细设计文档中设计的实现，发现详细设计文档中存在的错误；发现在编码过程中引入的错误。 单元的常见错误：(1)、单元接口；(2)、局部数据结构；(3)、独立路径；(4)、出错处理；(5)、边界条件。 单元测试策略：有三种，独立的单元测试策略，自顶向下的单元测试策略和自底向上的单元测试策略。 独立的测试策略：不考虑每个模块与其他模块之间的关系，为每个模块设计桩模块和驱动模块。每个模块进行独立的单元测试。 自顶向下的测试策略：先对最顶层的单元进行测试，把顶层所调用的单元做成桩模块。其次对第二层进行测试，使用上面已测试的单元做驱动模块。如此类推直到测试完所有模块。 自底向上测试：先对模块调用层次图上最低层的模块进行单元测试，模拟调用该模块的模块做驱动模块。然后再对上面一层做单元测试，用下面已被测试过的模块做桩模块。依次类推，直到测试完所有模块。 单元测试过程：计划(测什么)、设计(测试方案、策略)、实现(写测试用例、代码)、执行(测试报告)四个阶段。 单元测试的原则：(1)、对全新的代码或修改过的代码进行单元测试；(2)、单元测试根据单元测试计划和方案进行，排除测试的随意性；(3)、必须保证单元测试计划、单元测试方案、单元测试用例等经过评审；(4)、当测试用例的测试结果与预期结果不一致时，单元测试的执行人员需如实记录实际的测试结果；(5)、只有当测试计划中的结束标准达到时，单元测试才能结束；(6)、对被测试单元需达到的一定的代码覆盖率要求。 三. 测试用例 简介：测试用例(Test Case)是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。也指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。 不同类别的软件，测试用例是不同的。 概述：测试用例构成了设计和制定测试过程的基础。测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件或经由产品的事件流，因而，随着测试用例数量的增加，你对产品质量和测试流程也就越有信心。 判断测试是否完全的一个主要评测方法是基于需求的覆盖，而这又是以确定、实施和/或执行的测试用例的数量为依据的。 测试工作量与测试用例的数量成比例。最佳方案是为每个测试需求至少编制两个测试用例。一个测试用例用于证明该需求已经满足，通常称作正面测试用例。另一个测试用例反映某个无法接受、反常或意外的条件或数据，用于论证只有在所需条件下才能够满足该需求，这个测试用例称作负面测试用例。 设计方法： (1)、白盒技术：白盒测试是结构测试，所以被测对象基本上是源程序，以程序的内部逻辑为基础设计测试用例。 白盒测试的测试用例设计：一般采用逻辑覆盖法和基本路径法进行设计。 逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计技术，这一方法要求测试人员对程序的逻辑结构有清楚的了解。逻辑覆盖可分为：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖与路径覆盖。 语句覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使程序中的每个可执行语句至少执行一次。 判定覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，使得程序中的每个判断的取真分支和取假分支至少经历一次，即判断的真假值均曾被满足。 条件覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，要使每个判断中每个条件的可能取值至少满足一次。 判定条件覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，使得判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果至少出现一次。 路径覆盖法：在测试时，首先设计若干个测试用例，然后运行被测程序，要求覆盖程序中所有可能的路径。 基本路径覆盖法：是在程序控制流图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，设计测试用例的方法。该方法把覆盖的路径数压缩到一定限度内，程序中的循环体最多只执行一次。设计出的测试用例要保证在测试中，程序的每一个可执行语句至少执行一次。 循环路径测试：基本路径覆盖法将循环限制在最多一次，这样虽然大大降低了需要覆盖的路径的条数，但对循环的测试却不充分了，因此还需要对循环路径进行测试。循环路径测试包含，简单循环的测试和嵌套循环的测试。 每一种覆盖方法都有其优缺点。通常在设计测试用例时应该根据代码模块的复杂度，选择覆盖方法。一般的代码的复杂度与测试用例设计的复杂度成正比。因此，设计人员必须做到模块或方法功能的单一性、高内聚性，使得方法或函数代码尽可能的简单；这样将可大大提高测试用例设计的容易度，提高测试用例的覆盖程度。 基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。基本路径测试法包括以下5个方面：(1)、程序的控制流图：描述程序控制流的一种图示方法；(2)、程序环境复杂性：McCabe复杂性度量；从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行依次所必须的测试用例数目的上界；(3)、导出测试用例；(4)、准备测试用例，确保基本路径集中的每一条路径的执行；(5)、图形矩阵：是在基本路径测试中起辅助作用的软件工具，利用它可以实现自动地确定一个基本路径集。 另外，对于测试用例的选择除了满足所选择的覆盖程度（或覆盖标准）外还需要尽可能的采用边界值分析法、错误推测法等常用地设计方法。采用边界值分析法设计合理的输入条件与不合理的输入条件；条件边界测试用例应该包括输入参数的边界与条件边界（if,while，for，switch ,SQL Where子句等）。错误推测法，列举出程序中所有可能的错误和容易发生错误的特殊情况，根据它们选择测试用例；在编码、单元测试阶段可以发现很多常见的错误和疑似错误，对于这些错误应该作重点测试，并设计相应的测试用例。 (2)、黑盒技术：等价划分类、边界值分析、错误推测、因果图、综合策略 测试类设计：一个模块或一个方法（Method）并不是一个独立的程序，在考虑测试它时要同时考虑它和外界的联系，用些辅助模块去模拟与所测模块相联系的其他模块。这些辅助模块分为两种： (1)、驱动模块（driver）：相当于所测模块的主程序。它接收测试数据，把这些数据传送给所测模块，最后再输出实际测试结果； (2)、桩模块（stub）:用于代替所测模块调用的子模块。桩模块可以做少量的数据操作，不需要把子模块所有功能都带进来，但不容许什么事情也不做。 打桩：一般在做单元或集成测试时，如果某个程序单元的某条语句，需要调用的一个外部函数还没有设计、编码、调试完成的话，可以只让它简单地返回几个支持测试用例的值就可以了，这种状态的外部函数一般就叫做“打桩”。 所测模块与它相关的驱动模块及桩模块共同构成了一个“测试环境”。 驱动模块和桩模块的编写会给测试带来额外的开销。因为它们在软件交付时并不作为产品的一部分一同交付，而且它们的编写需要一定的工作量。特别是桩模块，不能只简单地给出“曾经进入”的信息。为了能够正确的测试软件，桩模块可能需要模拟实际子模块的功能，这样桩模块的建立就不是很轻松了。 编写桩模块是困难费时的，其实也是完全可以避免编写桩模块的；只需在项目进度管理时将实际桩模块的代码编写工作安排在被测模块前编写即可。而且这样可以提高测试工作的效率，提高实际桩模块的测试频率从而更有效的保证产品的质量。但是，为了保证能够向上一层级提供稳定可靠的实际桩模块，为后续模块测试打下良好的基础，驱动模块还是必不可少的。 对于每一个包或子系统我们可以根据所编写的测试用例来编写一个测试模块类来做驱动模块，用于测试包中所有的待测试模块。而最好不要在每个类中用一个测试函数的方法，来测试跟踪类中所有的方法。这样的好处在于：(1)、能够同时测试包中所有的方法或模块，也可以方便的测试跟踪指定的模块或方法；(2)、能够联合使用所有测试用例对同一段代码执行测试，发现问题；(3)、便以回归测试，当某个模块作了修改之后，只要执行测试类就可以执行所有被测的模块或方法。这样不但能够方便得检查、跟踪所修改的代码，而且能够检查出修改对包内相关模块或方法所造成的影响，使修改引进的错误得以及时发现；(4)、复用测试方法，使测试单元保持持久性，并可以用既有的测试来编写相关测试；(5)、将测试代码与产品代码分开，使代码更清晰、简洁；提高测试代码与被测代码的可维护性。 跟踪调试：跟踪调试不但是深入测试代码的最佳方法，而且也是程序调试发现错误根源的有利工具。测试类设计完成后，最好能借助代码排错工具来跟踪调试待测代码段以深入的检查代码的逻辑错误。现有的代码开发工具（如:JBuilder）一般都集成了这类排错工具。排错工具一般由执行控制程序、执行状态查询程序、跟踪程序组成。执行控制程序包括断点定义、断点撤销、单步执行、断点执行、条件执行等功能。执行状态查询程序包括寄存器、堆栈状态、变量、代码等与程序相关的各种状态信息的查询。跟踪程序用以跟踪程序执行过程中所经历的事件序列（如：分支、子程序调用等）。程序员可通过对程序执行过程中各种状态的判别进行程序错误的识别、定位及改正。 对于模块的单元跟踪调试最好能够做到：每次修改被测模块后，都将所有测试用例跟踪执行一遍以排除所有可能出现或引进的错误。在时间有限的情况下也必须调用驱动模块对所有的测试用例执行一次，并对出现错误或异常的测试用例跟踪执行一次，以发现问题的根源。 排错过程往往是一个艰苦的过程，特别是那种算法复杂、调用子模块较多的模块，对于错误的定位来说并不是件容易的事情。尽管排错不是一门好学的技术（有时人们更愿意称之为艺术），但还是有若干行之有效的方法和策略，下面介绍几种排错时应该采用的方法策略：(1)、断点设置，设置断点对源程序实行断点跟踪将能够大大提高排错的效率。通常断点的设置除了根据经验与错误信息来设置外，还应重点考虑以下几种类行的语句：A、函数调用语句。子函数的调用语句是测试的重点，一方面由于在调用子函数时可能引起接口引用错误，另一方面可能是子函数本身的错误；B、判定转移/循环语句。判定语句常常会由于边界值与比较优先级等问题引起错误或失效而作出错误的转移。因此，对于判定转移/循环语句也是一个重要的测试点；C、SQL语句。对于数据库的应用程序来说，SQL语句常常会在模块中占比较重要的业务逻辑，而且比较复杂。因此，它也属于比较容易出现错误的语句；D、复杂算法段。出错的概率常与算法的复杂度成正比。所以越复杂的算法越需要作重点跟踪，如递归、回朔等算法。(2)、可疑变量查看，在跟踪执行状态下当程序停止在某条语句时可查看变量的当前值和对象的当前属性。通过对比这些变量当前值与预期值可以轻松的定位程序问题根源；(3)、SQL语句执行检查，在跟踪执行或运行状态下将疑似错误的SQL语句打印出来，重新在数据库SQL查询分析器（如：Oracle SQL Plus）中跟踪执行可以较高效的检查纠正SQL语句错误；(4)、注意群集现象，经验表明测试后程序中残存的错误数目与该程序中已发现的错误数目或检错率成正比。根据这个规律，应当对错误群集的程序段进行重点测试，以提高测试投资的效益。如果发现某一代码段似乎比其他程序模块更多的错误倾向时，则应当花费较多的时间和代价测试这个程序模块。 测试用例设计的基本原则：(1)、一个好的测试用例在于能够发现至今没有发现的错误；(2)、测试用例应由测试输入数据和与之对应的预期输出结果这两部分组成；(3)、在测试用例设计时，应当包含合理的输入条件和不合理的输入条件。 测试用例的具体做法： (1)、测试用例文档：编写测试用例文档应有文档模板，须符合内部的规范要求。 (2)、测试用例的设置：按功能设置用例、按路径设置用例、按功能、路径混合模式设置用例； (3)、设计测试用例：测试用例可以分为基本事件、备选事件和异常事件。 四. 白盒测试 白盒测试一般包括以下几项： (1)、目的：保证程序创建的类与接口的完整与正确，以及程序模块单独正常运行。保证局部模块功能完备性，运行正确性与稳定性。 (2)、测试项：所要测试的类。 (3)、测试依据：A、需求规格说明书、用例描述清单；B、设计文档；C、编码规范；D、开发命名标准。 (4)、通过的准则：创建的类、接口、方法、属性应与《设计文档》保持一致；程序的各种命名、注释、代码行的格式等应符合《程序开发命名标准》和《编码规范》；程序模块能独立稳定运行。 (5)、测试环境配置：A、测试工具；B、软件环境。 测试步骤： (1)、配置好测试环境； (2)、编写测试用例； (3)、静态测试、走查代码； (4)、动态测试； (5)、确定问题属性：分为四类，错误、缺陷、失效、故障。 错误是指计算值、观测值、测量值之间，或条件与真值之间，不符合规定的或理论上的正确值或条件。 缺陷是指与期望值或特征值的偏差。 故障是指功能部件不能执行所要求的功能。故障可能由错误、缺陷或失效引起。 失效是指功能部件执行其功能的能力丧失，系统或系统部件丧失了在规定限度内执行所要求功能的能力。 (6)、确定问题类别； (7)、填写测试报告。 白盒测试和单元测试的区别：(1)、测试目的：一个是测试程序的整体逻辑，另一个是测试程序中一个独立的模块；(2)、通常的执行人员不一样：白盒一般由专门的白盒测试人员完成，单元测试一般由程序员自己完成。]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 下 keepalived 的安装和配置]]></title>
    <url>%2Fpost%2Fad3d36af.html</url>
    <content type="text"><![CDATA[安装前准备：yum -y install gcc gcc-c++ autoconf automake makeyum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel 一、下载keepalived方法一：yum -y install keepalived方法二：下载二进制源码包：http://www.keepalived.org/download.html #下载安装文件 123456789101112cd /usr/local/src wget http://www.keepalived.org/software/keepalived-1.4.0.tar.gz #解压文件 tar -zxvf keepalived-1.40.0.tar.gz #编译 cd keepalived-1.40.0/ #--prefix 指定安装地址 #/usr/local/keepalived/ 安装的目录，不要和自己安装文件一个目录，不然报错 ./configure --prefix=/usr/local/keepalived/ #编译并安装 make &amp;&amp; make install &lt;div&gt;配置：（后面部分会详细介绍，这里就用默认配置） &lt;div&gt; &lt;div&gt;启动： &lt;div&gt;首先拷贝几个文件到CentOS7环境中： &lt;div&gt; 12345&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;[root@localhost ~]# cp keepalived-1.3.4/keepalived/etc/init.d/keepalived /etc/init.d/[root@localhost ~]# mkdir /etc/keepalived[root@localhost ~]# cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/[root@localhost ~]# cp keepalived-1.3.4/keepalived/etc/sysconfig/keepalived /etc/sysconfig/[root@localhost ~]# cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ 二、编辑/etc/keepalived/keepalived.conf &lt;pre&gt;&lt;code class=&quot;hljs perl&quot;&gt;yum安装编辑此文件 vim /ect/keepalived/keepalived.conf 源码包安装编辑此文件&lt;/code&gt;1 &lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt; vim /usr/local/keepalived/etc/keepalived/keepalived.conf global_defs { notification_email { #mr@mruse.cn # 指定keepalived在发生切换时需要发送email到的对象，一行一个 #sysadmin@firewall.loc } notification_email_from xxx@163.com # 指定发件人 smtp_server smtp@163.com # smtp 服务器地址 smtp_connect_timeout 30 # smtp 服务器连接超时时间 router_id LVS_1 # 标识本节点的字符串,通常为hostname,但不一定非得是hostname,故障发生时,邮件通知会用到 } vrrp_instance VI_1 { # 实例名称 state MASTER # 可以是MASTER或BACKUP，不过当其他节点keepalived启动时会将priority比较大的节点选举为MASTER interface eth0 # 节点固有IP（非VIP）的网卡，用来发VRRP包做心跳检测 mcast_src_ip 192.168.0.179 #本机的ip，需要修改 virtual_router_id 51 # 虚拟路由ID,取值在0-255之间,用来区分多个instance的VRRP组播,同一网段内ID不能重复;主备必须为一样; priority 100 # 用来选举master的,要成为master那么这个选项的值最好高于其他机器50个点,该项取值范围是1-255(在此范围之外会被识别成默认值100) advert_int 1 # 检查间隔默认为1秒,即1秒进行一次master选举(可以认为是健康查检时间间隔) authentication { # 认证区域,认证类型有PASS和HA（IPSEC）,推荐使用PASS(密码只识别前8位) auth_type PASS # 默认是PASS认证 auth_pass MrUse # PASS认证密码 } virtual_ipaddress { 192.168.0.219 # 虚拟VIP地址,允许多个 } } 123456三、开启服务 （1）systemctl start keepalived（在yum安装时直接使用此命令启动服务） （2）源码包安装启动服务还需进行如下步骤 #创建keepalived配置文件目录 mkdir /etc/keepalived &lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt; #拷贝配置文件到/etc/keepalived目录下 cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/ #复制keepalived脚本到/etc/init.d/ 目录 cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/ #(可忽略) #拷贝keepalived脚本到/etc/sysconfig/ 目录 cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ #建立软连接 ln -s /usr/local/keepalived/sbin/keepalived /sbin/ #添加到开机启动 chkconfig keepalived on #查看服务状况 systemctl status keepalived 12345四、启用ip转发 &lt;pre&gt;&lt;code class=&quot;hljs ruby&quot;&gt;echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;net.ipv4.ip_forward = 1&quot; &lt;span class=&quot;hljs-meta&quot;&gt;&gt;&gt; /etc/sysctl.conf sysctl -p&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 五、防火墙添加规则 firewall-cmd –direct –permanent –add-rule ipv4 filter INPUT 0 –in-interface enp196 –destination 224.0.0.18 –protocol vrrp -j ACCEPT &lt;pre&gt;&lt;code class=&quot;hljs shell&quot;&gt;success &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;bash&quot;&gt; firewall-cmd --direct --permanent --add-rule ipv4 filter OUTPUT 0 \--out-interface enp196 --destination 224.0.0.18 --protocol vrrp -j ACCEPT success &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;bash&quot;&gt; firewall-cmd --reload success&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;```&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 下 mysql+keepalived实现双主自由切换]]></title>
    <url>%2Fpost%2Fe98eb11f.html</url>
    <content type="text"><![CDATA[目录 ip规划 mysql双主配置 keepalived配置 mysql1中keepalived的配置 mysql2中keepalived的配置 VIP漂移检测本文的目的是搭建一个互为主从的mysql高可用架构，用来保证mysql服务器宕机的时候，能够自动的切换的另一台mysql服务器。# ip规划主机名ip地址角色mysql1RIP:172.25.0.41 VIP 172.25.0.200主服务器1mysql2Rip:172.25.0.42 VIP 172.25.0.200主服务器2# mysql双主配置第一步，修改mysql1配置文件，如下所示。123456789101112131415161718192021222324252627[root@mysql1 ~]# vim /etc/my.cnf [mysqld] datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 # Settings user and group are ignored when systemd is used. # If you need to run mysqld under a different user or group, # customize your systemd unit file for mariadb according to the # instructions in http://fedoraproject.org/wiki/Systemd server-id = 1 log-bin = binlog relay_log = mysql-relay-bin log_slave_updates =1 auto_increment_increment=2 #表示自增长ID的数量，即步进 auto_increment_offset=1 ##自增长ID起始位置 [mysqld_safe] log-error=/var/log/mariadb/mariadb.log pid-file=/var/run/mariadb/mariadb.pid # # include all files from the config directory # !includedir /etc/my.cnf.d第二步：修改mysql2的配置文件，如下： 12345678910111213141516171819202122232425262728293031&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;[root@mysql2 ~]# vim /etc/my.cnf[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemdserver-id=2#配置server-id,标识从服务器relay_log = mysql-relay-bin#打开Mysql中继日志log_bin =mysql-bin#打开从服务器的二进制日志log_slave_updates =1#使得更新的数据写进二进制日志中auto_increment_increment=2#表示自增长ID的数量，即步进auto_increment_offset=2#自增长ID起始位置[mysqld_safe]log-error=/var/log/mariadb/mariadb.logpid-file=/var/run/mariadb/mariadb.pid## include all files from the config directory#!includedir /etc/my.cnf.d第三步：在mysql1上创建复制账号，在Master的数据库中建立一个备份帐户：每个slave使用标准的MySQL用户名和密码连接master。进行复制操作的用户会授予REPLICATION SLAVE权限。MariaDB [(none)]&gt; grant replication slave ,replication client on *.* to slave@&#39;172.25.%.%&#39; identified by &#39;centos&#39;;第四步：启动从服务器配置线程,在mysql2上配置 12345678&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;MariaDB [(none)]&gt; change master to master_host=&apos;172.25.0.41&apos;, master_user=&apos;slave&apos;, master_password=&apos;centos&apos;, master_log_file=&apos;binlog.000003&apos;, #指明初始复制时的mysql1中的binlog文件master_log_pos=245;#指明初始复制时binlog文件的位置开启slave线程MariaDB [(none)]&gt; start slave;第五步：上述已搭建好mysql1和mysql2的主从，接下来配置mysql2和mysql1的主从，使其能够互为主从。在mysq1上指定mysql2为主。 1234567&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;MariaDB [(none)]&gt; change master to master_host=&apos;172.25.0.42&apos;, master_user=&apos;slave&apos;, master_password=&apos;centos&apos;, master_log_file=&apos;mysql-bin.000003&apos;, master_log_pos=486688;#指明复制时的起始文件和起始位置。开启slave进程MariaDB [(none)]&gt; start slave; # keepalived配置keepalived能够实现mysql1和mysql2共享一个虚拟ip，当前端访问数据库的时候，可以直接指向这个ip地址，若mysql1宕机了，VIP资源可以直接共享给mysql2. ## mysql1中keepalived的配置第一步：编辑keepalived的配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;! Configuration File for keepalivedglobal_defs &#123; #设置报警通知邮件地址，可以设置多个 notification_email &#123; root@localhost &#125; #设置邮件的发送地址 notification_email_from mysql@xiaomi.com #设置smtp server的地址,该地址必须是存在的 smtp_server 127.0.0.1 #设置连接smtp server的超时时间 smtp_connect_timeout 30 #运行Keepalived服务器的标识，发邮件时显示在邮件标题中的信息 router_id mysql_ha&#125;# 检测脚本vrrp_script chk_mysql &#123; script &quot;/etc/keepalived/mysqlcheck/check_slave.sh&quot; interval 2 weight 2&#125;#定义VRRP实例,实例名自定义vrrp_instance mysql-ha &#123; #指定Keepalived的角色，MASTER主机 BACKUP备份 state BACKUP #此处两个都设置为BACKUP #指定HA监测的接口 interface ens34 #虚拟路由标识，这个标识是一个数字(1-255)，在一个VRRP实例中主备服务器ID必须一样 virtual_router_id 68 #优先级，数字越大优先级越高，在一个实例中主服务器优先级要高于备服务器 priority 100 #从服务器99 #设置主备之间同步检查的时间间隔单位秒 advert_int 1 #设置不抢占模式（DB1设置即可） nopreempt #设置验证类型和密码 authentication &#123; #验证类型有两种&#123;PASS|HA&#125; auth_type PASS #设置验证密码，在一个实例中主备密码保持一样 auth_pass centos &#125; track_script &#123; chk_mysql # 执行监控的服务 &#125; #定义虚拟IP地址,可以有多个，每行一个 virtual_ipaddress &#123; 172.25.0.200 &#125;&#125;第二步：编写心跳检测脚本： 123456789101112131415&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;[root@mysql1 /etc/keepalived/mysqlcheck]# vim /etc/keepalived/mysqlcheck/check_slave.sh #!/bin/bash#This scripts is check for Mysql Slave statuscounter=$(netstat -na|grep &quot;LISTEN&quot;|grep &quot;3306&quot;|wc -l)if [ &quot;$&#123;counter&#125;&quot; -eq 0 ]; then systemctl stop keepalived killall keepalivedfiping 172.25.0.41 -w1 -c1 &amp;&gt;/dev/nullif [ $? -ne 0 ]then systemctl stop keepalived killall keepalivedfi需要为此.sh文件添加可执行权限 1&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt; chmod +x /etc/keepalived/mysqlcheck/check_slave.sh基于网段是否可用以及mysql数据库是否工作来判断服务器的心跳 ## mysql2中keepalived的配置第一步：编辑keepalived中的配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;[root@mysql2 ~]# vim /etc/keepalived/keepalived.conf ! Configuration File for keepalivedglobal_defs &#123; #设置报警通知邮件地址，可以设置多个 notification_email &#123; root@localhost &#125; #设置邮件的发送地址 notification_email_from mysql@xiaomi.com #设置smtp server的地址,该地址必须是存在的 smtp_server 127.0.0.1 #设置连接smtp server的超时时间 smtp_connect_timeout 30 #运行Keepalived服务器的标识，发邮件时显示在邮件标题中的信息 router_id mysql_ha&#125;# 检测脚本vrrp_script chk_mysql &#123; script &quot;/etc/keepalived/mysqlcheck/check_slave.sh&quot; interval 2 weight 2&#125;#定义VRRP实例,实例名自定义vrrp_instance mysql-ha &#123; #指定Keepalived的角色，MASTER主机 BACKUP备份 state BACKUP #此处两个都设置为BACKUP #指定HA监测的接口 interface ens34 #虚拟路由标识，这个标识是一个数字(1-255)，在一个VRRP实例中主备服务器ID必须一样 virtual_router_id 68 #优先级，数字越大优先级越高，在一个实例中主服务器优先级要高于备服务器 priority 90 #从服务器99 #设置主备之间同步检查的时间间隔单位秒 advert_int 1 #设置不抢占模式（DB1设置即可） #nopreempt #设置验证类型和密码 authentication &#123; #验证类型有两种&#123;PASS|HA&#125; auth_type PASS #设置验证密码，在一个实例中主备密码保持一样 auth_pass centos &#125; track_script &#123; chk_mysql # 执行监控的服务 &#125; #定义虚拟IP地址,可以有多个，每行一个 virtual_ipaddress &#123; 172.25.0.200 &#125;&#125; 第二步：编写检测脚本： 123456789101112131415&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;[root@mysql2 ~]# vim /etc/keepalived/mysqlcheck/check_slave.sh #!/bin/bash#This scripts is check for Mysql Slave statuscounter=$(netstat -na|grep &quot;LISTEN&quot;|grep &quot;3306&quot;|wc -l)if [ &quot;$&#123;counter&#125;&quot; -eq 0 ]; then systemctl stop keepalived killall keepalivedfiping 172.25.0.42 -w1 -c1 &amp;&gt;/dev/nullif [ $? -ne 0 ]then systemctl stop keepalived killall keepalivedfi需要为此.sh文件添加可执行权限 1&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt; chmod +x /etc/keepalived/mysqlcheck/check_slave.sh上述心跳检测脚本中，对于状态的检测写的很简单，其一是基于该服务器的mysql是否开启，其二是基于该网段是否可以ping通。可以根据自己的需求，将该脚本设计的更复杂一些。比如根据数据库的插入、删除等是否可用、主从线程是否开启等进行细分。提高检测的精准度。 # VIP漂移检测mysql1和mysql2中同时开启keepalived服务和msyql服务查看mysql1中的ip地址：[root@mysql1 ~]# ip a s由上图可知，此时的VIP是在mysql1中的。停止mysql1中的mysql服务，再观察mysql1和mysql2的ip状况。mysql1：MySQL2：可以看到VIP资源已经由mysql1转移到了mysql2当中。在生产环境中，利用这种机制能够实现故障转移的功能。]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>keepalived</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 高可用性—keepalived+mysql双主（有详细步骤和全部配置项解释）]]></title>
    <url>%2Fpost%2F45313b13.html</url>
    <content type="text"><![CDATA[博主QQ：819594300 博客地址：http://zpf666.blog.51cto.com/ 有什么疑问的朋友可以联系博主，博主会帮你们解答，谢谢支持！ 前言：生产环境中一台mysql主机存在单点故障，所以我们要确保mysql的高可用性，即两台MySQL服务器如果其中有一台MySQL服务器挂掉后，另外一台能立马接替其进行工作。 MySQL的高可用方案一般有如下几种： keepalived+双主，MHA，PXC，MMM，Heartbeat+DRBD等，比较常用的是keepalived+双主，MHA和PXC。 本节主要介绍了利用 keepalived 实现 MySQL 数据库的高可用。 Keepalived+mysql双主来实现MySQL-HA，我们必须保证两台MySQL数据库的数据完全一样，基本思路是两台MySQL互为主从关系，通过Keepalived配置虚拟IP，实现当其中的一台MySQL数据库宕机后，应用能够自动切换到另外一台MySQL数据库，保证系统的高可用。 拓扑环境： OS：centos7.2x86_64 Mysql版本：mysql5.7.13 Keepalived: keepalived-1.2.20 Mysql-vip:192.168.1.150 Mysql-master1:192.168.1.100 Mysql-master2:192.168.1.200 一、 配置两台mysql主主同步 该过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务写入二进制日志。在事件写入二进制日志完成后，master通知存储引擎提交事务。 下一步就是slave将master的binarylog拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经同步了master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。 SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。 主主同步就是两台机器互为主的关系，在任何一台机器上写入都会同步。 若mysql主机开启了防火墙，需要关闭防火墙或创建规则。 实验具体过程如下： 1、修改MySQL配置文件 注意：mysql1和mysql只有server-id不同和auto-increment-offset不同,其他必须相同。 部分配置项解释如下： binlog_format= mixed：指定mysql的binlog日志的格式，mixed是混合模式。 relay-log：开启中继日志功能 relay-log-index：中继日志清单 auto-increment-increment= 2：表示自增长字段每次递增的量，其默认值是1。它的值应设为整个结构中服务器的总数，本案例用到两台服务器，所以值设为2。 auto-increment-offset= 2：用来设定数据库中自动增长的起点(即初始值)，因为这两能服务器都设定了一次自动增长值2，所以它们的起点必须得不同，这样才能避免两台服务器数据同步时出现主键冲突。 注：另外还可以在my.cnf配置文件中，添加“binlog_do_db=数据库名”配置项（可以添加多个）来指定要同步的数据库。如果配置了这个配置项，如果没添加在该配置项后面的数据库，则binlog不记录它的事件。 2、将mysql1设为mysql2的主服务器 在mysql1主机上创建授权账户，允许在mysql2(192.168.1.200)主机上连接 查看mysql1的当前binlog状态信息： 在mysql2上将mysql1设为自已的主服务器并开启slave功能： 下面看一看mysql2的状态： 在mysql1防火墙上开启3306/tcp例外： 顺道把mysql2的防火墙也开启3306/tcp例外，反正后面实验还是要开，那就现在一道开了吧： 再次查看mysql2的状态： 更换mysql2的UUID号： 修改完UUID必须重启mysqld服务才能生效： 这次再来查看mysql2的状态： 3、现在反过来·，再将mysql2设为mysql1的主服务器 在mysql2主机上创建授权账户，允许在mysql1(192.168.1.100)主机上连接 查看mysql2的当前binlog状态信息： 在mysql1上将mysql2设为自已的主服务器并开启slave功能： 查看mysql1的状态： 4、测试主主同步 在mysql1上创建要同步的数据库如bdqn，并在bdqn中创建一张测试表叫it 查看mysql2主机是否同步了mysql1上的数据变化： 从上图可以看出mysql2同步了mysql1的数据变化 现在往mysql2主机上向it表中插入两行数据： 查看mysql1主机是否同步了mysql2上的数据变化： 总结：至此现在任何一台MySQL上更新数据都会同步到另一台MySQL，MySQL同步完成。 注意：若主MYSQL服务器已经存在，只是后期才搭建从MYSQL服务器，在置配数据同步前应先将主MYSQL服务器的要同步的数据库拷贝到从MYSQL服务器上（如先在主MYSQL上备份数据库，再用备份在从MYSQL服务器上恢复） 下面我们就完成keepalived的高可用性： 说明：keepalived是集群管理中保证集群高可用的一个软件解决方案，其功能类似于heartbeat，用来防止单点故障 keepalived是以VRRP协议为实现基础的，VRRP全称VirtualRouter Redundancy Protocol，即虚拟路由冗余协议。 虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip，master会发组播（组播地址为224.0.0.18），当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，这样的话就可以保证路由器的高可用了。 keepalived主要有三个模块，分别是core 、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现VRRP协议的。 二、keepalived的安装配置 1、在mysql1和mysql2两台服务器上安装keepalived的几个依赖包 注意：如不知道keepalived需要哪些依赖包，可到下载后的源码解压目录下查看INSTALL 文件内容，安装需要的依赖包，源码安装任何一个软件都要养成查看源码包文档的习惯，比如INSTALL，README,doc等文档，可以获得很多有用的信息。 下面我们来看一看keepalived的INSTALL文件： 2、在两台mysql上都开始解压缩编译安装keepalived 注：如果你使用的是centos6.5版本，则配置编译装的时候要这样写,如下图所示： 3、执行make install操作之后，会自动生成/etc/init.d/keepalived脚本文件，但还需要手动添加为系统服务，这样就可以使用service、chkconfig工具来对keepalived服务程序进行管理了。 4、若开启了防火墙，则需要关闭防火墙或者建富策略（现实生产环境中，都不允许关防火墙的，所以我们还是建富策略为第一选择）（两台mysql都需要操作） 5、修改keepalived的配置文件 说明：keepalived只有一个配置文件keepalived.conf，里面主要包括以下几个配置区域，分别是： global_defs、vrrp_instance和virtual_server。 global_defs：主要是配置故障发生时的通知对象以及机器标识。 vrrp_instance：用来定义对外提供服务的VIP区域及其相关属性。 virtual_server：虚拟服务器定义 看不清截图的可以看下面的粘贴的文字： ! Configuration File for keepalived global_defs { router_id mysql-1 } vrrp_instance VI_1 { state BACKUP interface eno16777736 virtual_router_id 51 priority 100 advert_int 1 nopreempt authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.1.150 } } virtual_server 192.168.1.150 3306 { delay_loop 2 lb_algo rr lb_kind DR persistence_timeout 60 protocol TCP real_server 192.168.1.100 3306 { weight 3 notify_down /etc/keepalived/bin/mysql.sh TCP_CHECK { connect_timeout 3 nb_get_retry 3 delay_before_retry 3 connect_port 3306 } } } 每个配置项的解释如下： 同样的也需要修改mysql2的keepalived配置文件（下图中绿色部分为和mysql1不一样的地方） 可以使用scp命令把mysql1主机上配置好的keepalived.conf文件拷贝到server2主机，只需要改绿色部分即可: 6、启动keepalived服务（两台都要启动） 7、mysql1和mysql2上都需要添加检测脚本 作用：是当mysql停止工作时自动关闭本机的keeplived，从而实现将故障主机踢出热备组，因每台机器上keepalived只添加了本机为realserver，所以当mysqld正常启动后，我们还需要手动启动keepalived服务。 8、给mysql.sh脚本赋予可执行权限（两台mysql都操作同样的步骤） 9、在mysql1和mysql2上分别执行ip addr show dev eno16777736命令查看mysql1和mysql2对VIP（群集虚拟IP）的控制权 从上图可以看出mysql1是master，mysql2是slave。 10、停止mysql1的mysql服务，看keepalived健康检查程序是否会触发了我们编写的脚本，进行自动故障切换 从上图可以说明在master服务器的mysql服务发生故障时，mysql1主机触发了我们编写的脚本，发生了自动故障切换。 11、现在我们把mysql1的mysql服务开起来，并且keepalived的服务也需要手动开启 12、我们再次在两台mysql服务器上用ip addr show dev eno16777736命令看一下 从上面两张图可以看出，即便mysql1的mysql服务和keepalived服务都重新开启了，mysql2仍然是master了，mysql1抢不回去master的权利了，说明我们设置的nopreempt配置生效了，在生产环境中就需要添加不抢占配置，保证了群集稳定性，只有当mysql2的mysql服务坏掉的时候，mysql1才会再次成为master，否则它永远只能当mysql2的备份。（注：nopreempt一般是在优先级高的mysql上设置） 13、我们找一台安装有MySQL客户端，然后登录VIP，看是否能登录，在登录之前两台MySQL服务器都要授权允许从远程登录 在客户端上登陆： 上图显示说明在客户端访问VIP地址，由mysql2主机提供响应的，因为mysql2当前是主服务器，将mysql2的mysql服务停止，在客户端执行show variables like‘server_id’; 上图显示说明在客户端的查询请求是由mysql1主机响应的，故障切换成功。 总结： Keepalived+mysql双主一般来说，中小型规模的时候，采用这种架构是最省事的。 在master节点发生故障后，利用keepalived的高可用机制实现快速切换到备用节点。 在这个方案里，有几个需要注意的地方： 1.采用keepalived作为高可用方案时，两个节点最好都设置成BACKUP模式，避免因为意外情况下（比如脑裂）相互抢占导致往两个节点写入相同数据而引发冲突； 2.把两个节点的auto_increment_increment（自增步长）和auto_increment_offset（自增起始值）设成不同值。其目的是为了避免master节点意外宕机时，可能会有部分binlog未能及时复制到slave上被应用，从而会导致slave新写入数据的自增值和原先master上冲突了，因此一开始就使其错开；当然了，如果有合适的容错机制能解决主从自增ID冲突的话，也可以不这么做； 3.slave节点服务器配置不要太差，否则更容易导致复制延迟。作为热备节点的slave服务器，硬件配置不能低于master节点； 4.如果对延迟问题很敏感的话，可考虑使用MariaDB分支版本，或者直接上线MySQL 5.7最新版本，利用多线程复制的方式可以很大程度降低复制延迟；]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>keepalived</tag>
        <tag>mysql</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备份VMware虚拟磁盘文件 移植到其他虚拟机]]></title>
    <url>%2Fpost%2F993653b6.html</url>
    <content type="text"><![CDATA[原文：http://jingyan.baidu.com/article/a681b0de17b3173b1843468f.html 方法/步骤1. 第一种方法：直接复制本地主机磁盘下的虚拟磁盘文件到备份目录中，下次恢复时，直接用VMware打开备份目录下的文件即可。首先，打开VMware虚拟机，鼠标放到需要备份的VMware机名称前，会显示此虚拟机虚拟磁盘文件及配置文件所存放的目录。2. 进入到虚拟磁盘及配置文件所在目录，复制所有文件到备份目录中，或者直接复制上一级文件夹（这里是win10x64），然后重命名。3. 恢复或移植到其它虚拟机。直接在VMware主界面中点击右上角”文件（F）“,在弹出来的下拉框中点击”打开（O）“，选择备份目录或从别人虚拟机磁盘文件拷过来的目录。4. 第二种方法：导出vof模板文件，恢复或在其它虚拟机上使用时直接导入vof模板文件即可。首先，打开Vmware虚拟机，选中需要导出的虚拟机名称，然后点击”文件（F）“,在弹出来的下拉框中点击”导出为OVF（E）”（老版的虚拟机好像要点击“导出”然后再点击“导出OVF面板”）5. 选择保存OVF模板的目录，默认文件名是.ovf的，不需要更改，直接点击“保存”按钮即可。6. 然后，就等待着慢慢导出，虚拟机中的软件安装的越多，文件越多，导出时就越慢，所以得看各自的情况了，时间长的不要着急。7. 导出后，在导出的目录中会发现有3个文件。分别后缀为.mf、.vof和.vmdk。MF文件各种虚拟机相关配置是否被篡改。vof文件开放虚拟化格式程序包，保证各个配置之间的正确对应，相当于一种配置文件。8. 恢复虚拟机或在其它虚拟机上使用导出的vof。同样在VMware主界面中点击右上角”文件（F）“,在弹出来的下拉框中点击”打开（O）“，选中恢复目录中的ovf文件，点击“打开”按钮。9. 在弹出的界面中选择“信虚拟机名称（A）”以及“新虚拟机的存储路径（P）”，然后点击“导入”按钮。等待进度条导入成功，就恢复好虚拟机了。此时，恢复好后你就可以打开虚拟机。]]></content>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Mysql 双机热备实现数据库高可用]]></title>
    <url>%2Fpost%2F9cae9a63.html</url>
    <content type="text"><![CDATA[mysql双主热备，也称主主互备，目的是mysql数据库高可用，只支持双机，原因是mysql的复制是一主多从，但一个从服务器只能有一个主服务器。双机热备的条件是双机mysql版本必须一致。服务器分别为A(172.16.9.212)、B(172.16.9.213)，配置步骤如下：一、A-&gt;B主从备份1、在主服务器A上创建从服务器备份的用户，IP地址为B的IPgrant replication slave on . to ‘wuwei‘@’172.16.9.213’ identified by ‘123456’;2、打开主服务器A的二进制日志binarylogvim /etc/my.cnf新增配置如下：要同步的数据库为smartmon配置好保存后需重启mysql3、如果初态不同，则要同步初态先锁定 smartmon数据库：FLUSH TABLES WITH READ LOCK; 然后导出smartmon数据：mysqldump –master-data -uroot -p smartmon &gt; /root/smartmon.sql解除锁定：UNLOCK TABLES; 4、查看主服务器A的binary日志位置，配置从服务器需要用到：show master status\G 5、打开从服务器B的中继日志relay_log新增配置如下： 设置要备份的数据库为smartmon保存，重启mysql6、导入主服务器A的数据库初态拷贝A生成的smartmon.sql到B服务器，再导入mysql -uroot -p smartmon &lt; smartmon.sql然后可以在mysql环境中查看到数据库的数据是一样的7、在从服务器B上开启主从同步，host为A的IP，用户密码是在主服务器A上设置备份用户，log_file和log_pos是主服务器master的binary看到的信息。MariaDB [smartmon]&gt; change master to -&gt; master_host=’172.16.9.212’, -&gt; master_user=’wuwei’, -&gt; master_password=’123456’, -&gt; master_log_file=’mysql-bin.000001’, -&gt; master_log_pos=2338575; 8、在从服务器B上查看slave状态show slave status\G 图中的红框， 两个都是Yes， 说明开启成功。从A到B的主从复制就完成了，所有在A中的修改都能自动同步到B，但是对B的修改却不能同步到A。因为是单向的，如果需要双向同步的话，需要再做一次从B到A的复制。二、B-&gt;A主从备份实际就是步骤一的逆向操作。将B（172.16.9.213）作为主服务器，A（172.16.9.212）作为从服务器。步骤基本和上面一样：1、在B中创建备份用户grant replication slave on . to ‘wuwei‘@’172.16.9.212’ identified by ‘123456’;2、打开 /etc/my.cnf ， 开启B的binarylog：新增配置如下： 3、不需要导出B的初态同步到A上了，因为A和B的初态是一样的（步骤一实现的），查看master日志状态。show master status\G 4、登录到A服务器开启中继relay_log 5、在A服务器上开启同步：MariaDB [smartmon]&gt; change master to -&gt; master_host=’172.16.9.213’, -&gt; master_user=’wuwei’, -&gt; master_password=’123456’, -&gt; master_log_file=’mysql-bin.000003’, -&gt; master_log_pos=2394;host为B的IP地址，user、password是在B上创建的备份用户，log_file、log_pos是在B上看到的master状态信息。6、在A上查看slave status. 如果IO进程和SQL进程都为YES，说明从B到A的同步成功。如果为NO或者执行步骤5失败的，则需要查看mysql日志文件/var/lib/mysql/主机名.err文件查找错误 图中的error信息是说找不到中继日志文件。这是因为我们在配置A的中继文件时改了中继文件名，但是mysql没有同步。解决办法：先停掉mysql服务，然后删掉/var/lib/mysql下的relay-log.info、主机名-relay-bin.000001、主机名-relay-bin.index，再启动mysql查看slave status就变为YES了。配置完成。]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7配置Mysql热备份]]></title>
    <url>%2Fpost%2Fd67c5ca2.html</url>
    <content type="text"><![CDATA[Mysql 的安装： 本人习惯讲安装包放在 /usr/local/src/ ①.[root@localhost ~]#cd /usr/local/src/ ②.[root@localhostsrc]#wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm ③．[root@localhostsrc]#rpm-ivh mysql57-community-release-el7-8.noarch.rpm ④.[root@localhost src]# yum -y install mysql-server 默认配置文件路径：配置文件：/etc/my.cnf日志文件：/var/log/var/log/mysqld.log服务启动脚本：/usr/lib/systemd/system/mysqld.servicesocket文件：/var/run/mysqld/mysqld.pid 查看临时密码随机：注意：安装完mysql服务器登录密码是随机的，需要重置密码。 [root@localhost ~]# grep “password” /var/log/mysqld.log 现在就可以用这个密码进行登录了：mysql -uroot -p Mysql安装结束！ 开始今天的主菜：一台主服务器-一台备份服务器实现热备份： 首先保证两台服务器mysql版本一致，同时防火墙都对3306开放 当前环境： A服务器 ip:192.168.200.11 准备作为主服务器master B服务器 ip: 192.168.200.20 用于备份的服务器slave 一．在A服务器上操作1.创建专门用于备份的 用户（登录mysql之后执行） 123CREATE USER &apos;cp_user&apos;@&apos;192.168.10.130&apos; IDENTIFIED WITH mysql_native_password BY &apos;master2018!&apos;; GRANT REPLICATION SLAVE ON *.* TO &apos;cp_user&apos;@&apos;192.168.200.20&apos;; （注意：这里的cp_user 和 master2018! 是一会儿备份服务器配置是需要用到的master服务器的用户名和密码，需要记下来） 2.修改 MySQL配置文件： /etc/my.cnf 12345678910111213141516171819202122232425262728&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0 log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid&lt;span style=&quot;color: #ff0000;&quot;&gt;log-bin=mysql-binbinlog_format=mixedserver-id=1 //服务器唯一性标识符，每台服务器配置必须保存不一样read-only=0 binlog-do-db=hello //需要备份的那个数据库名叫 “hello”auto-increment-increment=2 //这里设置用来台服务器来做备份，按个人情况定auto-increment-offset=1 //表示这台服务器序号，从1开始，不超auto-increment-increment//配置完该数据库中插入第一个数据id=1,第二条数据id=3而不是2，避免的数据库集群中id冲突&lt;/span&gt; 重新启动mysql服务！ 3.执行 mysql&gt;show master status\G(看到下面信息) mysql-bin.000002和154这两个值需要记得后面有用（刚安装完的数据库可能是mysql-bin.000001 查看master配置： 注意：到这master已经配置完成了！加油,已经成功一半了 下面配置备份服务： 二．B服务器操作：（安装过程都一样这里不重复） 1.修改MySQL /etc/my.cnf 文件： 看最后六行配置。 配置完保存修改，重新启动mysql服务！ 2.登录B服务器的mysql服务器：执行下面命令（配置同步的主服务器） 1234567891011&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;CHANGE MASTER TO MASTER_HOST=‘192.168.200.11’, MASTER_USER=&apos;cp_user&apos;, MASTER_PASSWORD=&apos;master2018!&apos;, MASTER_LOG_FILE=&apos;mysql-bin.000002&apos;, MASTER_LOG_POS=154; 到这里就算是完成99%了，重启B服务器的MySQL服务：service mysql restart 查看slave上备份线程的工作情况： Slave_IO_Running:Yes Slave_SQL_Running:Yes 两个当中如果有一个不是yes都是有问题的，本人第一次运行时遇到了第一个是no,第二个是yes，经过检测是上一步骤中MASTER_LOG_POS=154 这个值没有和master上面获的的Position的值一致，重新执行B服务器的操作2,参数输入正确就行。 IP不正确或者防火墙未对3306开发都可能导致错误。 &lt;table border=&quot;1&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; My.cnf文件中的常见参数讲解 server-id 必须保证每个服务器不一样。 这可能和循环同步有关。 防止进入死循环。 replicate-do-db 可以指定需要复制的数据库。 replicate-ignore-db 复制时需要排除的数据库， 我使用了，这个。 除开系统的几个数据库之外，所有的数据库都复制。 relay_log 中继日志的名字。 前面说到了， 复制线程需要先把远程的变化拷贝到这个中继日志中， 在执行。 log-slave-updates 意思是，中继日志执行之后，这些变化是否需要计入自己的binarylog 当你的B服务器需要作为另外一个服务器的主服务器的时候需要打开。 就是双主互相备份，或者多主循环备份。如果只是一个master和一个备份服务器这个参数可以不要。 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/pre&gt;&lt;/pre&gt;]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware中CentOS设置静态IP]]></title>
    <url>%2Fpost%2Fd613d41e.html</url>
    <content type="text"><![CDATA[因为之前搭建的MongoDB分片没有采用副本集，最近现网压力较大，所以准备研究一下，于是在自己电脑的虚拟机中搭建环境，但是发现之前VMware设置的是DHCP，所以每次重新resume后虚拟机中IP都变了，导致之前已经搭建好的mongodb环境老是出问题又要重新搭建很麻烦，所以设置一下静态静态IP，步骤很简单： 首先关闭VMware的DHCP： Edit-&gt;Virtual Network Editor 选择VMnet8，去掉Use local DHCP service to distribute IP address to VMs选项。点击NAT Settings查看一下GATEWAY地址： 点击OK就可以了。 设置CentOS静态IP： 涉及到三个配置文件，分别是： 123/etc/sysconfig/network/etc/sysconfig/network-scripts/ifcfg-eth0/etc/resolv.conf 首先修改/etc/sysconfig/network如下： 123NETWORKING=yesHOSTNAME=localhost.localdomain**GATEWAY****=192.168.129.2** 指定网关地址。 然后修改/etc/sysconfig/network-scripts/ifcfg-eth0： 123456789101112DEVICE=&quot;eth0&quot;#BOOTPROTO=&quot;dhcp&quot;BOOTPROTO=&quot;static&quot;IPADDR=192.168.129.129NETMASK=255.255.255.0HWADDR=&quot;00:0C:29:56:8F:AD&quot;IPV6INIT=&quot;no&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;ba48a4c0-f33d-4e05-98bd-248b01691c20&quot;DNS1=192.168.129.2 注意：这里DNS1是必须要设置的否则无法进行域名解析。 最后配置下/etc/resolv.conf： 1nameserver 192.168.129.2 其实这一步可以省掉，上面设置了DNS Server的地址后系统会自动修改这个配置文件。 这样很简单几个步骤后虚拟机的IP就一直是192.168.129.129了。]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 mysql8]]></title>
    <url>%2Fpost%2F992f7709.html</url>
    <content type="text"><![CDATA[本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/ManagementAndJava/article/details/80039650本文主要从以下几个方面对自己在centos7 下安装mysql8过程做如下总结： CentOS7 安装mysql8 步骤； window下的Navicat 连接MySql8；* 涉及到的Linux命令——————————————————————————————————————## 第一部分 CentOS7安装mysql### 1.1 安装前清理工作；#### 1.1.1 清理原有的mysql数据库；使用以下命令查找出安装的mysql软件包和依赖包：rpm -pa | grep mysql1234567891011121314151617181920212223242526272829303132显示结果如下： 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql80-community-release-el7-1.noarch &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql-community-server-8.0.11-1.el7.x86_64 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql-community-common-8.0.11-1.el7.x86_64 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 4. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql-community-libs-8.0.11-1.el7.x86_64 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 5. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql-community-client-8.0.11-1.el7.x86_64 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;使用以下命令依次删除上面的程序 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;yum remove mysql-xxx-xxx-&lt;/code&gt;删除mysql的配置文件，卸载不会自动删除配置文件，首先使用如下命令查找出所用的配置文件； find / -name mysql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647可能的显示结果如下： 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/etc/logrotate.d/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/etc/selinux/targeted/active/modules/100/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/etc/selinux/targeted/tmp/modules/100/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 4. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/var/lib/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 5. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/var/lib/mysql/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 6. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/usr/bin/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 7. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/usr/lib64/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 8. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;/usr/local/mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;根据需求使用以下命令 依次 对配置文件进行删除 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;rm -rf /var/lib/mysql&lt;/code&gt; #### 1.1.2 删除MariaDB的文件，由于MySQL在CentOS7中收费了，所以已经不支持MySQL了，取而代之在CentOS7内部集成了mariadb，而安装MySQL的话会和MariaDB的文件冲突，所以需要先卸载掉MariaDB.使用rpm 命令查找出要删除的mariadb文件； rpm -pa | grep mariadb1234可能的显示结果如下： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;mariadb-libs-5.5.56-2.el7.x86_64&lt;/code&gt;删除上面的程序 rpm -e mariadb-libs-5.5.56-2.el7.x86_64123456789101112131415161718192021222324252627282930313233343536可能出现错误提示如下： 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;依赖检测失败： &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;libmysqlclient.so.18()(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 4. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 5. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;libmysqlclient.so.18(libmysqlclient_18)(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 6. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 7. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;libmysqlclient.so.18(libmysqlclient_18)(64bit) 被 (已安裝) postfix-2:2.10.1-6.el7.x86_64 需要 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;使用强制删除： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64&lt;/code&gt;至此就将原来有的mysql 和mariadb数据库删除了； ### 1.2 安装mysql #### 1.2.1 下面mysql官网提供的mysql repo源centos的yum 源中默认是没有mysql的，所以我们需要先去官网下载mysql的repo源并安装；mysql官网下载链接：mysql repo下载地址 如下： #### 1.2.2 使用putty的pscp将文件上传到CentOS使用putty将F:盘下刚下好的mysql repo文件上传到Centos/usr/local/mysql文件夹下； D:\Putty&gt;pscp F:\mysql80-community-release-el7-1.noarch.rpm root@192.168.145.136:/usr/local/mysql/1234#### 1.2.3 安装 yum repo文件并更新 yum 缓存；&lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;rpm -ivh mysql57-community-release-el7-11.noarch.rpm&lt;/code&gt;执行结果：会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo更新 yum 命令 1. yum clean all 2. yum makecache #### 1.2.4 使用 yum安装mysql 当我们在使用yum安装mysql时，yum默认会从yum仓库中安装mysql最新的GA版本；如何选择自己的版本； 第一步： 查看mysql yum仓库中mysql版本，使用如下命令 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;yum repolist all | grep mysql&lt;/code&gt;123456789101112131415161718![](http://pangguoming.com/blog/images/0e034093-4357-4849-ad6b-ef20962e8362.jpg)可以看到 MySQL 5.5 5.6 5.7为禁用状态 而MySQL 8.0为启用状态；第二步 使用&lt;span class=&quot;command&quot;&gt; yum-config-manager 命令修改相应的版本为启用状态最新版本为禁用状态&lt;/span&gt; 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;yum-config-manager --disable mysql80-community &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;yum-config-manager --enable mysql57-community &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;或者可以编辑 mysql repo文件， &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;cat /etc/yum.repos.d/mysql-community.repo &lt;/code&gt; 将相应版本下的enabled改成 1 即可； #### 1.2.5 安装mysql 命令如下： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;yum install mysql-community-server&lt;/code&gt;12345![](http://pangguoming.com/blog/images/eb2d1486-df2d-487a-bfe4-e17b2676c8f9.jpg) #### 1.2.6 开启mysql 服务&lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;systemctl start mysqld.service&lt;/code&gt; #### 1.2.7 获取初始密码登录mysql mysql在安装后会创建一个root@locahost账户，并且把初始的密码放到了/var/log/mysqld.log文件中； &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;cat /var/log/mysqld.log | grep password&lt;/code&gt;12345 ![](http://pangguoming.com/blog/images/883686a7-1190-4580-8912-bcf17b0958cc.jpg) 使用初始密码登录mysql &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;mysql -u root -p &lt;/code&gt; 修改初始密码： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;MyNewPass4!&apos;;&lt;/code&gt;1234567891011121314151617181920212223242526 #### 1.2.8 在防火墙中开启3306端口CentOS7默认使用的是firewall作为防火墙，我这里改为习惯常用的iptables防火墙第一步： 关闭firewall防火墙 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl stop firewalld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl disable firewalld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl mask firewalld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;第二步： 安装iptables防火墙 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;yum install iptables-services -y&lt;/code&gt; 第三步： 启动iptable防火墙 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl enable iptables &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl start iptables &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 第四步： 编辑防火墙增加端口 防火墙文件位置为： /etc/sysconfig/iptables &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;vim /etc/sysconfig/iptables&lt;/code&gt;1234在倒数第三行上增加 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT&lt;/code&gt; 第五步： 重启防火墙 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl enable iptables.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl start iptables.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; #### 1.2.9 将mysql 服务加入开机启动项，并启动mysql进程 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl enable mysqld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl start mysqld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 常用mysql服务命令： 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;登录mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql -u username -p &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 4. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;退出mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 5. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;quit &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 6. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 7. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;启动mysql &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 8. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl start mysqld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 9. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 10. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;结束 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 11. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl stop mysqld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 12. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 13. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;重启 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 14. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl restart mysqld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 15. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 16. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;开机自启 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 17. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;systemctl enable mysqld.service &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 18. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 19. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;查看mysql版本 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 20. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;select version(); &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 本节参考文档： 参考文献1： centos安装mysql 参考文献2： A Quick Guide to Using the MySQL Yum Repository ## 第二部分 Navicat 连接 Mysql8 ### 2.1 开启mysql远程服务： #### 2.1.1 修改mysql数据库下的user表中host的值 可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”登录mysql数据库 执行如下命令： 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;mysql -u root -p &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;use mysql; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;update user set host=&apos;%&apos; where user=&apos;root&apos;; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; #### 2.1.2 使用授权的方式 赋予任何主机访问数据的权限 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos;WITH GRANT OPTION;&lt;/code&gt;1&lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;mysql&gt;FLUSH PRIVILEGES&lt;/code&gt; 如果想myuser用户使用mypassword密码从任何主机连接到mysql服务器的话。 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;%&apos;IDENTIFIED BY &apos;mypassword&apos; WITH GRANT OPTION;&lt;/code&gt;123如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器，并使用mypassword作为密码 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;192.168.1.3&apos;IDENTIFIED BY &apos;mypassword&apos; WITH GRANT OPTION;&lt;/code&gt; #### 2.2 在使用 Navicat for Mysql连接mysql 8.0时会报如下错误： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: &lt;/code&gt;12345678910mysql8.0 引入了新特性 caching_sha2_password；这种密码加密方式客户端不支持；客户端支持的是mysql_native_password 这种加密方式；我们可可以查看mysql 数据库中user表的 plugin字段；![](http://pangguoming.com/blog/images/9128a2ca-ace4-4e97-8838-6e8ef0e30f4b.jpg)可以使用命令将他修改成mysql_native_password加密模式： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;update user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;;&lt;/code&gt; 再用Navicat链接 就可以链接成功； 本节参考文献： 参考文献1： mysql开启远程的两种方式 参考文献2：初次安装mysql遇到的问题 ## 第三部分：安装过程中涉及到的Linux命令学习； 3.1 rpm 3.2 putty 上传文件 pscp命令； 在window机上CD进入pttty安装目录： &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt; cd :\program files (x86)\Putty&lt;/code&gt;1234 将本地文件拷贝到Linux上*：pscp 文件 用户名@LinuxIP:目录*&lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt; pscp hello.txt root@192.168.145.135:/tmp/userfile/&lt;/code&gt; 将本地文件夹 拷贝到Linux上：*pscp -r 目录 用户名@LinuxIP:目录* &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt; pscp -r c:\file root@10.43.65.98:/root/testFolder &lt;/code&gt;1234 将Linux上的文件\root\test.txt拷贝到本地C盘src文件夹，如下：&lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt; pscp root@abc_pc:/root/test.txt C:\src &lt;/code&gt; 3.3 修改防火墙文件/etc/sysconfig/iptables 3.4 systemctl命令 &lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Error】centos7 minimal connect： Network is unreachable]]></title>
    <url>%2Fpost%2F98ed3ed.html</url>
    <content type="text"><![CDATA[参考链接：http://www.centoscn.com/CentosBug/osbug/2015/1208/6500.html 由于centos7 和之前的版本差异比较大，之前的一些命令不能完全使用。 centos7 minimal刚装默认没有打开网卡。 步骤一：cd /etc/sysconfig/network-scripts/ 步骤二： ls 这时候你会发现没有教程上说的ifcfg-eth0文件，打开第一个即可。 有的教程找不到就新建一个，肯定是错的。 步骤三：vi ifcfg-eno167777736 步骤四：修改ONBOOT为yes 保存退出（参考vi使用方法） 步骤五：service network restart]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proguard使用最新，最全教程，亲自试验]]></title>
    <url>%2Fpost%2Ffee36bfa.html</url>
    <content type="text"><![CDATA[最近公司有一个项目，是外包项目，由于对方也有技术人员，出于技术上的保密，需要对class文件进行二次处理，于是网上找了好久，只发现Proguard是用的最广泛而且网上资料最多的。由于不是纯JAVA项目，而是WEB项目，涉及到大量的配置文件，所以用这个工具稍显吃力，于是开始研究这玩意，花了好长一段时间，重复试验了N次，终于整出来了，下面总结一下我的经验。。 首先我介绍下我要混淆的项目框架是jeecg+easyui+spring（包含xml配置文件，导致部分class文件不能直接混淆）。下面开始说详细的操作步奏： 1）将web项目的src目录的java文件打包，只需要选择java文件即可，其他配置文件什么的都不用选择，如图 2）到http://proguard.sourceforge.net/下载proguard，目前我下载并使用的是proguard5.1（注：本人下载频道也有proguard5.1）。 3）解压proguard5.1，执行 bin目录下的proguardgui.bat 然后会弹出如下图所示窗口 4）点击左边“input/output”菜单，然后点击右边的“Add input”按钮，添加需要混淆的jar包，我这里是test.jar,然后点击“add output”,选择输出的路径和包名。 5）下面开始添加支持库，这个地方很重要，很多同学刚开始使用这个工具的时候就是这里老是出问题。 点击右边的“add”。 说明一下，这里最好把你的eclipse里java project里的libraries所有Library的jar包，包含web项目lib下面的包，jdk中jre下面的包和servlet.jar包等copy到一个目录，然后在这里加入这些jar包。系统默认会带上rt.jar,这里我们可以先remove掉，然后到jre下面copy所有的包。 6）点击“shrinking”，设置成如图所示。 7）点击“obfuscation”，设置如图所示 8）点击“optimization”设置如图所示 9）点击information,设置如图所示，注意选择jdk版本（Target） 10) 点击“process”，再点击“save configuration”，在弹出的对话框中，输入要保存的配置文件名称(这里我的是1111111.pro)，最后点击“保存”. 11) 设置基本完成，关掉proguard窗口，找到刚刚保存的配置文件，开始手动修改部分配置。 以下是我的配置文件，经测试通过，手动修改的部分为红色字体 -injars Test\test.jar-outjars Test\test–.jar-libraryjars ‘D:\jdk1.6.0_45\jre\lib\rt.jar’-libraryjars hunxiao\a\activation-1.1.jar-libraryjars hunxiao\a\activiti-cxf-5.10.jar-libraryjars hunxiao\a\activiti-engine-5.10.jar-libraryjars hunxiao\a\activiti-spring-5.10.jar-libraryjars hunxiao\a\alt-rt.jar-libraryjars hunxiao\a\alt-string.jar-libraryjars hunxiao\a\aopalliance-1.0.jar-libraryjars hunxiao\a\c3p0-0.9.1.2.jar-libraryjars hunxiao\a\charsets.jar-libraryjars hunxiao\a\commons-beanutils-1.9.1.jar-libraryjars hunxiao\a\commons-codec-1.9.jar-libraryjars hunxiao\a\commons-collections-3.2.1.jar-libraryjars hunxiao\a\commons-digester-1.7.jar-libraryjars hunxiao\a\commons-digester3-3.2.jar-libraryjars hunxiao\a\commons-io-2.0.1.jar-libraryjars hunxiao\a\commons-lang3-3.3.jar-libraryjars hunxiao\a\commons-logging-1.1.3.jar-libraryjars hunxiao\a\cos-26Dec2008.jar-libraryjars hunxiao\a\deploy.jar-libraryjars hunxiao\a\dom4j-1.6.1.jar-libraryjars hunxiao\a\druid-0.2.6.jar-libraryjars hunxiao\a\edtftpj.jar-libraryjars hunxiao\a\ehcache-core-2.5.2.jar-libraryjars hunxiao\a\fastjson-1.2.0.jar-libraryjars hunxiao\a\fprzMock.jar-libraryjars hunxiao\a\freemarker-2.3.16.jar-libraryjars hunxiao\a\groovy-all-1.5.5.jar-libraryjars hunxiao\a\guava-16.0.1.jar-libraryjars hunxiao\a\hessian-4.0.7.jar-libraryjars hunxiao\a\itext-2.1.7.jar-libraryjars hunxiao\a\iTextAsian-2.1.jar-libraryjars hunxiao\a\jasperreports-3.7.4.jar-libraryjars hunxiao\a\javaws.jar-libraryjars hunxiao\a\javax.servlet.jsp.jstl-1.2.0.v201105211821.jar-libraryjars hunxiao\a\jce.jar-libraryjars hunxiao\a\jfinal-1.6-bin-with-src.jar-libraryjars hunxiao\a\jfinal-ext-eu.jar-libraryjars hunxiao\a\jna-4.1.0.jar-libraryjars hunxiao\a\jna-platform-4.1.0.jar-libraryjars hunxiao\a\joda-time-2.1.jar-libraryjars hunxiao\a\joor-0.9.3.jar-libraryjars hunxiao\a\jsse.jar-libraryjars hunxiao\a\jxls-core-0.9.9.jar-libraryjars hunxiao\a\kaptcha-2.3.2.jar-libraryjars hunxiao\a\log4j-1.2.16.jar-libraryjars hunxiao\a\management-agent.jar-libraryjars hunxiao\a\mybatis-3.1.1.jar-libraryjars hunxiao\a\mysql-connector-java-5.1.20-bin.jar-libraryjars hunxiao\a\ojdbc6.jar-libraryjars hunxiao\a\org.apache.taglibs.standard.glassfish-1.2.0.v201112081803.jar-libraryjars hunxiao\a\org.springframework.aop-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.asm-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.aspects-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.beans-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.context-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.context.support-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.core-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.expression-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.instrument-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.instrument.tomcat-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.jdbc-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.jms-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.org.apache.commons.logging-1.1.1.jar-libraryjars hunxiao\a\org.springframework.orm-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.oxm-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.test-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.transaction-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.web-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.web.portlet-3.1.1.RELEASE.jar-libraryjars hunxiao\a\org.springframework.web.servlet-3.1.1.RELEASE.jar-libraryjars hunxiao\a\plugin.jar-libraryjars hunxiao\a\poi-3.9.jar-libraryjars hunxiao\a\quartz-1.8.6.jar-libraryjars hunxiao\a\resources.jar-libraryjars hunxiao\a\rt.jar-libraryjars hunxiao\a\servlet-api.jar-libraryjars hunxiao\a\shiro-all-1.2.3.jar-libraryjars hunxiao\a\slf4j-api-1.6.1.jar-libraryjars hunxiao\a\slf4j-log4j12-1.6.1.jar-libraryjars hunxiao\a\sqlite-jdbc-3.7.2.jar-libraryjars hunxiao\a\ssosdk-2.0-SNAPSHOT.jar-libraryjars hunxiao\a\TaxWsBean.jar-target 1.6-dontshrink-useuniqueclassmembernames-keeppackagenames-keepattributes Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,LocalVariableTable,Annotation,Synthetic,EnclosingMethod-keepparameternames#保留单个类-keep public class net.easyunion.common.shiro.ShiroDbRealm-keep public class net.easyunion.common.filters.SetCharacterEncodingFilter-keep public class net.easyunion.common.queue.MakeQueue#保留所有控制类（如果是SSH三大框架，由于页面发出请求到struts核心拦截器拦截之后，找到配置文件，配置文件必须对应action里面的类和方法，这里就不能混淆类和方法，所以所有的action类包括里面的方法都不需要混淆，按照如下方式设置就行，保留所有的Action类名和方法名）-keep public class net.easyunion.app.invoice.controller. {;}-keep public class net.easyunion.app.sysseting.controller. {;}-keep public class net.easyunion.app.system.controller. {;}-keep public class net.easyunion.app.system.model. {;}-keep public class net.easyunion.app.supplier.controller. {;}-keep public class net.easyunion.common.controller. {;}-keep public class net.easyunion.app.Config# Keep names - Native method names. Keep all native class/method names.-keepclasseswithmembers,includedescriptorclasses,allowshrinking class { native ;}# Keep names - _class method names. Keep all .class method names. This may be# useful for libraries that will be obfuscated again with different obfuscators.-keepclassmembers,allowshrinking class { java.lang.Class class$(java.lang.String); java.lang.Class class$(java.lang.String,boolean);}# Remove - System method calls. Remove all invocations of System# methods without side effects whose return values are not used.-assumenosideeffects public class java.lang.System { public static long currentTimeMillis(); static java.lang.Class getCallerClass(); public static int identityHashCode(java.lang.Object); public static java.lang.SecurityManager getSecurityManager(); public static java.util.Properties getProperties(); public static java.lang.String getProperty(java.lang.String); public static java.lang.String getenv(java.lang.String); public static java.lang.String mapLibraryName(java.lang.String); public static java.lang.String getProperty(java.lang.String,java.lang.String);}# Remove - Math method calls. Remove all invocations of Math# methods without side effects whose return values are not used.-assumenosideeffects public class java.lang.Math { public static double sin(double); public static double cos(double); public static double tan(double); public static double asin(double); public static double acos(double); public static double atan(double); public static double toRadians(double); public static double toDegrees(double); public static double exp(double); public static double log(double); public static double log10(double); public static double sqrt(double); public static double cbrt(double); public static double IEEEremainder(double,double); public static double ceil(double); public static double floor(double); public static double rint(double); public static double atan2(double,double); public static double pow(double,double); public static int round(float); public static long round(double); public static double random(); public static int abs(int); public static long abs(long); public static float abs(float); public static double abs(double); public static int max(int,int); public static long max(long,long); public static float max(float,float); public static double max(double,double); public static int min(int,int); public static long min(long,long); public static float min(float,float); public static double min(double,double); public static double ulp(double); public static float ulp(float); public static double signum(double); public static float signum(float); public static double sinh(double); public static double cosh(double); public static double tanh(double); public static double hypot(double,double); public static double expm1(double); public static double log1p(double);}# Remove - Number method calls. Remove all invocations of Number# methods without side effects whose return values are not used.-assumenosideeffects public class java.lang. extends java.lang.Number { public static java.lang.String toString(byte); public static java.lang.Byte valueOf(byte); public static byte parseByte(java.lang.String); public static byte parseByte(java.lang.String,int); public static java.lang.Byte valueOf(java.lang.String,int); public static java.lang.Byte valueOf(java.lang.String); public static java.lang.Byte decode(java.lang.String); public int compareTo(java.lang.Byte); public static java.lang.String toString(short); public static short parseShort(java.lang.String); public static short parseShort(java.lang.String,int); public static java.lang.Short valueOf(java.lang.String,int); public static java.lang.Short valueOf(java.lang.String); public static java.lang.Short valueOf(short); public static java.lang.Short decode(java.lang.String); public static short reverseBytes(short); public int compareTo(java.lang.Short); public static java.lang.String toString(int,int); public static java.lang.String toHexString(int); public static java.lang.String toOctalString(int); public static java.lang.String toBinaryString(int); public static java.lang.String toString(int); public static int parseInt(java.lang.String,int); public static int parseInt(java.lang.String); public static java.lang.Integer valueOf(java.lang.String,int); public static java.lang.Integer valueOf(java.lang.String); public static java.lang.Integer valueOf(int); public static java.lang.Integer getInteger(java.lang.String); public static java.lang.Integer getInteger(java.lang.String,int); public static java.lang.Integer getInteger(java.lang.String,java.lang.Integer); public static java.lang.Integer decode(java.lang.String); public static int highestOneBit(int); public static int lowestOneBit(int); public static int numberOfLeadingZeros(int); public static int numberOfTrailingZeros(int); public static int bitCount(int); public static int rotateLeft(int,int); public static int rotateRight(int,int); public static int reverse(int); public static int signum(int); public static int reverseBytes(int); public int compareTo(java.lang.Integer); public static java.lang.String toString(long,int); public static java.lang.String toHexString(long); public static java.lang.String toOctalString(long); public static java.lang.String toBinaryString(long); public static java.lang.String toString(long); public static long parseLong(java.lang.String,int); public static long parseLong(java.lang.String); public static java.lang.Long valueOf(java.lang.String,int); public static java.lang.Long valueOf(java.lang.String); public static java.lang.Long valueOf(long); public static java.lang.Long decode(java.lang.String); public static java.lang.Long getLong(java.lang.String); public static java.lang.Long getLong(java.lang.String,long); public static java.lang.Long getLong(java.lang.String,java.lang.Long); public static long highestOneBit(long); public static long lowestOneBit(long); public static int numberOfLeadingZeros(long); public static int numberOfTrailingZeros(long); public static int bitCount(long); public static long rotateLeft(long,int); public static long rotateRight(long,int); public static long reverse(long); public static int signum(long); public static long reverseBytes(long); public int compareTo(java.lang.Long); public static java.lang.String toString(float); public static java.lang.String toHexString(float); public static java.lang.Float valueOf(java.lang.String); public static java.lang.Float valueOf(float); public static float parseFloat(java.lang.String); public static boolean isNaN(float); public static boolean isInfinite(float); public static int floatToIntBits(float); public static int floatToRawIntBits(float); public static float intBitsToFloat(int); public static int compare(float,float); public boolean isNaN(); public boolean isInfinite(); public int compareTo(java.lang.Float); public static java.lang.String toString(double); public static java.lang.String toHexString(double); public static java.lang.Double valueOf(java.lang.String); public static java.lang.Double valueOf(double); public static double parseDouble(java.lang.String); public static boolean isNaN(double); public static boolean isInfinite(double); public static long doubleToLongBits(double); public static long doubleToRawLongBits(double); public static double longBitsToDouble(long); public static int compare(double,double); public boolean isNaN(); public boolean isInfinite(); public int compareTo(java.lang.Double); public byte byteValue(); public short shortValue(); public int intValue(); public long longValue(); public float floatValue(); public double doubleValue(); public int compareTo(java.lang.Object); public boolean equals(java.lang.Object); public int hashCode(); public java.lang.String toString();}# Remove - String method calls. Remove all invocations of String# methods without side effects whose return values are not used.-assumenosideeffects public class java.lang.String { public static java.lang.String copyValueOf(char[]); public static java.lang.String copyValueOf(char[],int,int); public static java.lang.String valueOf(boolean); public static java.lang.String valueOf(char); public static java.lang.String valueOf(char[]); public static java.lang.String valueOf(char[],int,int); public static java.lang.String valueOf(double); public static java.lang.String valueOf(float); public static java.lang.String valueOf(int); public static java.lang.String valueOf(java.lang.Object); public static java.lang.String valueOf(long); public boolean contentEquals(java.lang.StringBuffer); public boolean endsWith(java.lang.String); public boolean equalsIgnoreCase(java.lang.String); public boolean equals(java.lang.Object); public boolean matches(java.lang.String); public boolean regionMatches(boolean,int,java.lang.String,int,int); public boolean regionMatches(int,java.lang.String,int,int); public boolean startsWith(java.lang.String); public boolean startsWith(java.lang.String,int); public byte[] getBytes(); public byte[] getBytes(java.lang.String); public char charAt(int); public char[] toCharArray(); public int compareToIgnoreCase(java.lang.String); public int compareTo(java.lang.Object); public int compareTo(java.lang.String); public int hashCode(); public int indexOf(int); public int indexOf(int,int); public int indexOf(java.lang.String); public int indexOf(java.lang.String,int); public int lastIndexOf(int); public int lastIndexOf(int,int); public int lastIndexOf(java.lang.String); public int lastIndexOf(java.lang.String,int); public int length(); public java.lang.CharSequence subSequence(int,int); public java.lang.String concat(java.lang.String); public java.lang.String replaceAll(java.lang.String,java.lang.String); public java.lang.String replace(char,char); public java.lang.String replaceFirst(java.lang.String,java.lang.String); public java.lang.String[] split(java.lang.String); public java.lang.String[] split(java.lang.String,int); public java.lang.String substring(int); public java.lang.String substring(int,int); public java.lang.String toLowerCase(); public java.lang.String toLowerCase(java.util.Locale); public java.lang.String toString(); public java.lang.String toUpperCase(); public java.lang.String toUpperCase(java.util.Locale); public java.lang.String trim();}# Remove - StringBuffer method calls. Remove all invocations of StringBuffer# methods without side effects whose return values are not used.-assumenosideeffects public class java.lang.StringBuffer { public java.lang.String toString(); public char charAt(int); public int capacity(); public int codePointAt(int); public int codePointBefore(int); public int indexOf(java.lang.String,int); public int lastIndexOf(java.lang.String); public int lastIndexOf(java.lang.String,int); public int length(); public java.lang.String substring(int); public java.lang.String substring(int,int);}# Remove - StringBuilder method calls. Remove all invocations of StringBuilder# methods without side effects whose return values are not used.-assumenosideeffects public class java.lang.StringBuilder { public java.lang.String toString(); public char charAt(int); public int capacity(); public int codePointAt(int); public int codePointBefore(int); public int indexOf(java.lang.String,int); public int lastIndexOf(java.lang.String); public int lastIndexOf(java.lang.String,int); public int length(); public java.lang.String substring(int); public java.lang.String substring(int,int);} 12）手动设置完成后保存，然后重新打开progrard，执行 bin目录下的proguardgui.bat。 点击第一个选项“Proguard”，再点击“Load configuration”，选择我们刚才保存的“1111111.pro”进行加载。 13）然后点击Process，然后点击View configuration查看是否是已经修改过后的配置文件。 14） 确认是最新修改过的配置文件，然后点击process！开始混淆。。 如下图，表示混淆成功。。 15）我们可以用jd-gui反编译工具看看混淆后的效果。可以看到，之前设置不混淆的类都没有更换类名，而混淆的类都自动更换为a,b,c等类名了。到此，整个java项目混淆就成功了，然后把混淆成功的class文件拷贝到自己的web项目中，替换原先的class文件，然后用tomcat跑项目，发现和正常的class文件运行效果一样，项目正常运行。 16）说明下配置 参数： -include {filename} 从给定的文件中读取配置参数-basedirectory {directoryname} 指定基础目录为以后相对的档案名称-injars {class_path} 指定要处理的应用程序jar,war,ear和目录-outjars {class_path} 指定处理完后要输出的jar,war,ear和目录的名称-libraryjars {classpath} 指定要处理的应用程序jar,war,ear和目录所需要的程序库文件-dontskipnonpubliclibraryclasses 指定不去忽略非公共的库类。-dontskipnonpubliclibraryclassmembers 指定不去忽略包可见的库类的成员。 保留选项 -keep {Modifier} {class_specification} 保护指定的类文件和类的成员-keepclassmembers {modifier} {class_specification} 保护指定类的成员，如果此类受到保护他们会保护的更好-keepclasseswithmembers {class_specification} 保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。-keepnames {class_specification} 保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）-keepclassmembernames {class_specification} 保护指定的类的成员的名称（如果他们不会压缩步骤中删除）-keepclasseswithmembernames {class_specification} 保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）-printseeds {filename} 列出类和类的成员-keep选项的清单，标准输出到给定的文件 压缩 -dontshrink 不压缩输入的类文件-printusage {filename}-whyareyoukeeping {class_specification} 优化 -dontoptimize 不优化输入的类文件-assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用-allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员 混淆 -dontobfuscate 不混淆输入的类文件-printmapping {filename}-applymapping {filename} 重用映射增加混淆-obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称-overloadaggressively 混淆时应用侵入式重载-useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆-flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中-repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中-dontusemixedcaseclassnames 混淆时不会产生形形色色的类名-keepattributes {attribute_name,…} 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses.-renamesourcefileattribute {string} 设置源文件中给定的字符串常量]]></content>
      <tags>
        <tag>Proguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven WEB 项目使用ProGuard进行混淆，最佳解决方案]]></title>
    <url>%2Fpost%2F91fd1306.html</url>
    <content type="text"><![CDATA[Maven WEB 项目使用ProGuard进行混淆，最佳解决方案近期公司的Android项目做了混淆，虽说对于保护代码并不是100%的，但混淆后的代码可以使那些不法份子难以阅读，这样也能对代码的保护做出贡献。于是，公司写的一大堆WEB项目也想做保护。但几大问题随之而来： 公司的所有项目全部是Maven项目，网上的混淆方案不是陈旧就是无效 网上的大部分解决方案感觉像是对简单DEMO进行混淆，根本不能用于复杂的WEB项目中 网上的大部分解决方案是针对Android项目的，针对WEB的少之又少 针对以上问题，本人花费一个月研究了WEB+Maven项目的混淆，终于收获果实，解决了这一大空缺难题。 项目介绍就如之前所述，我们要混淆的项目绝不是一个简单的WEB DEMO，必须要包含了大量第三方框架。本文中介绍的项目使用了主流的一些框架： Spring 4.1.1.RELEASE SpringMVC 4.1.1.RELEASE JackSon 2.5.0 MyBatis 3.3.0 Shiro 1.2.3 Log4J 1.2.17 SLF4J 1.7.10 Druid Pool 1.0.15 patchca 1.0.0 Jetty 9.2.7.v20150116 项目包结构 该项目是典型的Maven WEB项目，对于Maven WEB项目的结构不再赘述，这里对各种包做一下解释： annotation 注解包，里面是自己写的注解类，主要混淆对象 controller SpringMVC的控制器包，主要混淆对象 credntials Shiro的自定义凭证，次要混淆对象 dao DAO包，主要混淆对象 exception 异常包，自定义了一些异常，主要混淆对象 filter Shiro的自定义过滤器，次要混淆对象 interceptor Shiro的自定义拦截器，次要混淆对象 job SpringTASK的定时任务包，次要混淆对象 mapper Mybatis的XML映射文件包，非混淆对象 model 实体包，非混淆对象 realm Shiro的自定义域包，次要混淆对象 service 实体的服务包，次要混淆对象 token Shiro的自定义令牌包，次要混淆对象 utils 公司自己的工具类，主要混淆对象 主要混淆对象 对类的名称、属性、方法名都进行混淆次要混淆对象 对类的名称不混淆，类的属性、方法名选择性混淆非混淆对象 不进行混淆，混淆后可能出现异常 Maven 配置(pom.xml)本文的重头戏，使用Maven集成的ProGuard插件，混淆配置不用单独建立文件 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;project xmlns=“http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=“http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;groupId&gt;…&lt;/groupId&gt; &lt;artifactId&gt;zhukun.shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 属性--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;properties&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 项目编码--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;project.build.sourceEncoding&gt;UTF-8&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;project.build.sourceEncoding&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 单元测试包--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;junit.version&gt;4.12&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;junit.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- JAVAEE支持包--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;jstl.version&gt;1.2&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;jstl.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;servlet.version&gt;3.1.0&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;servlet.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 日志包--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;log4j.version&gt;1.2.17&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;log4j.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;slf4j.version&gt;1.7.10&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;slf4j.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;aspectj.version&gt;1.6.12&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;aspectj.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- commons支持--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;commons-logging.version&gt;1.1.3&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;commons-logging.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;commons-collections.version&gt;3.2.1&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;commons-collections.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;commons-fileupload.version&gt;1.3.1&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;commons-fileupload.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- shiro安全框架--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;shiro.version&gt;1.2.3&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;shiro.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- druid连接池--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;druid.version&gt;1.0.15&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;druid.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 数据库及数据库框架--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mysql.version&gt;5.1.30&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mysql.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mybatis.version&gt;3.3.0&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mybatis.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mybatis-spring.version&gt;1.2.3&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mybatis-spring.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- Mybatis分页插件--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mybatis-paginator.version&gt;1.2.16&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mybatis-paginator.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- Mybatis生成器插件--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mybatis-generator.version&gt;1.3.2&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mybatis-generator.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- Spring及SpringMVC支持包--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;spring.version&gt;4.1.1.RELEASE&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;spring.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;jackson.version&gt;2.5.0&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;jackson.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 验证码支持包--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;patchca.version&gt;1.0.0&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;patchca.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- Jetty插件--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;jetty.version&gt;9.2.7.v20150116&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;jetty.version&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- Maven编译插件--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;maven-compiler.version&gt;2.3.2&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;maven-compiler.version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;properties&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependencies&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;junit&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;junit&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${junit.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;javax.servlet&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;jstl&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${jstl.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;log4j&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;log4j&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${log4j.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.aspectj&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;aspectjweaver&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${aspectj.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.slf4j&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;slf4j-log4j12&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${slf4j.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;commons-logging&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;commons-logging&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${commons-logging.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.apache.shiro&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;shiro-core&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${shiro.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.apache.shiro&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;shiro-web&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${shiro.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.apache.shiro&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;shiro-spring&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${shiro.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.apache.shiro&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;shiro-ehcache&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${shiro.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.apache.shiro&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;shiro-quartz&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${shiro.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;commons-collections&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;commons-collections&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${commons-collections.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;mysql&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;mysql-connector-java&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${mysql.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;com.alibaba&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;druid&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${druid.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;javax.servlet&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;javax.servlet-api&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${servlet.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;commons-fileupload&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;commons-fileupload&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${commons-fileupload.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.mybatis&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;mybatis&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${mybatis.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.mybatis&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;mybatis-spring&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${mybatis-spring.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;com.github.miemiedev&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;mybatis-paginator&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${mybatis-paginator.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;com.fasterxml.jackson.core&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;jackson-core&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${jackson.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;com.fasterxml.jackson.core&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;jackson-databind&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${jackson.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;com.fasterxml.jackson.core&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;jackson-annotations&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${jackson.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.springframework&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;spring-core&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${spring.version}&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.springframework&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;spring-webmvc&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${spring.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.springframework&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;spring-context-support&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${spring.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.springframework&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;spring-orm&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${spring.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.springframework&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;spring-test&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${spring.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;scope&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;scope&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.patchca&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;patchca&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${patchca.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;dependencies&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;build&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;finalName&gt;shiro-spring&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;finalName&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!--使Maven打包时能打包src目录下的XML文件--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;resources&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;resource&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;directory&gt;src/main/java&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;directory&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;includes&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;include&gt;**/*.xml&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;include&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;includes&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;resource&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;resource&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;directory&gt;src/main/resources&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;directory&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;resource&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;resources&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugins&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;maven-compiler-plugin&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${maven-compiler.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;source&gt;1.7&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;source&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;target&gt;1.7&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;target&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;encoding&gt;UTF-8&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;encoding&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.eclipse.jetty&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;jetty-maven-plugin&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${jetty.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;webApp&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;contextPath&gt;/shiro-spring&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;contextPath&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;webApp&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;httpConnector&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 设置端口--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;port&gt;8080&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;port&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;httpConnector&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- MyBatis自动生成Mapper插件--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;org.mybatis.generator&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;mybatis-generator-maven-plugin&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;${mybatis-generator.version}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;verbose&gt;true&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;verbose&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;overwrite&gt;true&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;overwrite&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- ProGuard混淆插件--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt;com.github.wvengen&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt;proguard-maven-plugin&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt;2.0.11&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;version&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;executions&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;execution&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 混淆时刻，这里是打包的时候混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;phase&gt;package&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;phase&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;goals&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 使用插件的什么功能，当然是混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;goal&gt;proguard&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;goal&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;goals&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;execution&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;executions&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 是否将生成的PG文件安装部署--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;attach&gt;true&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;attach&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 是否混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;obfuscate&gt;true&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;obfuscate&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 指定生成文件分类 --&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;attachArtifactClassifier&gt;pg&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;attachArtifactClassifier&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;options&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- JDK目标版本1.7--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-target 1.7&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不做收缩（删除注释、未被引用代码）--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-dontshrink&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不做优化（变更代码实现逻辑）--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-dontoptimize&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不路过非公用类文件及成员--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-dontskipnonpubliclibraryclasses&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-dontskipnonpubliclibraryclassmembers&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 优化时允许访问并修改有修饰符的类和类的成员 --&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-allowaccessmodification&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 确定统一的混淆类的成员名称来增加混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-useuniqueclassmembernames&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆所有包名，本人测试混淆后WEB项目问题实在太多，毕竟Spring配置中有大量固定写法的包名--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keeppackagenames&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆所有特殊的类--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keepattributes Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,LocalVariable*Table,*Annotation*,Synthetic,EnclosingMethod&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆所有的set/get方法，毕竟项目中使用的部分第三方框架（例如Shiro）会用到大量的set/get映射--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keepclassmembers public class * {void set*(***);*** get*();}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆job包下的所有类名，且类中的方法也不混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.job.** { &amp;lt;methods&amp;gt;; }&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆filter包下的所有类名，这里主要是对Shiro的路踢人过滤器混淆，对类的属性和方法进行了混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.filter.** &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆凭证包下的所有类名，但对类中的属性、方法进行混淆，原因是Spring配置中用到了这个类名--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.credntials.** &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 混淆目的同上，这个是拦截器的包，包中有防止重复提交的拦截器--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.interceptor.** &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 混淆目的同上，这个是域包，包中有用户登录域--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.realm.** &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 不混淆model包中的所有类以及类的属性及方法，实体包，混淆了会导致ORM框架及前端无法识别--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.model.** {*;}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 以下两个包因为大部分是Spring管理的Bean，不对包类的类名进行混淆，但对类中的属性和方法混淆--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.service.** &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt;-keep class com.chinatelecom.gz.wy.zhukun.shiro_spring.dao.**&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;option&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;options&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;outjar&gt;${project.build.finalName}-pg.jar&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;outjar&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 添加依赖，这里你可以按你的需要修改，这里测试只需要一个JRE的Runtime包就行了 --&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;libs&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;lib&gt;${java.home}/lib/rt.jar&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;lib&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;libs&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 加载文件的过滤器，就是你的工程目录了--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;inFilter&gt;com/chinatelecom/gz/wy/zhukun/shiro_spring/**&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;inFilter&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 对什么东西进行加载，这里仅有classes成功，毕竟你也不可能对配置文件及JSP混淆吧--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;injar&gt;classes&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;injar&gt; &lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 输出目录--&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;outputDirectory&gt;${project.build.directory}&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;outputDirectory&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;configuration&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugin&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;plugins&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;build&gt; &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;/span&gt;&lt;span class=&quot;hljs-title&quot;&gt;project&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;``` 以上代码中的注释足够各位参考了，若有问题欢迎留言 ### 执行 clean package -DskipTests 使用Maven运行以上代码，执行完成后在target目录中会生成三个文件： * classes-pg.jar 混淆后的classes文件，里面包含完整的项目结构 * proguard_map.txt 混淆内容的映射 * proguard_seed.txt 参与混淆的类 混淆完成后，将classes-pg.jar解压到应用服务器覆盖原有的classes文件，通常目录为 X:\jetty9或tomcat7\webapps\shiro-spring\WEB-INF\classes 运行服务，项目运行正常 ### 反编译 既然是混淆了的代码，那我们现在作为盗码者来反编译一下classes文件 可以看出，混淆成功了，盗码者读起来不是一二般的痛苦，我们的目的已经达到 ### 遗留问题 1. 虽然混淆是在Maven打包的时候进行，但是生成的war包及classes目录并未混淆，还需要将jar包中的内容提取，比较麻烦，不知道有没有让生成的war包就是已经混淆的办法。 2. 本人的JAVA环境是JDK1.7 64位，其它的JDK并未尝试 3. 不能对Spring等配置文件混淆，这样包结构还是存在，减弱了盗码者的读码难度 ### 最后 欢迎大家讨论更加的代码保护方案，代码是我们辛苦的成果，绝不让他人非法盗取。当然，本文在非本人的同意下也禁止盗用，转载的话说明出处，谢谢合作！ 注：本文中提到的项目源码为商业机密，恕不提供，谢谢！]]></content>
      <tags>
        <tag>Proguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用proguard对java web工程代码混淆]]></title>
    <url>%2Fpost%2F9357e641.html</url>
    <content type="text"><![CDATA[目标：将代码混淆，也就是给第三方源代码，让他们只能运行，却看不懂代码。 用到的工具：混淆jar的工具：proguard5.1下载地址：http://download.csdn.net/detail/lk7688535/9625472反编译jar的工具：xjad2.2下载地址：http://download.csdn.net/detail/lk7688535/9625486 操作步骤：见这篇文章：http://blog.csdn.net/zhangdaiscott/article/details/45368261懒得搬运了，这篇文章写得很详细。 操作的时候如果遇到警告说某个类中的方法找不到的话，只需要将这个包下的类在.pro文件里声明-dontwarn com.parse.**具体参考：http://stackoverflow.com/questions/24765588/proguard-cannot-find-referenced-libraries；stack-overflow，很好很强大。 如上操作后便得到混淆后的jar包，再用xjad反编译就可得到混淆后的源代码了~]]></content>
      <tags>
        <tag>Proguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql双机热备的实现]]></title>
    <url>%2Fpost%2Fd7afbc1d.html</url>
    <content type="text"><![CDATA[转：http://blog.csdn.net/qq394829044/article/details/53203645 Mysql数据库没有增量备份的机制，当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制，其实就是把主数据库的所有的数据同时写到备份的数据库中。实现mysql数据库的热备份。 要想实现双机的热备，首先要了解主从数据库服务器的版本的需求。要实现热备mysql的版本都高于3.2。还有一个基本的原则就是作为从数据库的数据版本可以高于主服务器数据库的版本，但是不可以低于主服务器的数据库版本。 当然要实现mysql双机热备，除了mysql本身自带的REPLICATION功能可以实现外，也可以用Heartbeat这个开源软件来实现。不过本文主要还是讲如何用mysql自带的REPLICATION来实现mysql双机热备的功能。 1. 准备服务器由于Mysql不同版本之间的（二进制日志）binlog格式可能会不太一样，因此最好的搭配组合是主（Master）服务器的Mysql版本和从（Slave）服务器版本相同或者更低，主服务器的版本肯定不能高于从服务器版本。 本次我用于测试的两台服务器版本都是Mysql-5.5.17。 2. Mysql 建立主－从服务器双机热备配置步骤2.1环境描述A服务器（主服务器Master）：59.151.15.36 B服务器（从服务器Slave）：218.206.70.146 主从服务器的Mysql版本皆为5.5.17 Linux环境下 将主服务器需要同步的数据库内容进行备份一份，上传到从服务器上，保证始初时两服务器中数据库内容一致。 不过这里说明下，由于我是利用Mysql在安装后就有的数据库test进行测试的，所以两台服务器里面是没有建立表的，只不分别在test里面建立了同样的一张空表tb_mobile; Sql语句如下： mysql&gt; create table tb_mobile( mobile VARCHAR(20) comment’手机号码’, time timestamp DEFAULT now() comment’时间’ ); 2.2 主服务器Master配置2.2.1 创建同步用户 进入mysql操作界面，在主服务器上为从服务器建立一个连接帐户，该帐户必须授予REPLICATION SLAVE权限。因为从mysql版本3.2以后就可以通过REPLICATION对其进行双机热备的功能操作。 操作指令如下： mysql&gt; grant replication slave on . to ‘replicate‘@’218.206.70.146’ identified by ‘123456’; mysql&gt; flush privileges; 创建好同步连接帐户后，我们可以通过在从服务器（Slave）上用replicat帐户对主服务器（Master）数据库进行访问下，看下是否能连接成功。 在从服务器（Slave）上输入如下指令： [root@YD146 ~]# mysql -h59.151.15.36 -ureplicate -p123456 如果出现下面的结果，则表示能登录成功，说明可以对这两台服务器进行双机热备进行操作。 2.2.2 修改mysql配置文件 如果上面的准备工作做好，那边我们就可以进行对mysql配置文件进行修改了，首先找到mysql配置所有在目录，一般在安装好mysql服务后，都会将配置文件复制一一份出来放到/ect目录下面，并且配置文件命名为：my.cnf。即配置文件准确目录为/etc/my.cnf (Linux下用rpm包安装的MySQL是不会安装/etc/my.cnf文件的， 至于为什么没有这个文件而MySQL却也能正常启动和作用，在点有两个说法， 第一种说法，my.cnf只是MySQL启动时的一个参数文件，可以没有它，这时MySQL会用内置的默认参数启动， 第二种说法，MySQL在启动时自动使用/usr/share/mysql目录下的my-medium.cnf文件，这种说法仅限于rpm包安装的MySQL， 解决方法，只需要复制一个/usr/share/mysql目录下的my-medium.cnf文件到/etc目录，并改名为my.cnf即可。) 找到配置文件my.cnf打开后，在[mysqld]下修改即可： [mysqld] server-id = 1 //唯一id log-bin=mysql-bin //其中这两行是本来就有的，可以不用动，添加下面两行即可.指定日志文件 binlog-do-db = test //记录日志的数据库 binlog-ignore-db = mysql //不记录日志的数据库 2.2.3 重启mysql服务 修改完配置文件后，保存后，重启一下mysql服务，如果成功则没问题。 2.2.4 查看主服务器状态 进入mysql服务后，可通过指令查看Master状态，输入如下指令： 注意看里面的参数，特别前面两个File和Position，在从服务器（Slave）配置主从关系会有用到的。 注：这里使用了锁表，目的是为了产生环境中不让进新的数据，好让从服务器定位同步位置，初次同步完成后，记得解锁。 2.3 从服务器Slave配置2.3.1修改配置文件 因为这里面是以主－从方式实现mysql双机热备的，所以在从服务器就不用在建立同步帐户了，直接打开配置文件my.cnf进行修改即可，道理还是同修改主服务器上的一样，只不过需要修改的参数不一样而已。如下： [mysqld] server-id = 2 log-bin=mysql-bin replicate-do-db = test replicate-ignore-db = mysql,information_schema,performance_schema 2.3.2重启mysql服务 修改完配置文件后，保存后，重启一下mysql服务，如果成功则没问题。 2.3.3用change mster 语句指定同步位置 这步是最关键的一步了，在进入mysql操作界面后，输入如下指令： mysql&gt;stop slave; //先停步slave服务线程，这个是很重要的，如果不这样做会造成以下操作不成功。 mysql&gt;change master to master_host=’59.151.15.36’,master_user=’replicate’,master_password=’123456’, master_log_file=’ mysql-bin.000016 ‘,master_log_pos=107; 注：master_log_file, master_log_pos由主服务器（Master）查出的状态值中确定。也就是刚刚叫注意的。master_log_file对应File, master_log_pos对应Position。Mysql 5.x以上版本已经不支持在配置文件中指定主服务器相关选项。 遇到的问题，如果按上面步骤之后还出现如下情况： 则要重新设置slave。指令如下 mysql&gt;stop slave; mysql&gt;reset slave; 之后停止slave线程重新开始。成功后，则可以开启slave线程了。 mysql&gt;start slave; 2.3.4查看从服务器（Slave）状态 用如下指令进行查看 mysql&gt; show slave status\G; 查看下面两项值均为Yes，即表示设置从服务器成功。 Slave_IO_Running: Yes Slave_SQL_Running: Yes 2.4 测试同步之前开始已经说过了在数据库test只有一个表tb_mobile没有数据，我们可以先查看下两服务器的数据库是否有数据： Master:59.151.15.36 Slave:218.206.70.146 好了，现在可以在Master服务器中插入数据看下是否能同步。 Master:59.151.15.36 Slave:218.206.70.146 可以从上面两个截图上看出，在Master服务器上进行插入的数据在Slave服务器可以查到，这就表示双机热备配置成功了。 3. Mysql 建立主－主服务器双机热备配置步骤服务器还是用回现在这两台服务器 3.1创建同步用户 同时在主从服务器建立一个连接帐户，该帐户必须授予REPLIATION SLAVE权限。这里因为服务器A和服务器B互为主从，所以都要分别建立一个同步用户。 服务器A： mysql&gt; grant replication slave on . to ‘replicate‘@’218.206.70.146’ identified by ‘123456’; mysql&gt; flush privileges; 服务器B： mysql&gt; grant replication slave on . to ‘replicate‘@’59.151.15.36’ identified by ‘123456’; mysql&gt; flush privileges; 3.2修改配置文件my.cnf 服务器A [mysqld] server-id = 1 log-bin=mysql-bin binlog-do-db = test binlog-ignore-db = mysql #主－主形式需要多添加的部分 log-slave-updates sync_binlog = 1 auto_increment_offset = 1 auto_increment_increment = 2 replicate-do-db = test replicate-ignore-db = mysql,information_schema 服务器B： [mysqld] server-id = 2 log-bin=mysql-bin replicate-do-db = test replicate-ignore-db = mysql,information_schema,performance_schema #主－主形式需要多添加的部分 binlog-do-db = test binlog-ignore-db = mysql log-slave-updates sync_binlog = 1 auto_increment_offset = 2 auto_increment_increment = 2 3.3分别重启A服务器和B服务器上的mysql服务 重启服务器方式和上面的一样，这里就不做讲解了。 3.4分别查A服务器和B服务器作为主服务器的状态 服务器A： 服务器B： 3.5分别在A服务器和B服务器上用change master to 指定同步位置 服务器A： mysql&gt;change master to master_host=’218.206.70.146’,master_user=’replicate’,master_password=’123456’, master_log_file=’ mysql-bin.000011 ‘,master_log_pos=497; 服务器B： mysql&gt;change master to master_host=’59.151.15.36’,master_user=’replicate’,master_password=’123456’, master_log_file=’ mysql-bin.000016 ‘,master_log_pos=107; 3.6 分别在A和B服务器上重启从服务线程 mysql&gt;start slave; 3.7 分别在A和B服务器上查看从服务器状态 mysql&gt;show slave status\G; 查看下面两项值均为Yes，即表示设置从服务器成功。 Slave_IO_Running: Yes Slave_SQL_Running: Yes 3.8 测试主－主同步例子 测试服务器A： 在服务器A上插入一条语句如下图所示： 之后在服务器B上查看是否同步如下图所示： 测试服务器B： 在服务器B上插入一条语句如下图所示： 然后在从服务器A上查看是否有同步数据如下图所示： 最后从结果可以看出主－主形式的双机热备是能成功实现的。 4. 配置参数说明Server-id ID值唯一的标识了复制群集中的主从服务器，因此它们必须各不相同。Master_id必须为1到232－1之间的一个正整数值，slave_id值必须为2到232－1之间的一个正整数值。 Log-bin 表示打开binlog，打开该选项才可以通过I/O写到Slave的relay-log，也是可以进行replication的前提。 Binlog-do-db 表示需要记录二进制日志的数据库。如果有多个数据可以用逗号分隔，或者使用多个binlog-do-dg选项。 Binglog-ingore-db 表示不需要记录二进制日志的数据库，如果有多个数据库可用逗号分隔，或者使用多binglog-ignore-db选项。 Replicate-do-db 表示需要同步的数据库，如果有多个数据可用逗号分隔，或者使用多个replicate-do-db选项。 Replicate-ignore-db 表示不需要同步的数据库，如果有多个数据库可用逗号分隔，或者使用多个replicate-ignore-db选项。 Master-connect-retry master-connect-retry=n表示从服务器与主服务器的连接没有成功，则等待n秒（s）后再进行管理方式（默认设置是60s）。如果从服务器存在mater.info文件，它将忽略些选项。 Log-slave-updates 配置从库上的更新操作是否写入二进制文件，如果这台从库，还要做其他从库的主库，那么就需要打这个参数，以便从库的从库能够进行日志同步。 Slave-skip-errors 在复制过程，由于各种原因导致binglo中的sql出错，默认情况下，从库会停止复制，要用户介入。可以设置slave-skip-errors来定义错误号，如果复制过程中遇到的错误是定义的错误号，便可以路过。如果从库是用来做备份，设置这个参数会存在数据不一致，不要使用。如果是分担主库的查询压力，可以考虑。 --slave-skip-errors=[err_code1,err_code2,…|all|ddl_exist_errors] Command-Line Format–slave-skip-errors=nameOption-File Formatslave-skip-errorsSystem Variable Nameslave_skip_errorsVariable ScopeGlobalDynamic VariableNo Permitted ValuesTypestringDefaultOFFValid ValuesOFF[list of error codes]allddl_exist_errorsMySQL 5.6 as well as MySQL Cluster NDB 7.3 support an additional shorthand valueddl_exist_errors, which is equivalent to the error code list 1007,1008,1050,1051,1054,1060,1061,1068,1094,1146.Examples:–slave-skip-errors=1062,1053–slave-skip-errors=all–slave-skip-errors=ddl_exist_errorsSync_binlog=1 Or NSync_binlog的默认值是0，这种模式下，MySQL不会同步到磁盘中去。这样的话，Mysql依赖操作系统来刷新二进制日志binary log，就像操作系统刷新其他文件的机制一样。因此如果操作系统或机器（不仅仅是Mysql服务器）崩溃，有可能binlog中最后的语句丢失了。要想防止这种情况，可以使用sync_binlog全局变量，使binlog在每Ｎ次binlog写入后与硬盘同步。当sync_binlog变量设置为１是最安全的，因为在crash崩溃的情况下，你的二进制日志binary log只有可能丢失最多一个语句或者一个事务。但是，这也是最慢的一种方式（除非磁盘有使用带蓄电池后备电源的缓存cache,使得同步到磁盘的操作非常快）。即使sync_binlog设置为１，出现崩溃时，也有可能表内容和binlog内容之间存在不一致性。如果使用InnoDB表，Mysql服务器处理COMMIT语句，它将整个事务写入binlog并将事务提交到InnoDB中。如果在两次操作之间出现崩溃，重启时，事务被InnoDB回滚，但仍然存在binlog中。可以用-innodb-safe-binlog选项来增加InnoDB表内容和binlog之间的一致性。（注释：在Mysql 5.1版本中不需要-innodb-safe-binlog；由于引入了XA事务支持，该选项作废了），该选项可以提供更大程度的安全，使每个事务的binlog(sync_binlog=1)和（默认情况为真）InnoDB日志与硬盘同步，该选项的效果是崩溃后重启时，在滚回事务后，Mysql服务器从binlog剪切回滚的InnoDB事务。这样可以确保binlog反馈InnoDB表的确切数据等，并使从服务器保持与主服务器保持同步（不接收回滚的语句）。Auto_increment_offset和Auto_increment_incrementAuto_increment_increment和auto_increment_offset用于主－主服务器（master-to-master）复制，并可以用来控制AUTO_INCREMENT列的操作。两个变量均可以设置为全局或局部变量，并且假定每个值都可以为1到65,535之间的整数值。将其中一个变量设置为0会使该变量为1。这两个变量影响AUTO_INCREMENT列的方式：auto_increment_increment控制列中的值的增量值，auto_increment_offset确定AUTO_INCREMENT列值的起点。如果auto_increment_offset的值大于auto_increment_increment的值，则auto_increment_offset的值被忽略。例如：表内已有一些数据，就会用现在已有的最大自增值做为初始值。### 如何解决MySQL主从同步错误的SQL解决：stop slave;#表示跳过一步错误，后面的数字可变set global sql_slave_skip_counter =1;start slave;之后再用mysql&gt; show slave status\G 查看：Slave_IO_Running: YesSlave_SQL_Running: Yesok，现在主从同步状态正常了。`]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源飞控介绍]]></title>
    <url>%2Fpost%2F47393678.html</url>
    <content type="text"><![CDATA[所谓开源飞控就是建立在开源思想基础上的飞行自主控制器项目（Open Source AutoPilot），同时包含开源软件和开源硬件，而软件则包含飞控硬件中的固件和地面站软件。 一 开源飞控发展 第一代开源飞控系统使用Arduino或其他类似开源电子平台为基础，扩展连接各种MEMS传感器，能够让无人机能平稳地飞起来。 主要特点是模块化和可扩展能力。 第二代开源飞控系统大多拥有自己的开源硬件、开发环境和社区，采用全集成的硬件架构。 主要特点是高度集成、高可靠，其功能已经接近商业自动驾驶仪 第三代开源飞控系统将会在软件、人工智能以及云应用方面进行革新。加入集群飞行、图像识别、自主避障、自动跟踪飞行等高级飞行功能，向机器视觉、集群化、开发过程平台化的方向发展。 二开源飞控介绍 Arduino飞控 APM飞控 PX4和PIXHAWK Openpilot和Taulabs Multiwiicopter KK飞控 Paparazzi 三 主要平台对比]]></content>
      <tags>
        <tag>飞控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国外物联网平台（1）：亚马逊AWS IoT]]></title>
    <url>%2Fpost%2F2deb356.html</url>
    <content type="text"><![CDATA[# 国外物联网平台（1）——亚马逊AWS IoT马智## 平台定位 AWS IoT是一款托管的云平台，使互联设备可以轻松安全地与云应用程序及其他设备交互。 AWS IoT可支持数十亿台设备和数万亿条消息，并且可以对这些消息进行处理并将其安全可靠地路由至 AWS 终端节点和其他设备。应用程序可以随时跟踪所有设备并与其通信，即使这些设备未处于连接状态也不例外。 使用AWS Lambda、Amazon Kinesis、Amazon S3、Amazon Machine Learning、Amazon DynamoDB、Amazon CloudWatch、AWS CloudTrail 和内置 Kibana 集成的 Amazon Elasticsearch Service 等AWS服务来构建IoT应用程序，以便收集、处理和分析互连设备生成的数据并对其执行操作，且无需管理任何基础设施。## 架构## 与AWS IoT平台集成的AWS服务 Amazon DynamoDB—托管NoSQL数据库 Amazon Kinesis—大规模流式数据实时处理 AWS Lambda—EC2云虚拟机运行代码响应事件 Amazon Simple Storage Service（S3）—可扩展云存储 Amazon Simple Notification—推送通知服务 Amazon Simple Queue Service—消息队列服务## 设备SDK AWS IoT 设备 SDK 使用 MQTT、HTTP 或 WebSockets 协议将硬件设备连接到 AWS IoT，硬件设备无缝安全地与 AWS IoT 提供的设备网关和设备影子协作。 设备 SDK 支持 C、JavaScript 、Arduino、Java和Python。 设备 SDK 包含开源库、带有示例的开发人员指南和移植指南，用户根据硬件平台构建 IoT 产品或解决方案。## 设备网关 AWS IoT 设备网关支持设备安全高效地与 AWS IoT 进行通信。设备网关可以使用发布/订阅模式交换消息，从而支持一对一和一对多的通信。凭借此一对多的通信模式，AWS IoT 将支持互连设备向多名给定主题的订阅者广播数据。 设备网关支持 MQTT、WebSocket 和 HTTP 1.1 协议，也支持私有协议。 设备网关可自动扩展，以支持 10 亿多台设备，而无需预配置基础设施。## 认证和授权 AWS IoT 在所有连接点处提供相互身份验证和加密。AWS IoT 支持 AWS 身份验证方法（称为”SigV4”）以及基于身份验证的 X.509 证书。使用 HTTP 的连接可以使用任一方法，使用 MQTT 的连接可以使用基于证书的身份验证，使用 WebSockets 的连接可以使用 SigV4。 使用 AWS IoT 生成的证书以及由首选证书颁发机构 (CA) 签署的证书，将所选的角色和/或策略映射到每个证书，以便授予设备或应用程序访问权限，或撤消访问权限。 通过控制台或使用 API 创建、部署并管理设备的证书和策略。这些设备证书可以预配置、激活和与使用 AWS IAM 配置的相关策略关联。 AWS IoT 还支持用户移动应用使用 Amazon Cognito 进行连接，Amazon Cognito 将负责执行必要的操作来为应用用户创建唯一标识符并获取临时的、权限受限的 AWS 凭证。## 注册表 注册表将创建设备标识并跟踪元数据，如设备的属性和功能。 注册表向格式一致的每台设备分配唯一的标识，而不管设备的类型和连接方式为何。此外，它还支持描述设备功能的元数据，例如传感器是否报告温度，以及数据是华氏度还是摄氏度。 注册表存储有关设备的元数据，无需支付额外费用；并且需要每隔 7 天至少访问或更新注册表条目一次，注册表中的元数据就不会过期。以JSON格式存储的设备注册表信息## 设备影子（Shadow） 设备影子保留每台设备的最后报告状态和期望的未来状态，即便设备处于离线状态。 通过 API 或使用规则引擎，获取设备的最后报告状态或设置期望的未来状态。 应用程序可以设置设备的期望未来状态，而无需说明设备的当前状态。AWS IoT 将比较期望未来状态和最后报告状态之间的差异，并命令设备”弥补差异”。 设备 SDK 能够轻松地同步其状态及其影子，并响应通过影子设置的期望的未来状态。 设备影子免费存储设备状态多达一年。如果至少每年更新一次状态，则设备影子将永久保留状态；否则状态将过期。## 设备影子（Shadow）流程## 设备影子（Shadow）格式## 设备影子（Shadow）服务设备影子服务使用MQTT话题，便于应用和设备之间的通信，下面是相关的MQTT QoS 1话题：$aws/things/{thingName}/shadow/update$aws/things/{thingName}/shadow/get$aws/things/{thingName}/shadow/delete$aws/things/{thingName}/shadow/update/accepted$aws/things/{thingName}/shadow/update/rejected$aws/things/{thingName}/shadow/update/delta$aws/things/{thingName}/shadow/get/accepted$aws/things/{thingName}/shadow/get/rejected$aws/things/{thingName}/shadow/delete/accepted$aws/things/{thingName}/shadow/delete/rejected设备SDK（C-SDK、JS-SDK）将影子功能内置在设备中，能够使设备与影子服务之间自动同步状态。## 规则引擎 规则引擎验证发布到 AWS IoT 的入站消息，并根据定义的业务规则转换这些消息并将它们传输到另一台设备或云服务。规则可以应用至一台或多台设备中的数据，并且它可以并行执行一个或多 个操作。 规则引擎还可以将消息路由到 AWS 终端节点，包括 AWS Lambda、Amazon Kinesis、Amazon S3、Amazon Machine Learning、Amazon DynamoDB、Amazon CloudWatch 和内置 Kibana 集成的 Amazon Elasticsearch Service。外部终端节点可以使用 AWS Lambda、Amazon Kinesis 和 Amazon Simple Notification Service (SNS) 进行连接。 使用类似 SQL 的语句编写规则。例如：如果温度读数超出特定阈值，则它可以触发规则以便将数据传输到 AWS Lambda；如果此温度超出其他 5 台设备的平均值 15%，则应采取措施。 规则引擎将提供数十个可用于转换数据的可用功能，并且可以通过 AWS Lambda 创建无限个功能。例如，如果正在处理各种不同的数值，则可以取传入数字的平均值。规则还会触发在 AWS Lambda 中执行 Java、Node.js 或 Python 代码，从而提供最高灵活度以及处理设备数据的能力。## 规则引擎集成其它云服务规则引擎验证发布至AWS IoT的消息请求，基于业务规则转换消息请求并发布至其它服务，例如： 富集化或过滤从设备收集的数据 将设备数据写入一个亚马逊DynamoDBm数据库 保存文件至亚马逊S3 发送一个推送通知到所有亚马逊SNS用户 向亚马逊SQS队列发布数据 调用Lambda函数抽取数据 使用亚马逊Kinesis处理大量的设备消息数据 发送数据至亚马逊Elasticsearch服务 捕获一条CloudWatch测量数据 更新一条CloudWatch告警 把一条MQTT消息数据发送至亚马逊机器学习服务，基于亚马逊机器学习模型进行预测## 规则引擎&amp;实时流式数据处理N:1 入站的传感器流式数据（数据降噪）规则引擎过滤、转换、汇总传感器数据后，发送至亚马逊Kinesis处理实时流式数据Kinesis流式数据共享至其它业务系统将流式数据的实时处理结果导入至数据库、应用或其它亚马逊服务## 规则引擎&amp;推送通知服务推送通知支持苹果APNS推送通知服务、谷歌GCM云消息服务、亚马逊ADM设备消息服务，微软WNS推送服务亚马逊SNS推送通知服务-&gt;HTTP协议终端（短信、邮件）通过亚马逊SNS推送通知服务，调用第三方HTTP协议终端，支持订阅和重试## 规则引擎示例 – 使用机器学习预测函数{ “sql”: “SELECT FROM ‘iot/test’ where machinelearning_predict(‘my-model’, ‘arn:aws:iam::123456789012:role/my-iot-aml-role’, ).predictedLabel=1”, “ruleDisabled”: false, “awsIotSqlVersion”: “2016-03-23-beta”, “actions”: [{ “republish”: { “roleArn”: “arn:aws:iam::123456789012:role/my-iot-role”, “topic”: “my-mqtt-topic” } }]}上面是使用亚马逊机器学习预测函数machinelearning_predict 的规则示例，其含义是：如果机器学习预测函数处理MQTT消息后的结果是分类1，那么重新将此消息发布至一个话题。## 设备管理 支持全球或部分地区的固件升级 规则引擎在DynamoDBm数据库跟踪升级状态和进度 注册表存储设备的固件版本S3管理固件分发版本在S3中组织和保障和固件二进制文件消息代理使用话题模式通知设备分组通知设备分组固件更新信息，包括S3中的固件二进制文件URL地址## AWS IoT平台接口 AWS Command Line Interface (AWS CLI) 在Windows、Mac和Linux执行AWS IoT命令 AWS SDKs 使用特定语言API开发IoT应用 AWS IoT API 使用HTTP或者HTTPS请求开发IoT应用 AWS IoT Thing SDK for C * 在资源受限的设备上开发IoT应用，如MCU AWS IoT监控工具自动化监控工具 Amazon CloudWatch Alarms Amazon CloudWatch Logs Amazon CloudWatch Events AWS CloudTrail Log Monitoring 手工监控工具 AWS IoT 仪表盘 证书 策略 规则 设备 CloudWatch首页 当前告警和状态 告警和资源图表 服务健康度 CloudWatch 自定义仪表盘 自定义图表进行排障和监控趋势 搜索所有AWS资源指标 创建和修改告警参数 AWS IoT 初学者工具包 AWS IoT 初学者工具包旨在帮助进行原型开发和安全地连接 AWS IoT。 工具包内含开发微控制器开发板、传感器和执行器、AWS IoT 设备 SDK 以及入门指南。 AWS IoT 初学者工具包 - 支持的平台 AWS IoT生态 开发示例 - AWS IoT 按钮 创建设备 设备属性 创建证书 激活证书 创建策略 绑定证书与策略 绑定证书与设备 配置设备 使用MQTT客户端订阅设备消息 使用MQTT客户端查看设备消息 创建短信推送话题并订阅此话题 创建规则 创建规则的行为 测试订阅是否成功 作者：马智微信公众号：物联网那点事如果你想及时得到相关资讯，可以关注个人公众号。本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。]]></content>
      <tags>
        <tag>iot</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql主从配置（清晰的思路）]]></title>
    <url>%2Fpost%2F575d09df.html</url>
    <content type="text"><![CDATA[mysql主从配置。鄙人是在如下环境测试的： 主数据库所在的操作系统：win7 主数据库的版本：5.0 主数据库的ip地址：192.168.1.111 从数据库所在的操作系统：linux 从数据的版本：5.0 从数据库的ip地址：192.168.1.112 介绍完了环境，就聊聊配置步骤： 1、确保主数据库与从数据库一模一样。 例如：主数据库里的a的数据库里有b，c，d表，那从数据库里的就应该有一个模子刻出来的a的数据库和b，c，d表 2、在主数据库上创建同步账号。 GRANT REPLICATION SLAVE,FILE ON . TO ‘mstest‘@’192.168.1.112’ IDENTIFIED BY ‘123456’; 192.168.1.112：是运行使用该用户的ip地址 mstest：是新创建的用户名 123456：是新创建的用户名的密码 以上命令的详细解释，最好百度一下，写太多反到更加更不清思路。 3、配置主数据库的my.ini(因为是在window下，所以是my.ini不是my.cnf)。 [mysqld] server-id=1 log-bin=log binlog-do-db=mstest //要同步的mstest数据库,要同步多个数据库，就多加几个replicate-db-db=数据库名 binlog-ignore-db=mysql //要忽略的数据库 4、配置从数据库的my.cnf。 [mysqld] server-id=2 master-host=192.168.1.111 master-user=mstest //第一步创建账号的用户名 master-password=123456 //第一步创建账号的密码 master-port=3306 master-connect-retry=60 replicate-do-db=mstest //要同步的mstest数据库,要同步多个数据库，就多加几个replicate-db-db=数据库名 replicate-ignore-db=mysql //要忽略的数据库 5、验证是否成功 进入mysql，后输入命令:show slave status\G。将显示下图。如果slave_io_running和slave_sql_running都为yes，那么表明可以成功同步了 6、测试同步数据。 进入主数据库输入命令:insert into one(name) values(‘beijing’); 然后进入从数据库输入命令：select * from one; 如果此时从数据库有获取到数据，说明同步成功了，主从也就实现了]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql主从配置，实现读写分离]]></title>
    <url>%2Fpost%2Fdf7ad9c3.html</url>
    <content type="text"><![CDATA[大型网站为了软解大量的并发访问，除了在网站实现分布式负载均衡，远远不够。到了数据业务层、数据访问层，如果还是传统的数据结构，或者只是单单靠一台服务器扛，如此多的数据库连接操作，数据库必然会崩溃，数据丢失的话，后果更是 不堪设想。这时候，我们会考虑如何减少数据库的联接，一方面采用优秀的代码框架，进行代码的优化，采用优秀的数据缓存技术如：memcached,如果资金丰厚的话，必然会想到假设服务器群，来分担主数据库的压力。Ok切入今天微博主题，利用MySQL主从配置，实现读写分离，减轻数据库压力。这种方式，在如今很多网站里都有使用，也不是什么新鲜事情，今天总结一下，方便大家学习参考一下。 概述：搭设一台Master服务器（win8.1系统，Ip：192.168.0.104），搭设两台Slave服务器（虚拟机——一台Ubuntu，一台 Windows Server 2003） 原理：主服务器（Master）负责网站NonQuery操作，从服务器负责Query操作，用户可以根据网站功能模特性块固定访问Slave服务器，或者自己写个池或队列，自由为请求分配从服务器连接。主从服务器利用MySQL的二进制日志文件，实现数据同步。二进制日志由主服务器产生，从服务器响应获取同步数据库。 具体实现： 1、在主从服务器上都装上MySQL数据库，windows系统鄙人安装的是mysql_5.5.25.msi版本，Ubuntu安装的是mysql-5.6.22-linux-glibc2.5-i686.tar windows安装mysql就不谈了，一般地球人都应该会。鄙人稍微说一下Ubuntu的MySQL安装，我建议不要在线下载安装，还是离线安装的好。大家可以参考 http://www.linuxidc.com/Linux/2013-01/78716.htm 这位不知道大哥还是姐妹，写的挺好按照这个就能装上。在安装的时候可能会出现几种现象，大家可以参考解决一下： （1）如果您不是使用root用户登录，建议 su - root 切换到Root用户安装，那就不用老是 sudo 了。 （2）存放解压的mysql 文件夹，文件夹名字最好改成mysql （3）在./support-files/mysql.server start 启动MySQL的时候，可能会出现一个警告，中文意思是启动服务运行读文件时，忽略了my.cnf文件，那是因为my.cnf的文件权限有问题，mysql会认为该文件有危险不会执行。但是mysql还会启动成功，但如果下面配置从服务器参数修改my.cnf文件的时候，你会发现文件改过了，但是重启服务时，修改过后的配置没有执行，而且您 list一下mysql的文件夹下会发现很多.my.cnf.swp等中间文件。这都是因为MySQL启动时没有读取my.cnf的原因。这时只要将my.cnf的文件权限改成my_new.cnf的权限一样就Ok，命令：chmod 644 my.cnf就Ok （4）Ubuntu中修改文档内容没有Vim，最好把Vim 装上，apt-get install vim,不然估计会抓狂。 这时候我相信MySQL应该安装上去了。 2、配置Master主服务器 （1）在Master MySQL上创建一个用户‘repl’，并允许其他Slave服务器可以通过远程访问Master，通过该用户读取二进制日志，实现数据同步。 1231 mysql&gt;create user repl; //创建新用户2 //repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。3 mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;192.168.0.%&apos; IDENTIFIED BY &apos;mysql&apos;; （2）找到MySQL安装文件夹修改my.Ini文件。mysql中有好几种日志方式，这不是今天的重点。我们只要启动二进制日志log-bin就ok。 在[mysqld]下面增加下面几行代码 1231 server-id=1 //给数据库服务的唯一标识，一般为大家设置服务器Ip的末尾号2 log-bin=master-bin3 log-bin-index=master-bin.index （3）查看日志 mysql&gt; SHOW MASTER STATUS;+——————-+———-+————–+——————+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+——————-+———-+————–+——————+| master-bin.000001 | 1285 | | |+——————-+———-+————–+——————+1 row in set (0.00 sec) 重启MySQL服务 3、配置Slave从服务器（windows） （1）找到MySQL安装文件夹修改my.ini文件，在[mysqld]下面增加下面几行代码 my.cnf 配置 重启MySQL服务 （2）连接Master change master to master_host=’192.168.0.104’, //Master 服务器Ipmaster_port=3306,master_user=’repl’,master_password=’mysql’,master_log_file=’master-bin.000001’,//Master服务器产生的日志master_log_pos=0; （3）启动Slave start slave; 4、Slave从服务器（Ubuntu） （1）找到MySQL安装文件夹修改my.cnf文件,vim my.cnf s （2） ./support-files/myql.server restart 重启MySQL服务 , ./bin/mysql 进入MySQL命令窗口 （3）连接Master change master to master_host=’192.168.0.104’, //Master 服务器Ipmaster_port=3306,master_user=’repl’,master_password=’mysql’,master_log_file=’master-bin.000001’,//Master服务器产生的日志master_log_pos=0; （4）启动Slave start slave; OK所有配置都完成了，这时候大家可以在Master Mysql 中进行测试了，因为我们监视的时Master mysql 所有操作日志，所以，你的任何改变主服务器数据库的操作，都会同步到从服务器上。创建个数据库，表试试吧。。。]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sharding-jdbc之——分库分表实例]]></title>
    <url>%2Fpost%2F878fe4e8.html</url>
    <content type="text"><![CDATA[转载请注明出处：http://blog.csdn.net/l1028386804/article/details/79368021 一、概述之前，我们介绍了利用Mycat进行分库分表操作，Mycat分表操作是利用分库来进行的，单个库中的分表操作可结合MySQL的分区进行，这也是Mycat官方提倡的方式。那么，如何利用Mycat真正实现数据库的分库分表，可以私信我。今天，我们来看看sharding-jdbc，sharding-jdbc也是一款分库分表的“中间件”，不过，它并不向Mycat那样作为一个真正的中间件，它是一款以jar包的形式整合到业务中的插件，这就决定了它是轻量级的，用法也是十分简单的。 二、分库分表实战接下来，我们就利用sharding-jdbc进行数据库的分库分表操作。 1、创建数据库首先我们创建相应的数据库 123create database sharding_0; create database sharding_1; 这样我们就创建了两个数据库sharding_0和sharding_1; 接下来我们在两个库中创建相应的数据表，在两个库中分别进行如下SQL: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for t_student_00-- ----------------------------DROP TABLE IF EXISTS `t_student_00`;CREATE TABLE `t_student_00` ( `id` int(11) NOT NULL AUTO_INCREMENT, `student_id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for t_student_01-- ----------------------------DROP TABLE IF EXISTS `t_student_01`;CREATE TABLE `t_student_01` ( `id` int(11) NOT NULL AUTO_INCREMENT, `student_id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for t_user_00-- ----------------------------DROP TABLE IF EXISTS `t_user_00`;CREATE TABLE `t_user_00` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for t_user_01-- ----------------------------DROP TABLE IF EXISTS `t_user_01`;CREATE TABLE `t_user_01` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;-- ------------------------------ Table structure for t_user_02-- ----------------------------DROP TABLE IF EXISTS `t_user_02`;CREATE TABLE `t_user_02` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 这样，我们的数据库就准备好了。 #### 2、创建项目 接下来，我们就创建一个Maven项目，项目结构如下： #### 3、配置pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lyz&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;sharding-jdbc-mybatis&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.1.0.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.4&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dangdang&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-core&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; #### 4、创建数据库映射类 这里，我们创建两个数据库映射类：User类和Student类。 4-1、User类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.entity;import java.io.Serializable;/** * 用户类 * @author liuyazhuang * */public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; private Integer userId; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, userId=&quot; + userId + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 4-2、Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.entity;import java.io.Serializable;/** * 学生类 * @author liuyazhuang * */public class Student implements Serializable &#123; private static final long serialVersionUID = 8920597824668331209L; private Integer id; private Integer studentId; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getStudentId() &#123; return studentId; &#125; public void setStudentId(Integer studentId) &#123; this.studentId = studentId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;, studentId=&quot; + studentId + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; #### 5、创建Mapper类 5-1、UserMapper类 12345678910111213141516171819&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.mapper;import java.util.List;import com.lyz.sharding.entity.User; /** * 处理用户的数据操作接口 * @author liuyazhuang * */public interface UserMapper &#123; Integer insert(User u); List&lt;User&gt; findAll(); List&lt;User&gt; findByUserIds(List&lt;Integer&gt; userIds); &#125; 5-2、StudentMapper类 12345678910111213141516171819&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.mapper;import java.util.List;import com.lyz.sharding.entity.Student;/** * 处理学生的数据操作接口 * @author liuyazhuang * */public interface StudentMapper &#123; Integer insert(Student s); List&lt;Student&gt; findAll(); List&lt;Student&gt; findByStudentIds(List&lt;Integer&gt; studentIds); &#125; #### 6、创建service类 6-1、UserService类 1234567891011121314151617181920212223&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.service; import java.util.List;import com.lyz.sharding.entity.User;/** * 处理用户的Service * @author liuyazhuang * */public interface UserService &#123; public boolean insert(User u); public List&lt;User&gt; findAll(); public List&lt;User&gt; findByUserIds(List&lt;Integer&gt; ids); public void transactionTestSucess(); public void transactionTestFailure() throws IllegalAccessException; &#125; 6-2、StudentService类 1234567891011121314&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.service;import com.lyz.sharding.entity.Student;/** * 处理学生的service * @author liuyazhuang * */public interface StudentService &#123; boolean insert(Student student); &#125; #### 7、创建service的实现类 7-1、UserServiceImpl类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.service.impl; import java.util.List;import javax.annotation.Resource;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import com.lyz.sharding.entity.Student;import com.lyz.sharding.entity.User;import com.lyz.sharding.mapper.StudentMapper;import com.lyz.sharding.mapper.UserMapper;import com.lyz.sharding.service.UserService; @Service @Transactional public class UserServiceImpl implements UserService &#123; @Resource public UserMapper userMapper; @Resource public StudentMapper studentMapper; public boolean insert(User u) &#123; return userMapper.insert(u) &gt; 0 ? true :false; &#125; public List&lt;User&gt; findAll() &#123; return userMapper.findAll(); &#125; public List&lt;User&gt; findByUserIds(List&lt;Integer&gt; ids) &#123; return userMapper.findByUserIds(ids); &#125; @Transactional(propagation=Propagation.REQUIRED) public void transactionTestSucess() &#123; User u = new User(); u.setUserId(13); u.setAge(25); u.setName(&quot;war3 1.27&quot;); userMapper.insert(u); Student student = new Student(); student.setStudentId(21); student.setAge(21); student.setName(&quot;hehe&quot;); studentMapper.insert(student); &#125; @Transactional(propagation=Propagation.REQUIRED) public void transactionTestFailure() throws IllegalAccessException &#123; User u = new User(); u.setUserId(13); u.setAge(25); u.setName(&quot;war3 1.27 good&quot;); userMapper.insert(u); Student student = new Student(); student.setStudentId(21); student.setAge(21); student.setName(&quot;hehe1&quot;); studentMapper.insert(student); throw new IllegalAccessException(); &#125; &#125; 7-2、StudentServiceImpl类 1234567891011121314151617181920&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.lyz.sharding.entity.Student;import com.lyz.sharding.mapper.StudentMapper;import com.lyz.sharding.service.StudentService;@Service public class StudentServiceImpl implements StudentService&#123; @Resource public StudentMapper studentMapper; public boolean insert(Student student) &#123; return studentMapper.insert(student) &gt; 0 ? true : false; &#125; &#125; #### 8、创建分库逻辑 8-1、User分库逻辑UserSingleKeyDatabaseShardingAlgorithm类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.algorithm; import java.util.Collection; import java.util.LinkedHashSet; import com.dangdang.ddframe.rdb.sharding.api.ShardingValue; import com.dangdang.ddframe.rdb.sharding.api.strategy.database.SingleKeyDatabaseShardingAlgorithm; import com.google.common.collect.Range; /** * user表分库的逻辑函数 * @author liuyazhuang * */ public class UserSingleKeyDatabaseShardingAlgorithm implements SingleKeyDatabaseShardingAlgorithm&lt;Integer&gt;&#123; /** * sql 中关键字 匹配符为 =的时候，表的路由函数 */ public String doEqualSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; for (String each : availableTargetNames) &#123; if (each.endsWith(shardingValue.getValue() % 2 + &quot;&quot;)) &#123; return each; &#125; &#125; throw new IllegalArgumentException(); &#125; /** * sql 中关键字 匹配符为 in 的时候，表的路由函数 */ public Collection&lt;String&gt; doInSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(availableTargetNames.size()); for (Integer value : shardingValue.getValues()) &#123; for (String tableName : availableTargetNames) &#123; if (tableName.endsWith(value % 2 + &quot;&quot;)) &#123; result.add(tableName); &#125; &#125; &#125; return result; &#125; /** * sql 中关键字 匹配符为 between的时候，表的路由函数 */ public Collection&lt;String&gt; doBetweenSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(availableTargetNames.size()); Range&lt;Integer&gt; range = (Range&lt;Integer&gt;) shardingValue.getValueRange(); for (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123; for (String each : availableTargetNames) &#123; if (each.endsWith(i % 2 + &quot;&quot;)) &#123; result.add(each); &#125; &#125; &#125; return result; &#125; &#125; 8-2、Student分库逻辑StudentSingleKeyDatabaseShardingAlgorithm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.algorithm;import java.util.Collection; import java.util.LinkedHashSet; import com.dangdang.ddframe.rdb.sharding.api.ShardingValue; import com.dangdang.ddframe.rdb.sharding.api.strategy.database.SingleKeyDatabaseShardingAlgorithm; import com.google.common.collect.Range; /** * user表分库的逻辑函数 * @author liuyazhuang * */ public class StudentSingleKeyDatabaseShardingAlgorithm implements SingleKeyDatabaseShardingAlgorithm&lt;Integer&gt;&#123; /** * sql 中关键字 匹配符为 =的时候，表的路由函数 */ @Override public String doEqualSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; for (String each : availableTargetNames) &#123; if (each.endsWith(shardingValue.getValue() % 2 + &quot;&quot;)) &#123; return each; &#125; &#125; throw new IllegalArgumentException(); &#125; /** * sql 中关键字 匹配符为 in 的时候，表的路由函数 */ @Override public Collection&lt;String&gt; doInSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(availableTargetNames.size()); for (Integer value : shardingValue.getValues()) &#123; for (String tableName : availableTargetNames) &#123; if (tableName.endsWith(value % 2 + &quot;&quot;)) &#123; result.add(tableName); &#125; &#125; &#125; return result; &#125; /** * sql 中关键字 匹配符为 between的时候，表的路由函数 */ @Override public Collection&lt;String&gt; doBetweenSharding(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(availableTargetNames.size()); Range&lt;Integer&gt; range = (Range&lt;Integer&gt;) shardingValue.getValueRange(); for (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123; for (String each : availableTargetNames) &#123; if (each.endsWith(i % 2 + &quot;&quot;)) &#123; result.add(each); &#125; &#125; &#125; return result; &#125; &#125; #### 9、创建分表逻辑 9-1、User分表逻辑UserSingleKeyTableShardingAlgorithm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.algorithm; import java.util.Collection; import java.util.LinkedHashSet; import com.dangdang.ddframe.rdb.sharding.api.ShardingValue; import com.dangdang.ddframe.rdb.sharding.api.strategy.table.SingleKeyTableShardingAlgorithm; import com.google.common.collect.Range; /** * 因为t_student实际表在每个库中只有3个，所以 %3 * @author iuyazhuang * */ public class UserSingleKeyTableShardingAlgorithm implements SingleKeyTableShardingAlgorithm&lt;Integer&gt;&#123; /** * sql 中 = 操作时，table的映射 */ public String doEqualSharding(Collection&lt;String&gt; tableNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; for (String each : tableNames) &#123; if (each.endsWith((&quot;0&quot;.concat(String.valueOf(shardingValue.getValue() % 3))))) &#123; return each; &#125; &#125; throw new IllegalArgumentException(); &#125; /** * sql 中 in 操作时，table的映射 */ public Collection&lt;String&gt; doInSharding(Collection&lt;String&gt; tableNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(tableNames.size()); for (Integer value : shardingValue.getValues()) &#123; for (String tableName : tableNames) &#123; if (tableName.endsWith((&quot;0&quot;.concat(String.valueOf(value % 3))))) &#123; result.add(tableName); &#125; &#125; &#125; return result; &#125; /** * sql 中 between 操作时，table的映射 */ public Collection&lt;String&gt; doBetweenSharding(Collection&lt;String&gt; tableNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(tableNames.size()); Range&lt;Integer&gt; range = (Range&lt;Integer&gt;) shardingValue.getValueRange(); for (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123; for (String each : tableNames) &#123; if (each.endsWith((&quot;0&quot;.concat(String.valueOf(i % 3))))) &#123; result.add(each); &#125; &#125; &#125; return result; &#125; &#125; 9-2、创建Student分表逻辑StudentSingleKeyTableShardingAlgorithm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.algorithm; import java.util.Collection; import java.util.LinkedHashSet; import com.dangdang.ddframe.rdb.sharding.api.ShardingValue; import com.dangdang.ddframe.rdb.sharding.api.strategy.table.SingleKeyTableShardingAlgorithm; import com.google.common.collect.Range; /** * 因为t_student实际表在每个库中只有2个，所以 %2 * @author iuyazhuang * */ public class StudentSingleKeyTableShardingAlgorithm implements SingleKeyTableShardingAlgorithm&lt;Integer&gt;&#123; /** * sql 中 = 操作时，table的映射 */ public String doEqualSharding(Collection&lt;String&gt; tableNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; for (String each : tableNames) &#123; if (each.endsWith(&quot;0&quot;.concat(String.valueOf(shardingValue.getValue() % 2)))) &#123; return each; &#125; &#125; throw new IllegalArgumentException(); &#125; /** * sql 中 in 操作时，table的映射 */ public Collection&lt;String&gt; doInSharding(Collection&lt;String&gt; tableNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(tableNames.size()); for (Integer value : shardingValue.getValues()) &#123; for (String tableName : tableNames) &#123; if (tableName.endsWith(&quot;0&quot;.concat(String.valueOf(value % 2)))) &#123; result.add(tableName); &#125; &#125; &#125; return result; &#125; /** * sql 中 between 操作时，table的映射 */ public Collection&lt;String&gt; doBetweenSharding(Collection&lt;String&gt; tableNames, ShardingValue&lt;Integer&gt; shardingValue) &#123; Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(tableNames.size()); Range&lt;Integer&gt; range = (Range&lt;Integer&gt;) shardingValue.getValueRange(); for (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123; for (String each : tableNames) &#123; if (each.endsWith(&quot;0&quot;.concat(String.valueOf(i % 2)))) &#123; result.add(each); &#125; &#125; &#125; return result; &#125; &#125; #### 10、创建Mapper.xml 10-1、创建UserMapper.xml 12345678910111213141516171819202122232425262728293031&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; &lt;mapper namespace=&quot;com.lyz.sharding.mapper.UserMapper&quot; &gt; &lt;resultMap id=&quot;resultMap&quot; type=&quot;com.lyz.sharding.entity.User&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;/resultMap&gt; &lt;insert id=&quot;insert&quot;&gt; insert into t_user (user_id,name,age) values (#&#123;userId&#125;,#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;resultMap&quot;&gt; select &lt;include refid=&quot;columnsName&quot;/&gt; from t_user &lt;/select&gt; &lt;select id=&quot;findByUserIds&quot; resultMap=&quot;resultMap&quot;&gt; select &lt;include refid=&quot;columnsName&quot;/&gt; from t_user where user_id in ( &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/select&gt; &lt;sql id=&quot;columnsName&quot;&gt; id,user_id,name,age &lt;/sql&gt; &lt;/mapper&gt; 10-2、创建StudentMapper.xml 12345678910111213141516171819202122232425262728293031&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; &lt;mapper namespace=&quot;com.lyz.sharding.mapper.StudentMapper&quot; &gt; &lt;resultMap id=&quot;resultMap&quot; type=&quot;com.lyz.sharding.entity.Student&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;student_id&quot; property=&quot;studentId&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;/resultMap&gt; &lt;insert id=&quot;insert&quot;&gt; insert into t_student (student_id,name,age) values (#&#123;studentId&#125;,#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;resultMap&quot;&gt; select &lt;include refid=&quot;columnsName&quot;/&gt; from t_student &lt;/select&gt; &lt;select id=&quot;findByStudentIds&quot; resultMap=&quot;resultMap&quot;&gt; select &lt;include refid=&quot;columnsName&quot;/&gt; from t_student where student_id in ( &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/select&gt; &lt;sql id=&quot;columnsName&quot;&gt; id,student_id,name,age &lt;/sql&gt; &lt;/mapper&gt; #### 11、创建jdbc_dev.properties 1234567891011&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;jdbc_driver0 = com.mysql.jdbc.Driverjdbc_url0 = jdbc:mysql://localhost:3306/sharding_0?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=truejdbc_username0 = rootjdbc_password0 = rootjdbc_driver1 = com.mysql.jdbc.Driverjdbc_url1 = jdbc:mysql://localhost:3306/sharding_1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=truejdbc_username1 = rootjdbc_password1 = rootvalidationQuery=SELECT 1 #### 12、创建spring配置文件 12-1、spring-database.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mybatis-spring=&quot;http://mybatis.org/schema/mybatis-spring&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:config/resource/jdbc_dev.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean name=&quot;sharding_0&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url0&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username0&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password0&#125;&quot; /&gt; &lt;!-- &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc_driver0&#125;&quot; /&gt; --&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;0&quot; /&gt; &lt;!-- 连接池最大使用连接数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;0&quot; /&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;$&#123;validationQuery&#125;&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;25200000&quot; /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot; /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;1800&quot; /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;/bean&gt; &lt;bean name=&quot;sharding_1&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url1&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username1&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password1&#125;&quot; /&gt; &lt;!-- &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc_driver1&#125;&quot; /&gt; --&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;0&quot; /&gt; &lt;!-- 连接池最大使用连接数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;0&quot; /&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;$&#123;validationQuery&#125;&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;25200000&quot; /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot; /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;1800&quot; /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 12-2、spring-sharding.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mybatis-spring=&quot;http://mybatis.org/schema/mybatis-spring&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.lyz.sharding&quot; /&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.lyz.sharding.mapper&quot;/&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:config/mapper/*Mapper.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置好dataSourceRulue,即对数据源进行管理 --&gt; &lt;bean id=&quot;dataSourceRule&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.rule.DataSourceRule&quot;&gt; &lt;constructor-arg&gt; &lt;map&gt; &lt;entry key=&quot;sharding_0&quot; value-ref=&quot;sharding_0&quot;/&gt; &lt;entry key=&quot;sharding_1&quot; value-ref=&quot;sharding_1&quot;/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 对t_user表的配置，进行分库配置，逻辑表名为t_user，每个库有实际的三张表 --&gt; &lt;bean id=&quot;userTableRule&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.rule.TableRule&quot;&gt; &lt;constructor-arg value=&quot;t_user&quot; index=&quot;0&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;list&gt; &lt;value&gt;t_user_00&lt;/value&gt; &lt;value&gt;t_user_01&lt;/value&gt; &lt;value&gt;t_user_02&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;dataSourceRule&quot;/&gt; &lt;constructor-arg index=&quot;3&quot; ref=&quot;userDatabaseShardingStrategy&quot;/&gt; &lt;constructor-arg index=&quot;4&quot; ref=&quot;userTableShardingStrategy&quot;/&gt; &lt;/bean&gt; &lt;!-- t_user分库策略 --&gt; &lt;bean id=&quot;userDatabaseShardingStrategy&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.strategy.database.DatabaseShardingStrategy&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;user_id&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;bean class=&quot;com.lyz.sharding.algorithm.UserSingleKeyDatabaseShardingAlgorithm&quot; /&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- t_user 分表策略 --&gt; &lt;bean id=&quot;userTableShardingStrategy&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.strategy.table.TableShardingStrategy&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;user_id&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;bean class=&quot;com.lyz.sharding.algorithm.UserSingleKeyTableShardingAlgorithm&quot; /&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 对t_student表的配置，进行分库配置，逻辑表名为t_student，每个库有实际的三张表 --&gt; &lt;bean id=&quot;studentTableRule&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.rule.TableRule&quot;&gt; &lt;constructor-arg value=&quot;t_student&quot; index=&quot;0&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;list&gt; &lt;value&gt;t_student_00&lt;/value&gt; &lt;value&gt;t_student_01&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;dataSourceRule&quot;/&gt; &lt;constructor-arg index=&quot;3&quot; ref=&quot;studentDatabaseShardingStrategy&quot;/&gt; &lt;constructor-arg index=&quot;4&quot; ref=&quot;studentTableShardingStrategy&quot;/&gt; &lt;/bean&gt; &lt;!-- t_student分库策略 --&gt; &lt;bean id=&quot;studentDatabaseShardingStrategy&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.strategy.database.DatabaseShardingStrategy&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;student_id&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;bean class=&quot;com.lyz.sharding.algorithm.StudentSingleKeyDatabaseShardingAlgorithm&quot; /&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- t_student 分表策略 --&gt; &lt;bean id=&quot;studentTableShardingStrategy&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.strategy.table.TableShardingStrategy&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;student_id&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;bean class=&quot;com.lyz.sharding.algorithm.StudentSingleKeyTableShardingAlgorithm&quot; /&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 构成分库分表的规则 传入数据源集合和每个表的分库分表的具体规则 --&gt; &lt;bean id=&quot;shardingRule&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.rule.ShardingRule&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;dataSourceRule&quot;/&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;userTableRule&quot;/&gt; &lt;ref bean=&quot;studentTableRule&quot;/&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 对datasource进行封装 --&gt; &lt;bean id=&quot;shardingDataSource&quot; class=&quot;com.dangdang.ddframe.rdb.sharding.api.ShardingDataSource&quot;&gt; &lt;constructor-arg ref=&quot;shardingRule&quot;/&gt; &lt;/bean&gt; &lt;!-- 事务 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot; /&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; &lt;/beans&gt; #### 13、创建log4j.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE log4j:configuration PUBLIC &quot;-//APACHE//DTD LOG4J 1.2//EN&quot; &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;!-- [控制台STDOUT] --&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;encoding&quot; value=&quot;GBK&quot; /&gt; &lt;param name=&quot;target&quot; value=&quot;System.out&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %c&#123;2&#125; - %m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- [公共Appender] --&gt; &lt;appender name=&quot;DEFAULT-APPENDER&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt; &lt;param name=&quot;File&quot; value=&quot;logs/common-default.log&quot; /&gt; &lt;param name=&quot;Append&quot; value=&quot;true&quot; /&gt; &lt;param name=&quot;encoding&quot; value=&quot;GBK&quot; /&gt; &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;.&apos;yyyy-MM-dd&apos;.log&apos;&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p %c&#123;2&#125; - %m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- [错误日志APPENDER] --&gt; &lt;appender name=&quot;ERROR-APPENDER&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt; &lt;param name=&quot;File&quot; value=&quot;logs/common-error.log&quot; /&gt; &lt;param name=&quot;Append&quot; value=&quot;true&quot; /&gt; &lt;param name=&quot;encoding&quot; value=&quot;GBK&quot; /&gt; &lt;param name=&quot;threshold&quot; value=&quot;error&quot; /&gt; &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;.&apos;yyyy-MM-dd&apos;.log&apos;&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p %c&#123;2&#125; - %m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- [组件日志APPENDER] --&gt; &lt;appender name=&quot;COMPONENT-APPENDER&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt; &lt;param name=&quot;File&quot; value=&quot;logs/logistics-component.log&quot; /&gt; &lt;param name=&quot;Append&quot; value=&quot;true&quot; /&gt; &lt;param name=&quot;encoding&quot; value=&quot;GBK&quot; /&gt; &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;.&apos;yyyy-MM-dd&apos;.log&apos;&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p %c&#123;2&#125; - %m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- [组件日志] --&gt; &lt;logger name=&quot;LOGISTICS-COMPONENT&quot;&gt; &lt;level value=&quot;$&#123;loggingLevel&#125;&quot; /&gt; &lt;appender-ref ref=&quot;COMPONENT-APPENDER&quot; /&gt; &lt;appender-ref ref=&quot;ERROR-APPENDER&quot; /&gt; &lt;/logger&gt; &lt;!-- Root Logger --&gt; &lt;root&gt; &lt;level value=&quot;$&#123;rootLevel&#125;&quot;&gt;&lt;/level&gt; &lt;appender-ref ref=&quot;DEFAULT-APPENDER&quot; /&gt; &lt;appender-ref ref=&quot;ERROR-APPENDER&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;COMPONENT-APPENDER&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; #### 14、创建测试类ShardingJdbcMybatisTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;package com.lyz.sharding.test; import java.util.Arrays;import java.util.List;import javax.annotation.Resource;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.lyz.sharding.entity.Student;import com.lyz.sharding.entity.User;import com.lyz.sharding.service.StudentService;import com.lyz.sharding.service.UserService;/** * 测试分库分表规则 * @author liuyazhuang * */@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = &#123; &quot;classpath*:config/spring/spring-database.xml&quot;, &quot;classpath*:config/spring/spring-sharding.xml&quot; &#125;) public class ShardingJdbcMybatisTest &#123; @Resource public UserService userService; @Resource public StudentService studentService; @Test public void testUserInsert() &#123; User u = new User(); u.setUserId(11); u.setAge(25); u.setName(&quot;github&quot;); Assert.assertEquals(userService.insert(u), true); &#125; @Test public void testStudentInsert() &#123; Student student = new Student(); student.setStudentId(21); student.setAge(21); student.setName(&quot;hehe&quot;); Assert.assertEquals(studentService.insert(student), true); &#125; @Test public void testFindAll()&#123; List&lt;User&gt; users = userService.findAll(); if(null != users &amp;&amp; !users.isEmpty())&#123; for(User u :users)&#123; System.out.println(u); &#125; &#125; &#125; @Test public void testSQLIN()&#123; List&lt;User&gt; users = userService.findByUserIds(Arrays.asList(1)); if(null != users &amp;&amp; !users.isEmpty())&#123; for(User u :users)&#123; System.out.println(u); &#125; &#125; &#125; @Test public void testTransactionTestSucess()&#123; userService.transactionTestSucess(); &#125; @Test(expected = IllegalAccessException.class) public void testTransactionTestFailure() throws IllegalAccessException&#123; userService.transactionTestFailure(); &#125; &#125; ### 三、测试 我们进行ShardingJdbcMybatisTest类，查看数据表数据，即可看到我们的程序利用sharding-jdbc实现了分库分表操作。 ### 四、温馨提示 大家可以到链接http://download.csdn.net/download/l1028386804/10258290下载完整的sharding-jdbc分库分表实例源代码]]></content>
      <tags>
        <tag>Sharding-JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在springboot项目中使用mybatis 集成 Sharding-JDBC]]></title>
    <url>%2Fpost%2Fb3286b72.html</url>
    <content type="text"><![CDATA[前段时间写了篇如何使用Sharding-JDBC进行分库分表的例子，相信能够感受到Sharding-JDBC的强大了，而且使用配置都非常干净。官方支持的功能还包括读写分离、分布式主键、强制路由等。这里再介绍下如何在分库分表的基础上集成读写分离的功能。 读写分离的概念 就是为了缓解数据库压力，将写入和读取操作分离为不同数据源，写库称为主库，读库称为从库，一主库可配置多从库。 设置主从库后，第一个问题是如何进行主从的同步。官方不支持主从的同步，也不支持因为主从同步延迟导致的数据不一致问题。工程实践上进行主从同步有很多做法，一种常用的做法是每天定时同步或者实时同步。这个话题太大，暂不展开。 读写分离快速入门读写可以单独使用，也可以配合分库分表进行使用，由于上个分库分表的例子是基于1.5.4.1版本进行说明的，这里为了紧跟官方的步伐，升级Sharding-JDBC到最新的2.0.0.M2 项目结构如下： pom依赖 org.springframework.boot spring-boot-starter-web &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Sharding-JDBC核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.shardingjdbc&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Sharding-JDBC Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;io.shardingjdbc&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/code&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 ### 主从数据库配置在配置前，我们希望分库分表规则和之前保持一致：&gt; 基于`t_user`表，根据`city_id`进行分库，如果`city_id mod 2`为奇数则落在`ds_master_1`库，偶数则落在`ds_master_0`库；根据`user_id`进行分表，如果`user_id mod 2`为奇数则落在`t_user_1`表，偶数则落在`t_user_0`表读写分离规则：&gt; 读都落在从库，写落在主库因为使用`Sharding-JDBC Spring Boot Starter`，所以只需要在properties配置文件配置主从库的数据源即可： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt; spring.application.name=spring-boot-mybatis-sharding-jdbc-masterslave server.context-path=/springboot mybatis.config-location=classpath:mybatis-config.xml # 所有主从库 sharding.jdbc.datasource.names=ds_master_0,ds_master_1,ds_master_0_slave_0,ds_master_0_slave_1,ds_master_1_slave_0,ds_master_1_slave_1 # ds_master_0 sharding.jdbc.datasource.ds_master_0.type=com.alibaba.druid.pool.DruidDataSource sharding.jdbc.datasource.ds_master_0.driverClassName=com.mysql.jdbc.Driver sharding.jdbc.datasource.ds_master_0.url=jdbc:mysql:&lt;span class=&quot;hljs-comment&quot;&gt;//127.0.0.1:3306/ds_master_0?useSSL=false sharding.jdbc.datasource.ds_master_0.username=travis sharding.jdbc.datasource.ds_master_0.password= # slave &lt;span class=&quot;hljs-keyword&quot;&gt;for ds_master_0 sharding.jdbc.datasource.ds_master_0_slave_0.type=com.alibaba.druid.pool.DruidDataSource sharding.jdbc.datasource.ds_master_0_slave_0.driverClassName=com.mysql.jdbc.Driver sharding.jdbc.datasource.ds_master_0_slave_0.url=jdbc:mysql:&lt;span class=&quot;hljs-comment&quot;&gt;//127.0.0.1:3306/ds_master_0_slave_0?useSSL=false sharding.jdbc.datasource.ds_master_0_slave_0.username=travis sharding.jdbc.datasource.ds_master_0_slave_0.password= sharding.jdbc.datasource.ds_master_0_slave_1.type=com.alibaba.druid.pool.DruidDataSource sharding.jdbc.datasource.ds_master_0_slave_1.driverClassName=com.mysql.jdbc.Driver sharding.jdbc.datasource.ds_master_0_slave_1.url=jdbc:mysql:&lt;span class=&quot;hljs-comment&quot;&gt;//127.0.0.1:3306/ds_master_0_slave_1?useSSL=false sharding.jdbc.datasource.ds_master_0_slave_1.username=travis sharding.jdbc.datasource.ds_master_0_slave_1.password= # ds_master_1 sharding.jdbc.datasource.ds_master_1.type=com.alibaba.druid.pool.DruidDataSource sharding.jdbc.datasource.ds_master_1.driverClassName=com.mysql.jdbc.Driver sharding.jdbc.datasource.ds_master_1.url=jdbc:mysql:&lt;span class=&quot;hljs-comment&quot;&gt;//127.0.0.1:3306/ds_master_1?useSSL=false sharding.jdbc.datasource.ds_master_1.username=travis sharding.jdbc.datasource.ds_master_1.password= # slave &lt;span class=&quot;hljs-keyword&quot;&gt;for ds_master_1 sharding.jdbc.datasource.ds_master_1_slave_0.type=com.alibaba.druid.pool.DruidDataSource sharding.jdbc.datasource.ds_master_1_slave_0.driverClassName=com.mysql.jdbc.Driver sharding.jdbc.datasource.ds_master_1_slave_0.url=jdbc:mysql:&lt;span class=&quot;hljs-comment&quot;&gt;//127.0.0.1:3306/ds_master_1_slave_0?useSSL=false sharding.jdbc.datasource.ds_master_1_slave_0.username=travis sharding.jdbc.datasource.ds_master_1_slave_0.password= sharding.jdbc.datasource.ds_master_1_slave_1.type=com.alibaba.druid.pool.DruidDataSource sharding.jdbc.datasource.ds_master_1_slave_1.driverClassName=com.mysql.jdbc.Driver sharding.jdbc.datasource.ds_master_1_slave_1.url=jdbc:mysql:&lt;span class=&quot;hljs-comment&quot;&gt;//127.0.0.1:3306/ds_master_1_slave_1?useSSL=false sharding.jdbc.datasource.ds_master_1_slave_1.username=travis sharding.jdbc.datasource.ds_master_1_slave_1.password= # 分库规则 sharding.jdbc.config.sharding.&lt;span class=&quot;hljs-keyword&quot;&gt;default-database-strategy.inline.sharding-column=city_id sharding.jdbc.config.sharding.&lt;span class=&quot;hljs-keyword&quot;&gt;default-database-strategy.inline.algorithm-expression=ds_$&#123;city_id % &lt;span class=&quot;hljs-number&quot;&gt;2&#125; # 分表规则 sharding.jdbc.config.sharding.tables.t_user.actualDataNodes=ds_$&#123;&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;span class=&quot;hljs-number&quot;&gt;.1&#125;.t_user_$&#123;&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;span class=&quot;hljs-number&quot;&gt;.1&#125; sharding.jdbc.config.sharding.tables.t_user.tableStrategy.inline.shardingColumn=user_id sharding.jdbc.config.sharding.tables.t_user.tableStrategy.inline.algorithmExpression=t_user_$&#123;user_id % &lt;span class=&quot;hljs-number&quot;&gt;2&#125; # 使用user_id作为分布式主键 sharding.jdbc.config.sharding.tables.t_user.keyGeneratorColumnName=user_id # 逻辑主从库名和实际主从库映射关系 sharding.jdbc.config.sharding.master-slave-rules.ds_0.masterDataSourceName=ds_master_0 sharding.jdbc.config.sharding.master-slave-rules.ds_0.slaveDataSourceNames=ds_master_0_slave_0, ds_master_0_slave_1 sharding.jdbc.config.sharding.master-slave-rules.ds_1.masterDataSourceName=ds_master_1 sharding.jdbc.config.sharding.master-slave-rules.ds_1.slaveDataSourceNames=ds_master_1_slave_0, ds_master_1_slave_1 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ### Test 测试代码如下： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt; &lt;span class=&quot;hljs-annotation&quot;&gt;@RunWith(SpringRunner.class) &lt;span class=&quot;hljs-annotation&quot;&gt;@SpringBootTest &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;UserMapperTest { &lt;span class=&quot;hljs-javadoc&quot;&gt;/** Logger */ &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static Logger log = LoggerFactory.getLogger(UserMapperTest.class); &lt;span class=&quot;hljs-annotation&quot;&gt;@Resource &lt;span class=&quot;hljs-keyword&quot;&gt;private UserMapper userMapper; &lt;span class=&quot;hljs-annotation&quot;&gt;@Before &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setup() &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception { create(); clear(); } &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;create() &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException { userMapper.createIfNotExistsTable(); } &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;clear() { userMapper.truncateTable(); } &lt;span class=&quot;hljs-annotation&quot;&gt;@Test &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;insert() &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception { UserEntity user = &lt;span class=&quot;hljs-keyword&quot;&gt;new UserEntity(); user.setCityId(&lt;span class=&quot;hljs-number&quot;&gt;1); user.setUserName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;insertTest&quot;); user.setAge(&lt;span class=&quot;hljs-number&quot;&gt;10); user.setBirth(&lt;span class=&quot;hljs-keyword&quot;&gt;new Date()); assertTrue(userMapper.insert(user) &gt; &lt;span class=&quot;hljs-number&quot;&gt;0); Long userId = user.getUserId(); log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Generated Key--userId:&quot; + userId); userMapper.delete(userId); } &lt;span class=&quot;hljs-annotation&quot;&gt;@Test &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;find() &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception { UserEntity userEntity = userMapper.find(&lt;span class=&quot;hljs-number&quot;&gt;138734796783222784L); log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;user:{}&quot;, userEntity); } } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;1234567891011先运行`insert`方法，插入一条数据后，获取插入的`user_id`为`138734796783222784L`（每次运行会不一样）,由于`city_id=1`，读写分离约定，会落在主库，又根据分库规则会落在`ds_master_1`，再根据分表规则，会落在`t_user_0`![结果](http://7xkjk9.com1.z0.glb.clouddn.com/test.png)再运行`find`方法，指定userId，你会发现查出来是空的，这是因为Sharding-JDBC不支持主从同步以及主从同步延迟造成的数据不一致。这里我们显然术语第一种，因为根本就没有进行主从同步，那么从从库读取肯定是空的。我们可以反向推理下，假如开启了主从同步，现在数据落在主库`ds_master_1`，这个主库有两个从库：`ds_master_1_slave_0`和`ds_master_1_slave_1`，所以我们可以往这两个主库的`t_user_0`表插入刚才的数据，语句如下： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;INSERT INTO t_user_0(user_id,city_id,user_name,age,birth) values(&lt;span class=&quot;hljs-number&quot;&gt;138734796783222784,&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-string&quot;&gt;&apos;insertTest&apos;,&lt;span class=&quot;hljs-number&quot;&gt;10,&lt;span class=&quot;hljs-string&quot;&gt;&apos;2017-11-18 00:00:00&apos;); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 先往ds_master_1_slave_0的t_user_0表插入该条数据，可以理解为主库同步到从库的数据。重新运行find方法，发现返回的数据和主库的一致，表明Sharding-JDBC从ds_master_1的从库ds_master_1_slave_0的t_user_0表查到了数据。 再删掉ds_master_1_slave_0的t_user_0表的数据，往ds_master_1_slave_1的t_user_0表插入刚才那条数据，重新运行发现返回的结果为空，表明从ds_master_1的从库ds_master_1_slave_1的t_user_0表没有查到数据。 最后往ds_master_1_slave_0的t_user_0表重新插入刚才的数据，再运行发现又返回了数据。 基于以上现象，可以推论选择从库查询的时候经过了某种算法得到访问的从库，然后在从库根据分表规则查询数据。 ## 读写分离实现 这里包括几个问题： 1. 读写分离的查询流程？ 2. 如何做结果归并？ 3. 如何路由到某个从库进行查询？ 4. 可以强制路由主库进行读操作吗？ ### 读写分离的流程 1. 获取主从库配置规则，数据源封装成`MasterSlaveDataSource` 2. 根据路由计算，得到PreparedStatementUnit单元列表，合并每个PreparedStatementUnit的执行结果返回 3. 执行每个PrepareStatementUnit的时候需要获取连接，这里根据轮询负载均衡算法`RoundRobinMasterSlaveLoadBalanceAlgorithm`得到从库数据源，拿到连接后就开始执行具体的SQL查询了，这里通过`PreparedStatementExecutor.execute()`得到执行结果 4. 结果归并后返回 MasterSlaveDataSource: &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MasterSlaveDataSource &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;AbstractDataSourceAdapter { &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final ThreadLocal&lt;Boolean&gt; DML_FLAG = &lt;span class=&quot;hljs-keyword&quot;&gt;new ThreadLocal&lt;Boolean&gt;() { &lt;span class=&quot;hljs-annotation&quot;&gt;@Override &lt;span class=&quot;hljs-keyword&quot;&gt;protected Boolean &lt;span class=&quot;hljs-title&quot;&gt;initialValue() { &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;false; } }; &lt;span class=&quot;hljs-comment&quot;&gt;// 主从配置关系 &lt;span class=&quot;hljs-keyword&quot;&gt;private MasterSlaveRule masterSlaveRule; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;MasterSlaveDataSource(&lt;span class=&quot;hljs-keyword&quot;&gt;final MasterSlaveRule masterSlaveRule) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException { &lt;span class=&quot;hljs-keyword&quot;&gt;super(getAllDataSources(masterSlaveRule.getMasterDataSource(), masterSlaveRule.getSlaveDataSourceMap().values())); &lt;span class=&quot;hljs-keyword&quot;&gt;this.masterSlaveRule = masterSlaveRule; } &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static Collection&lt;DataSource&gt; &lt;span class=&quot;hljs-title&quot;&gt;getAllDataSources(&lt;span class=&quot;hljs-keyword&quot;&gt;final DataSource masterDataSource, &lt;span class=&quot;hljs-keyword&quot;&gt;final Collection&lt;DataSource&gt; slaveDataSources) { Collection&lt;DataSource&gt; result = &lt;span class=&quot;hljs-keyword&quot;&gt;new LinkedList&lt;&gt;(slaveDataSources); result.add(masterDataSource); &lt;span class=&quot;hljs-keyword&quot;&gt;return result; } ...省略部分代码 &lt;span class=&quot;hljs-comment&quot;&gt;// 获取数据源 &lt;span class=&quot;hljs-keyword&quot;&gt;public NamedDataSource &lt;span class=&quot;hljs-title&quot;&gt;getDataSource(&lt;span class=&quot;hljs-keyword&quot;&gt;final SQLType sqlType) { &lt;span class=&quot;hljs-comment&quot;&gt;// 强制路由到主库查询 &lt;span class=&quot;hljs-keyword&quot;&gt;if (isMasterRoute(sqlType)) { DML_FLAG.set(&lt;span class=&quot;hljs-keyword&quot;&gt;true); &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;new NamedDataSource(masterSlaveRule.getMasterDataSourceName(), masterSlaveRule.getMasterDataSource()); } &lt;span class=&quot;hljs-comment&quot;&gt;// 获取选中的从库数据源 String selectedSourceName = masterSlaveRule.getStrategy().getDataSource(masterSlaveRule.getName(), masterSlaveRule.getMasterDataSourceName(), &lt;span class=&quot;hljs-keyword&quot;&gt;new ArrayList&lt;&gt;(masterSlaveRule.getSlaveDataSourceMap().keySet())); DataSource selectedSource = selectedSourceName.equals(masterSlaveRule.getMasterDataSourceName()) ? masterSlaveRule.getMasterDataSource() : masterSlaveRule.getSlaveDataSourceMap().get(selectedSourceName); Preconditions.checkNotNull(selectedSource, &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;); &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;new NamedDataSource(selectedSourceName, selectedSource); } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819MasterSlaveRule： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MasterSlaveRule &#123; &lt;span class=&quot;hljs-comment&quot;&gt;// 名称（这里是ds_0和ds_1） &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final String name; &lt;span class=&quot;hljs-comment&quot;&gt;// 主库数据源名称（这里是ds_master_0和ds_master_1） &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final String masterDataSourceName; &lt;span class=&quot;hljs-comment&quot;&gt;// 主库数据源 &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final DataSource masterDataSource; &lt;span class=&quot;hljs-comment&quot;&gt;// 所属从库列表，key为从库数据源名称，value是真实的数据源 &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final Map&lt;String, DataSource&gt; slaveDataSourceMap; &lt;span class=&quot;hljs-comment&quot;&gt;// 主从库负载均衡算法 &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final MasterSlaveLoadBalanceAlgorithm strategy; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; RoundRobinMasterSlaveLoadBalanceAlgorithm: &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 轮询负载均衡策略，按照每个从节点访问次数均衡 &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;RoundRobinMasterSlaveLoadBalanceAlgorithm &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;MasterSlaveLoadBalanceAlgorithm { &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final ConcurrentHashMap&lt;String, AtomicInteger&gt; COUNT_MAP = &lt;span class=&quot;hljs-keyword&quot;&gt;new ConcurrentHashMap&lt;&gt;(); &lt;span class=&quot;hljs-annotation&quot;&gt;@Override &lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getDataSource(&lt;span class=&quot;hljs-keyword&quot;&gt;final String name, &lt;span class=&quot;hljs-keyword&quot;&gt;final String masterDataSourceName, &lt;span class=&quot;hljs-keyword&quot;&gt;final List&lt;String&gt; slaveDataSourceNames) { AtomicInteger count = COUNT_MAP.containsKey(name) ? COUNT_MAP.get(name) : &lt;span class=&quot;hljs-keyword&quot;&gt;new AtomicInteger(&lt;span class=&quot;hljs-number&quot;&gt;0); COUNT_MAP.putIfAbsent(name, count); count.compareAndSet(slaveDataSourceNames.size(), &lt;span class=&quot;hljs-number&quot;&gt;0); &lt;span class=&quot;hljs-keyword&quot;&gt;return slaveDataSourceNames.get(count.getAndIncrement() % slaveDataSourceNames.size()); } } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;``` DefaultResultSetHandler: &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt; &lt;span class=&quot;hljs-annotation&quot;&gt;@Override &lt;span class=&quot;hljs-keyword&quot;&gt;public List&lt;Object&gt; &lt;span class=&quot;hljs-title&quot;&gt;handleResultSets(Statement stmt) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException { ErrorContext.instance().activity(&lt;span class=&quot;hljs-string&quot;&gt;&quot;handling results&quot;).object(mappedStatement.getId()); &lt;span class=&quot;hljs-comment&quot;&gt;// 返回的结果集 &lt;span class=&quot;hljs-keyword&quot;&gt;final List&lt;Object&gt; multipleResults = &lt;span class=&quot;hljs-keyword&quot;&gt;new ArrayList&lt;Object&gt;(); &lt;span class=&quot;hljs-keyword&quot;&gt;int resultSetCount = &lt;span class=&quot;hljs-number&quot;&gt;0; ResultSetWrapper rsw = getFirstResultSet(stmt); List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps(); &lt;span class=&quot;hljs-keyword&quot;&gt;int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); &lt;span class=&quot;hljs-keyword&quot;&gt;while (rsw != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;&amp; resultMapCount &gt; resultSetCount) { ResultMap resultMap = resultMaps.get(resultSetCount); &lt;span class=&quot;hljs-comment&quot;&gt;// 将ResultSetWrapper的结果集添加到multipleResults中 handleResultSet(rsw, resultMap, multipleResults, &lt;span class=&quot;hljs-keyword&quot;&gt;null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } String[] resultSets = mappedStatement.getResultSets(); &lt;span class=&quot;hljs-keyword&quot;&gt;if (resultSets != &lt;span class=&quot;hljs-keyword&quot;&gt;null) { &lt;span class=&quot;hljs-keyword&quot;&gt;while (rsw != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;&amp; resultSetCount &lt; resultSets.length) { ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); &lt;span class=&quot;hljs-keyword&quot;&gt;if (parentMapping != &lt;span class=&quot;hljs-keyword&quot;&gt;null) { String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, &lt;span class=&quot;hljs-keyword&quot;&gt;null, parentMapping); } rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } } &lt;span class=&quot;hljs-keyword&quot;&gt;return collapseSingleResultList(multipleResults); } &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) &lt;span class=&quot;hljs-keyword&quot;&gt;throws SQLException { &lt;span class=&quot;hljs-keyword&quot;&gt;try { &lt;span class=&quot;hljs-keyword&quot;&gt;if (parentMapping != &lt;span class=&quot;hljs-keyword&quot;&gt;null) { handleRowValues(rsw, resultMap, &lt;span class=&quot;hljs-keyword&quot;&gt;null, RowBounds.DEFAULT, parentMapping); } &lt;span class=&quot;hljs-keyword&quot;&gt;else { &lt;span class=&quot;hljs-keyword&quot;&gt;if (resultHandler == &lt;span class=&quot;hljs-keyword&quot;&gt;null) { DefaultResultHandler defaultResultHandler = &lt;span class=&quot;hljs-keyword&quot;&gt;new DefaultResultHandler(objectFactory); &lt;span class=&quot;hljs-comment&quot;&gt;// 按照resultMap解析到defaultResultHandler中 handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, &lt;span class=&quot;hljs-keyword&quot;&gt;null); &lt;span class=&quot;hljs-comment&quot;&gt;// 最后的结果就是这里加进去的 multipleResults.add(defaultResultHandler.getResultList()); } &lt;span class=&quot;hljs-keyword&quot;&gt;else { handleRowValues(rsw, resultMap, resultHandler, rowBounds, &lt;span class=&quot;hljs-keyword&quot;&gt;null); } } } &lt;span class=&quot;hljs-keyword&quot;&gt;finally { &lt;span class=&quot;hljs-comment&quot;&gt;// issue #228 (close resultsets) closeResultSet(rsw.getResultSet()); } }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;```&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;]]></content>
      <tags>
        <tag>spring boot</tag>
        <tag>Sharding-JDBC</tag>
        <tag>mytatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈分布式数据库]]></title>
    <url>%2Fpost%2Fc096a551.html</url>
    <content type="text"><![CDATA[文章集中整理总结mysql分库分表开源产品，分布式数据库的设计，以及实际应用案例等相关内容，部分附上本文作者实际应用过程中的理解。 本文感谢sjdbc，mycat，姜承尧，林涛等文章提供的精彩介绍。 1、先抛出两个问题问题一、当mysql单表数据量爆炸时，你怎么办？问题二、当你的数据库无法承受高强度io时你怎么办？ 2、 基本概念2.1 谈数据库分片需要首先确定以下概念​ 1) 单库,就是一个库 ​ 2) 分片(sharding)，分片解决扩展性问题，属于水平拆分，引入分片，就引入了数据路由和分区键的概念。分表解决的是数据量过大的问题，分库解决的是数据库性能瓶颈的问题。 ​ 3) 分组(group)，分组解决可用性问题，分组通常通过主从复制(replication)的方式实现。(各种可用级别方案单独介绍) ​ 4) 互联网公司数据库实际软件架构是(大数据量下)：又分片，又分组（如下图） 3、 分片3.1 水平拆分，垂直拆分都是什么？ 分区表？1)若不走分区键很容易出现全表锁，并发上来后简直是灾难。2)自己分库分表，自己掌控业务场景、访问模式，可控。mysql分区表官方介绍是针对myisam做的优化，你知道他怎么玩的？分半天还是一个ibdata是不是很尴尬 3.2 为什么分表?​ 关系型数据库在大于一定数据量的情况下检索性能会急剧下降。在面对互联网海量数据情况时，所有数据都存于一张表，显然会轻易超过数据库表可承受的数据量阀值。这个单表可承受的数据量阀值，需根据数据库和并发量的差异，通过实际测试获得。 水平拆分如果能预估规模，越早做成本越低。 2.3 为什么分库?​ 单纯的分表虽然可以解决数据量过大导致检索变慢的问题，但无法解决过多并发请求访问同一个库，导致数据库响应变慢的问题。所以通常水平拆分都至少要采用分库的方式，用于一并解决大数据量和高并发的问题。这也是部分开源的分片数据库中间件只支持分库的原因。 3.4 分布式事务？​ 但分表也有不可替代的适用场景。最常见的分表需求是事务问题。同在一个库则不需考虑分布式事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。目前强一致性的分布式事务由于性能问题，导致使用起来并不一定比不分库分表快。目前采用最终一致性的柔性事务居多。分表的另一个存在的理由是，过多的数据库实例不利于运维管理。 mysql本身？消息补偿？2PC? 3.5 小结​ 综上所述，最佳实践是合理地配合使用分库+分表。 3.6 如何自己实现分库分表？​ 1) dao层，首先通过分区键算出库名表名(如shardKey%shardNum 算出来表index如y，然后y/(shardNum/sourceNum)=x,y是表下标，x是库下标)。​ 2) 把source从spring容器中拿出来，把表名当参数传进去，拼成分片后的sql。​ 3) 思路大概是(select … from order where … -&gt; 先拿到db_x的source 然后 select … from order_y where …) 你想这么干？你已经成功了。当然淘宝和当当的架构师也是这么干的。 3.7 SO，不需要我们亲自动手，其实你需要做的只是按照实际需求挑选而已。 3.8 重点介绍两个产品，先不说具体配置，只说思想​ 1) sharding-jdbc（所处位置，通用数据访问层，部署在客户端的jar包，用于将用户的SQL路由到指定的数据库中） 盗一波图 ​ 2) jproxy jproxy是什么？ ​ jproxy提供MariaDB, MySQL等数据库的统一接入访问，拥有流量过载保护，数据自动拆分，可配置路由规则，数据无缝迁移等功能。​ 应用场景：数据需要分库分表，自动扩容的应用。 为什么分片都是2的n次方？a % (2^n) 等价于 a &amp; (2^n - 1) 其中一个原因就是位运算 扩容？ 虚拟桶。 极限就是一片一库。 演变过程 cobar-&gt;mycat-&gt;jproxy mycat是什么? ​ 简单的说，就是：一个彻底开源的，面向企业应用开发的“大数据库集群”。支持事务、ACID、可以替代Mysql的加强版数据库，一个的数据库中间件产品。 其优势具有：1) 基于阿里开源的Cobar产品而研发，Cobar的稳定性、可靠性、优秀的架构和性能2) 拥有众多成熟的使用案例3) 强大的团队(其参与者都是5年以上资深软件工程师、架构师、DBA等)4) 开源，创新，持续更新 盗一波图 4、 分组4.1 为什么分组？​ 分组解决可用性问题 mysql的ha 网洛上的都是vip漂移实现的 盗一波图 方案一：MYSQL主从复制（单活） 方案二：双主（单活），failover比单主简单 方案三：双主配SAN存储（单活） 方案四：DRBD 双主配DRBD （单活） 方案五：NDB CLUSTER 共享存储? 不需要复制了 更高的一致性 真正的高并发场景，什么架构都抗不住，老老实实用缓存。 需要大量读的场景尽量做到最终一致性。 4.2 同步，异步，半同步1) 异步复制 (mysql默认) Master将事件写入binlog，但并不知道Slave是否或何时已经接收且已处理。当Slave准备好才会向Master请求binlog。缺点：不能保证一些事件都能够被所有的Slave所接收。 2) 同步复制 Master提交事务，直到事务在所有的Slave都已提交，此时才会返回客户端，事务执行完毕。缺点：完成一个事务可能会有很大的延迟。 3) 半同步复制 半同步复制工作的机制处于同步和异步之间，Master的事务提交阻塞，只要一个Slave已收到该事务的事件且已记录。它不会等待所有的Slave都告知已收到，且它只是接收，并不用等其完全执行且提交。 半同步复制的步骤：i.当Slave主机连接到Master时，能够查看其是否处于半同步复制的机制。 ii.当Master上开启半同步复制的功能时，至少应该有一个Slave开启其功能。此时，一个线程在Master上提交事务将受到阻塞，直到得知一个已开启半同步复制功能的Slave已收到此事务的所有事件，或等待超时。 iii.当一个事务的事件都已写入其relay-log中且已刷新到磁盘上，Slave才会告知已收到。 iv.如果等待超时，也就是Master没被告知已收到，此时Master会自动转换为异步复制的机制。当至少一个半同步的Slave赶上了，Master与其Slave自动转换为半同步复制的机制。 v.半同步复制的功能要在Master，Slave都开启，半同步复制才会起作用；否则，只开启一边，它依然为异步复制。 4.3 ha方案4.3.1 MHA4.3.2 MMM 5、 应用案例5.1 记录一次mongo迁移mysql的过程(分库分表使用jproxy)mongo怎么了？跟分片无关的部分简单说。​ mongo很好，只是业界并没有成熟的MongoDB运维经验，jd too。像高并发的系统 订单和库存 商品 还是拿nosql把，高并发的写,也不会打挂他,比如hbase，顶多GC频繁点，但是也是可用的。一致性完全可以CAS搞定，而不是mysql的排他锁。 迁移数据库的一个方案1) 中心化(统一入口)2) 双写(先同步写mysql如果发生异常改异步，尽量避免服务不可用)3) 倒库(jproxy支持通过游标形式全量遍历库-逐个表操作，可以利用其异步同步数据)4) 数据校验5) 切库提供服务 去mongo+优化方案(此处引入了分片的概念) 压测与性能 去mongo任务线类型任务备注影线系统风险design海关迁移方案设计评审……无design分库分表技术选型jproxy…无apply申请迁移相关应用(辅助系统)跑批任务…无apply申请mysql集群dbs系统…无apply申请jproxy集群直接找接口人…无apply申请es集群esm杰斯…无codingtrace表服务中心化soacenter高coding涉及trace业务逻辑梳理，全部切换中心接口接口完全适配platform低verify回归测试，并线上走单验证一段时间先预发后正式…高coding实现mysql版本共2个表sql映射文件基于自主研发的generatorcenter低verifymysql版本sql映射文件单元测试基于自主研发的generatorcenter低codingtrace表实现基于jproxy的分库分表128个库(主) 1主3从center中codinges分别按照商家id分片，保税区id分片，异步写，读开放jsf2套集群4套索引es中coding中心接口加入代理层，可利用开关切换读mongo/mysql/es…center高coding异步补偿mongo,mysql,es功能开发基于jmqplatform中coding代理层实现mongo和mysql版本互为主被双写(mongo主)，异步写es双11后mysql主center高verify线上开双写(包括es)两套es集群…中coding倒库功能开发，数据校验功能开发reactorconfig高verify倒库，并进行数据校验校验规则(特殊字段不校验)…高verify对中心接口进行压测线上，压测环境隔离(jsf别名)…高coding优化配置(mysql调整最大连接数,es使用filterCache)……高verify对中心接口进行压测……高verify升级后架构正式上线……无verify监控切换mysql之后的接口性能……无verify监控切换mysql之后对相关依赖系统的影响……无todo停mongo写……无todo继续迁移海关mongo中其他表(以上均为trace表)……无todo彻底下线mongo数据库服务器，只保留mysql服务器……无 5.2 记录一次异构具有复杂分片规则数据库的过程5.2.1 难点​ 交易库存复杂的分片规则，数据量大，更新频繁，一致性保证。 回到本源，缓存+队列 5.2.2 不跑题，我们就说分片部分，如何接手一个复杂分片规则的数据库？ 参考案例如何异构一个数十亿级别的数据库 有多复杂?​ 6000+表，28个库，4套分片规则。(解决方案 sharding-jdbc)]]></content>
      <tags>
        <tag>分布式数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neo4j资料 Neo4j教程 Neo4j视频教程 Neo4j 图数据库视频教程]]></title>
    <url>%2Fpost%2Fcc42e7fa.html</url>
    <content type="text"><![CDATA[课程发布地址 地址： 腾讯课堂《Neo4j 图数据库视频教程》 https://ke.qq.com/course/327374?tuin=442d3e14作者庞国明，《Neo4j权威指南》副主编、《Neo4j 3.x 入门经典》翻译 邮箱：pangguoming@yeah.net QQ:1143815700 Neo4j技术讨论QQ群：547190638 Neo4j中文社区:http://neo4j.com.cn 面向人群Neo4j初学者；已掌握一定Neo4j技术的开发人员 课程目的快速入门和掌握Neo4j相关应用和开发技术，能够将Neo4j应用到相关业务领域，并能够掌握相关技术平台的开发 课程说明 课程面向Neo4j 3.4.x版本 课程共39节，每节课约1小时课时，总共约40小时课时 每节课都有 详细操作过程、操作结果展示 每节课都有 教学文档、实例项目（源代码）供学员下载 课程涉猎 Neo4j入门、基本操作、Cypher、程序开发、运维、应用案例等多个方面 因录制本套课程需付出一定时间和精力成本，因此为付费课程，价格39元 课程内容介绍 第1节 图数据库基础 第2节 Neo4j安装与基本操控 第3节 Neo4j基本概念与入门实例 第4节 Cypher 概述与基本语法 第5节 Cypher 语句——MATCH、OPTIONAL MATCH 第6节 Cypher 语句——WHER、RETURN、START、CREATE 第7节 Cypher 语句——MERGE、CREATE UNIQUE、SET 第8节 Cypher 语句——DELETE、REMOVE、ORDERBY LIMIT SKIP WITH 第9节 Cypher 语句——FOREACH、Aggregation、UNWIND、UNION、CALL、LOAD CSV 第10节 Cypher 函数——断言、标量、列表 第11节 Cypher 函数——数学、字符串、自定义 第12节 Cypher 索引、约束、统计 第13节 Cypher 查询调优与执行计划 第14节 Java 嵌入式开发模式 第15节 Java 嵌入式开发——遍历 第16节 Java 嵌入式开发——索引 第17节 Java 嵌入式开发——用户自定义过程 第18节 Java 嵌入式开发——用户自定义函数 第19节 java在线备份数据库与 对数据库实时监控 第20节 java 驱动开发——链接与配置 第21节 Java 驱动开发——session、事务、异步、结果集、异常、书签 第22节 .Net 驱动开发——链接、配置 第23节 .Net 驱动开发——session、事务、异步、结果集、异常、书签 第24节 javescript 驱动开发——链接与配置 第25节 javescript 驱动开发——session、事务、异步、结果集、异常、书签 第26节 javescript 驱动开发——网页端开发 第27节 Python 驱动开发——链接与配置 第28节 Python 驱动开发——session、事务、异步、结果集、异常、书签 第29节 Spring Data Neo4j开发——环境搭建、入门实例 第30节 Spring Data Neo4j开发——测试运行 第31节 HTTP API 开发——流、认证、事务、返回数据、错误处理 第33节 HTTP API 开发——关系、类型、属性、标签、度、索引、约束、遍历 第34节 Neo4j 管理——部署、配置、监控 第35节 Neo4j 管理——备份、恢复 第36节 Neo4j 管理——导入、导出 第37节 Neo4j 管理——安全管理 第38节 Neo4j 管理——运维、优化 第39节 案例 Neo4j与D3.js 实现数据可视化展示（两种技术方案实现） 课程疏漏处理因时间仓促、缺乏授课经验 课程中难免有疏漏、错误，恳请广大学员批评指正，对课程中的错误我会及时修改并重新录制。 大家可以在本帖或腾讯课堂留言指明错误。 对课程中出现的缺点和不足，请在neo4j中文社区留言（http://neo4j.com.cn/topic/5b83b27fd40e09d75e4d2521） 谢谢]]></content>
      <tags>
        <tag>neo4j</tag>
        <tag>视频教程</tag>
        <tag>Neo4j视频教程</tag>
        <tag>Neo4j 图数据库视频教程</tag>
        <tag>Neo4j教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql分布式数据库中间件对比]]></title>
    <url>%2Fpost%2Fc0603c85.html</url>
    <content type="text"><![CDATA[目前数据库中间件有很多，基本这些中间件在下都有了解和使用，各种中间件优缺点及使用场景也都有些心的。所以总结一个关于中间件比较的系列，希望可以对大家有帮助。## 1. 什么是中间件传统的架构模式就是 应用连接数据库直接对数据进行访问，这种架构特点就是简单方便。但是随着目前数据量不断的增大我们就遇到了问题: 单个表数据量太大 单个库数据量太大 单台数据量服务器压力很大 读写速度遇到瓶颈当面临以上问题时，我们会想到的第一种解决方式就是 向上扩展(scale up) 简单来说就是不断增加硬件性能。这种方式只能暂时解决问题，当业务量不断增长时还是解决不了问题。特别是淘宝，facebook，youtube这种业务成线性，甚至指数级上升的情况此时我们不得不依赖于第二种方式： 水平扩展 。 直接增加机器，把数据库放到不同服务器上，在应用到数据库之间加一个proxy进行路由，这样就可以解决上面的问题了。## 2. 中间件与读写分离很多人都会把中间件认为是读写分离，其实读写分离只是中间件可以提供的一种功能，最主要的功能还是在于他可以 分库分表 ，下面是一个读写分离的示意图：上面的图可以看出，红线代表写请求，绿线代表读请求。这就是一个简单的读写分离，下面我们在看看分库分表中间件。上面这幅图就可以看出中间件作用，比如下面的这个SQL：[sql] view plain copy1. &lt;span class=“operator” style=“”&gt;&lt;span class=“keyword” style=“”&gt;select * &lt;span class=“keyword” style=“”&gt;from table_name &lt;span class=“keyword” style=“”&gt;where id = &lt;span class=“number” style=“”&gt;1; 按照中间件分库分表算法，此SQL将发送到DB1节点，由DB1这个MySQL负责解析和获取id=1的数据，并通过中间件返回给客户端。而在读写分离结构中并没有这些分库分表规则， 他只能在众多读节点中load balance随机进行分发，它要求各个节点都要存放一份完整的数据。## 3.各类中间件比较目前市面上中间件种类很多种 先看下各种中间件背景:#### Cobar:阿里巴巴B2B开发的关系型分布式系统，管理将近3000个MySQL实例。 在阿里经受住了考验，后面由于作者的走开的原因cobar没有人维护 了，阿里也开发了tddl替代cobar。#### MyCAT:社区爱好者在阿里cobar基础上进行二次开发，解决了cobar当时存 在的一些问题，并且加入了许多新的功能在其中。目前MyCAT社区活 跃度很高，目前已经有一些公司在使用MyCAT。总体来说支持度比 较高，也会一直维护下去，#### OneProxy:数据库界大牛，前支付宝数据库团队领导楼总开发，基于mysql官方 的proxy思想利用c进行开发的，OneProxy是一款商业收费的中间件， 楼总舍去了一些功能点，专注在性能和稳定性上。有朋友测试过说在 高并发下很稳定。#### Vitess:这个中间件是Youtube生产在使用的，但是架构很复杂。 与以往中间件不同，使用Vitess应用改动比较大要 使用他提供语言的API接口，我们可以借鉴他其中的一些设计思想。#### Kingshard:Kingshard是前360Atlas中间件开发团队的陈菲利用业务时间 用go语言开发的，目前参与开发的人员有3个左右， 目前来看还不是成熟可以使用的产品，需要在不断完善。#### Atlas:360团队基于mysql proxy 把lua用C改写。原有版本是支持分表， 目前已经放出了分库分表版本。在网上看到一些朋友经常说在高并 发下会经常挂掉，如果大家要使用需要提前做好测试。#### MaxScale与MySQL Route:这两个中间件都算是官方的吧，MaxScale是mariadb (MySQL原作者维护的一个版本)研发的，目前版本不支持分库分表。MySQL Route是现在MySQL 官方Oracle公司发布出来的一个中间件。这两个中间件后面也会跟进测试下，看下效果如何。## 4. 结语这里主要是简单介绍了下各种中间件由来和特点，后面文章会陆续介绍各个中间件更详细的特性，优缺点，性能测试结果。好文要顶 关注我 收藏该文]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>分布式数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[申请高级项目经理]]></title>
    <url>%2Fpost%2F30e25557.html</url>
    <content type="text"><![CDATA[要评计算机系统集成项目经理必须先考软考的系统集成项管理工程师，如果想评计算机系统集成高级项目经理必须考软考的信息系统项目管理师。考试一年2次，每年的5月下旬和11月中旬， 项目经理应当符合下列条件：（一） 参加并通过信息系统项目管理师专业资格考试； （二）具有IT相关专业学历且从事信息系统集成相关工作，如非IT相关专业则要加考IT专业知识。学历、职称及工作经历应符合下列条件之一： 1、具有专科学历且从事信息系统集成相关工作不少于4年； 2、具有本科以上学历且从事信息系统集成相关工作不少于2年； 3、具有中级专业技术职称且从事信息系统集成相关工作不少于1年。 （三）近两年管理过、或作为项目组主要成员参与管理过的系统集成项目未发生过责任事故，其中验收完成的系统集成项目应符合下列条件之一： 1、至少有2项合同额在200万元以上的系统集成项目；2、完成系统集成项目总额500万以上，其中至少一项合同额在100万以上、软件费用不低于30%的系统集成项目。 高级项目经理应当符合下列条件： （一） 参加信息产业部指定培训机构组织的高级项目经理培训并取得高级项目经理培训合格证； （二） 获得项目经理资质不少于3年（成绩特别突出者可破格）； （三） 具有本科以上（含本科）学历或中级以上（含中级）专业技术职称； （四） 作为项目负责人或主要管理人员近3年管理过的系统集成项目未发生过责任事故，其中验收完成的系统集成项目应符合下列条件之一： 1、至少有1项合同额在1200万元人民币以上、软件费用不低于30%的系统集成项目； 2、系统集成项目总额3000万以上，其中至少2项合同额在500万以上、软件费用不低于30%的系统集成项目。 资深项目经理应当符合下列条件： （一） 参加信息产业部指定培训机构组织的资深项目经理培训并取得资深项目经理培训合格证； （二） 获得高级项目经理资质不少于5年； （三） 具有硕士以上（含硕士）学位，或具有高级以上（含高级）专业技术职称； （四） 具有在一、二级计算机信息系统集成资质的企、事业单位中担任过高级技术管理职务的经历； （五） 近5年管理过的系统集成项目未发生过责任事故，并且具有组织管理大规模复杂系统集成项目的经验，其中验收完成的系统集成项目应符合下列条件之一： 1、至少有2项合同额在3000万元人民币以上、软件费用不低于30%的系统集成项目； 2、至少有4项合同额在1500万元人民币以上、软件费用不低于30%的系统集成项目。]]></content>
      <tags>
        <tag>项目经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号网页授权获取用户openid]]></title>
    <url>%2Fpost%2F9e02c4f5.html</url>
    <content type="text"><![CDATA[最近一个项目是在微信公众号内二次开发，涉及到微信公众号支付，根据文档要求想要支付就必须要获取到用户的openid。 这是微信官方文档https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842 官方流程网页授权流程分为四步：1、引导用户进入授权页面同意授权，获取code2、通过code换取网页授权access_token（与基础支持中的access_token不同）3、如果需要，开发者可以刷新网页授权access_token，避免过期4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制） 我的思路1、首先是要在公众号后台进行配置，设置回调路径，具体要求参照官方文档。 要将这里的txt文件放在项目根路径下，否则上面的回调域名是无法保存的。 2、用户访问第三方页面时，先去请求一个api，获取code和state code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期。 请求API参数拼接https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxXXXXXXXXXXXXXXXXXXXXXX&amp;redirect_uri=http://XXXXXXXXXXX/ydx-business/payWeiXin/getOpenId&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1&amp;connect_redirect=1#wechat_redirect 这里的scope分为两种：一种是静默方式（snsapi_base）；一种是非静默方式（snsapi_userinfo），需要用户去手动点击同意才能获取用户的信息。 这是非静默方式授权 静默方式直接就获取到了openid 3、在1中配置的回调方法中根据获取到的code和state再去请求如下接口，获取access_token 和openid。 获取code后，请求以下链接获取access_token：https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 代码段 @SuppressWarnings(“null”) @RequestMapping(“/getOAuth”) public String getOAuth(){ String code = request.getParameter(“code”);//获取微信服务器授权返回的code值 String state = request.getParameter(“state”);//验证是否来自微信重定向的请求 PrintWriter pw = null; try { pw = response.getWriter(); if(Constant.STATE.equals(state)){ /** * 构造请求链接 * https://api.weixin.qq.com/sns/oauth2/access_token? * appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code */ String url = Constant.ACCESS_TOKEN_URL+Constant.APP_ID+&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;secret=&quot;+Constant.APP_SECRET+&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;code=&quot;+code+&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;grant_type=authorization_code&quot;; String jsonStr = HttpUtil.httpRequest(url); String openid = JSONObject.parseObject(jsonStr).getString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;openid&quot;); System.out.println(openid+&lt;span class=&quot;hljs-string&quot;&gt;&quot;==========================&quot;); session = request.getSession(); session.setAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;openid&quot;, openid); &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-string&quot;&gt;&quot;login/wx_login&quot;;&lt;span class=&quot;hljs-comment&quot;&gt;//登录页面 }&lt;span class=&quot;hljs-keyword&quot;&gt;else{ response.setContentType(&lt;span class=&quot;hljs-string&quot;&gt;&quot;text/html;charset=utf-8&quot;); pw.write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;script&gt;alert(&apos;授权失败!&apos;);&lt;/script&gt;&quot;); pw.flush(); pw.close(); } } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (IOException e) { e.printStackTrace(); response.setContentType(&lt;span class=&quot;hljs-string&quot;&gt;&quot;text/html;charset=utf-8&quot;); pw.write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;script&gt;alert(&apos;发生后台异常!&apos;);&lt;/script&gt;&quot;); pw.flush(); pw.close(); } &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;null; }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;``` 总结：到此就已经获取到了用户的openid，因为只涉及支付业务所用就不再往下获取用户的个人信息。感觉微信这里的官方文档逻辑还都比较清楚，照着流程走下来一般都没什么问题，具体如何获取到openid的代码可以参考我前文里的那段，已经在实际项目中实践过。]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷软件开发简述]]></title>
    <url>%2Fpost%2F1cd017d.html</url>
    <content type="text"><![CDATA[前言：由于我读了邹欣老师的《构建之法:现代软件工程(第二版)》，因此对敏捷软件开发有了比较大的兴趣。于是我在网上找了一些论文，比如Requirements Engineering and Agile Software Development、A decade of agile methodologies: Towards explaining agile software development。在读了这些论文之后，对敏捷软件开发有了大致的了解。这篇博文主要是简单介绍敏捷软件开发，重点集中在主要的敏捷开发方法和它的优势，同时也作为一个备忘录，来记录我在这个过程中收获到的重要的知识。 目录 敏捷开发简介 传统软件开发方法的缺点 敏捷的优势 主要的敏捷方法 4.1 Scrum 4.2 极限编程（eXtreme Prgramming） 4.3 精益软件开发（Lean Software Development） 参考文献 1. 敏捷开发简介软件工程一直是一项复杂的任务，而纵观其历史，软件工程也发展出了许多不同的理论。从最开始的原始状态，到逐渐成型的瀑布模型，软件工程正在不断发展。在二十一世纪初，有专家又提出了敏捷开发的概念，并且这个概念在近些年来被大量实践。因此，本博客将主要介绍敏捷软件开发的优点以及具体内容。 敏捷不是某一种方法论、过程或框架，也不是字面意义上的敏捷，而是一组价值观和原则。这些价值观和原则由17位软件开发领域的领军人物在2001年通过《敏捷宣言》传递给世界，也在那个时候宣告了全球敏捷开发运动的开始。 敏捷宣言 我们通过身体力行和帮助他人来揭示更好的软件开发方式。经由这项工作，我们形成了如下价值观： 个体与交互 重于 过程和工具 可用的软件 重于 完备的文档 客户协作 重于 合同谈判 响应变化 重于 遵循计划 在每组比对中，后者并非全无价值，但我们更看重前者。 敏捷12原则 我们的最高目标是，通过尽早和持续地交付有价值的软件来满足客户。 欢迎对需求提出变更——即使是在项目开发后期。要善于利用需求变更，帮助客户获得竞争优势。 要不断交付可用的软件，周期从几周到几个月不等，且越短越好。 项目过程中，业务人员与开发人员必须在一起工作。 要善于激励项目人员，给他们以所需要的环境和支持，并相信他们能够完成任务。 无论是团队内还是团队间，最有效的沟通方法是面对面的交谈。 可用的软件是衡量进度的主要指标。 敏捷过程提倡可持续的开发。项目方、开发人员和用户应该能够保持持续稳定的进展速度。 对技术的精益求精以及对设计的不断完善将提升敏捷性。 要做到简洁，即尽最大可能减少不必要的工作。这是一门艺术。 最佳的架构、需求和设计出自于自组织的团队。 团队要定期反省如何能够做到更有效，并相应地调整团队的行为。 符合敏捷价值观及原则的主流敏捷开发方法包括：极限编程（eXtreme Prgramming），精益软件开发（Lean Software Development），动态系统开发方法（DSDM）,Scrum等等。 2. 传统软件开发方法的缺点 传统型软件开发是基于“瀑布模型”的开发方式，以软件架构为核心，采用结构化设计以及分析方法将软件生命划分期限，并且开发进度按照从上而下的顺序相互衔接，如同瀑布一般。瀑布模型是Winston Royce在1970年提出的一种软件开发模型，其严格遵守计划、分析、编码、测试、维护的步骤。阶段之间通过文档流通，每个阶段结束时要进行严格的审查，检查功能设计和实现是否符合上阶段流下了的文档的要求，如果不符合就逆流到上个阶段检查并修正，以此往复，直到流到最后阶段产品通过测试后进行发布及运行期间的维护。 图1 瀑布模型开发过程 由于各个阶段需要文档相互流通，在软件开发前期就需要对整个软件的架构进行设计。优秀的架构可以使软件足以支撑整个功能体系以及便于维护，而这样优秀强大的框架通常需要在十分有经验并且有着独特眼光的架构师在完全理解开发用户的需求之后才可能设计出，通常难度是较大。并且软件的框架一旦确定下来就很难改变，甚至会牵一发而动全身，难以适应的客户需求。此外，在软件开发过程中需要人员之间交流的并不多，每一个阶段对代码的编写或者测试都由文档规定。由于各个阶段要自上而下相互衔接，各个阶段的沟通要通过大量臃肿、复杂的文档来传递信息。这样的软件开发通常会将每一块的功能做的相对完善，而模块之间的衔接以及充分理解文档的时间将显得非常长。 3. 敏捷的优势敏捷方法主要通过迭代过程来应对需求和技术的变化。在每一次迭代周期结束时，都应交付用户一个可用的，可部署的系统，使得用户可以尽早的体验系统并给予反馈。每次迭代周期应尽可能短，以便能及时频繁地处理需求变化和用户反馈。 采用敏捷开发方式将会给企业和用户带来诸多好处： 交付用户需要的软件。它将带给用户其真正需要的软件系统。瀑布模式通常会在产品的起点与最终结果之间划出一条直线，然后沿着直线不断往前走。然而当项目完成时，用户通常会发现终点已经不是他们真正的目的地。而敏捷方法则采用小步的方式前行，每走完一步，都需要及时调整并确定下一步的方向，直到抵达真正的终点。 更高的质量。敏捷对迭代周期的产出有严格的质量要求。敏捷提倡使用测试驱动开发（test-driven development），即在正式开发功能代码之前，先开发该功能的测试代码。这为敏捷项目的整个开发周期提供了可靠的质量保证。 更快的将产品推向市场。敏捷提倡避免大规模的前期计划，认为那是一种很大的浪费。因为很多预先的计划的东西都会发生改变，大而全的前期计划通常是徒劳的。敏捷提倡逐步完善的计划。敏捷团队只专注于开发项目中当前最需要的、最具价值的部分。这样能尽早地投入开发，缩短产品上市的时间，或者说使得软件可以更早的交付使用。 4. 主要的敏捷方法4.1 **Scrum** Scrum最早由Jeff Sutherland在1993年提出，Ken Schwaber 在1995年OOPSLA会议上形式化了Scrum开发过程，并向业界公布。目前Scrum是应用最为广泛的敏捷方法之一。Scrum中的主要角色包括： Scrum Master: Scrum教练和团队带头人，确保团队合理的运作Scrum，并帮助团队扫除实施中的障碍； 产品负责人: 确定产品的方向和愿景，定义产品发布的内容、优先级及交付时间，为产品投资报酬率负责； 开发团队: 一个跨职能的小团队，人数5-9人，团队拥有交付可用软件需要的各种技能。 在每一次冲刺或迭代当中，开发团队创建可用的软件的一个增量。每一个迭代所要实现的功能来自产品订单。产品订单按照优先级排列工作需求。在迭代计划会议中，产品负责人告诉开发团队需要完成产品订单中的哪些订单项。开发团队决定在下一次迭代中他们能够承诺完成多少订单项。在迭代的过程中，没有人能够变更迭代订单，这意味着在一个迭代中需求是被冻结的。 图2 scrum 过程 Scrum中通过三个活动进行检验和适应：每日例会检验Sprint目标的进展，做出调整，从而优化次日的工作价值；Sprint评审和计划会议检验发布目标的进展，做出调整，从而优化下一个Sprint的工作价值；Sprint回顾会议是用来回顾已经完成的Sprint，并且确定做出什么样的改善可以使接下来的Sprint更加高效、更加令人满意，并且工作更快乐。 4.2 **极限编程（eXtreme Prgramming）** 极限编程（eXtreme Prgramming），是一种软件工程方法学。如同其他敏捷方法学，极限编程和传统方法学的本质不同在于它更强调可适应性而不是可预测性。极限编程的支持者认为软件需求的不断变化是很自然的现象，是软件项目开发中不可避免的、也是应该欣然接受的现象；他们相信，和传统的在项目起始阶段定义好所有需求再费尽心思的控制变化的方法相比，有能力在项目周期的任何阶段去适应变化，将是更加现实更加有效的方法。极限编程规定了一些实践和简单规则，包括：编写用户故事、架构规范、实施规划、迭代计划、代码开发、单元测试、验收测试等等。 像所有其他敏捷方法一样，极限编程预期并积极接受变化。它具有以下的价值观或原则： 互动交流。团队成员不是通过文档来交流，文档不是必须的。团队成员之间通过日常沟通、简单设计、测试、系统隐喻以及代码本身来沟通产品需求和系统设计。 反馈。反馈是一种信息的交流，能使系统更加完善。反馈也和交流密切相关，客户的实际使用、功能测试、单元测试等都能为开发团队提供反馈信息。同时，开发团队也可以通过估计和设计用户案例的方式将信息反馈给客户。 简单。极限编程提倡简单的设计，简单的解决方案。极限编程总是从一个简单的系统入手，并且只创建今天可能需要的功能模块。因为它认为，创建明天需要的功能模块可能会由于需求的变化而成为浪费。 勇气。极限编程理论中的“系统开发中的勇气”最好用一组实践来诠释。其中之一就是“只为今天的需求设计以及编码，不要考虑明天”这条戒律。这是努力避免陷入设计的泥潭、而在其他问题上花费了太多不必要的精力。勇气使得开发人员在需要重构他们的代码时能感到舒适。这意味着重新审查现有系统并完善它会使得以后出现的变化需求更容易被实现。另一个勇气的例子是了解什么时候应该完全丢弃现有的代码。每个程序员都有这样的经历：他们花了一整天的时间纠缠于自己设计和代码中的一个复杂的难题却无所得，而第二天回来以一个全新而清醒的角度来考虑，在半小时内就轻松解决了问题。 团队。极限编程提倡团队合作，相互尊重。极限编程以建立并激励团队为一项重要任务。同时它把互相尊重和实际的开发习惯相结合。比如，为了尊重其他团队成员的劳动成果，每个人不得将未通过单元测试的代码集成到系统中。因此，每个人的代码质量必须过关。 图3 极限编程示意图 4.3 **精益软件开发（Lean Software Development）** 精益思想的核心思想是查明和消除浪费。在软件开发过程中，bugs，没用的功能，等待以及其他任何对实现结果没有益处的东西都是浪费。浪费及其源头必须被分析查明，然后设法消除。精益开发的其它原则包括: 强调学习。软件开发过程是一个不断学习的过程。每个团队成员都需要从日常的失败，互动，交流以及信息反馈中学习，不断改进所开发的产品和开发效率。 在最后时刻做决定。这样可以避免在可能改变的事情上做无谓的努力，从而有效的避免浪费。 用最快的速度交付用户。较短的迭代周期能够加速产品的开发及交付，加快交流，提高生产力。 给团队自主权。激励团队并让所有团队成员自我管理始终是所有敏捷方法获得成功的基本因素之一。 诚信。确保整个系统正常工作，真正满足客户的需求是整个团队需要努力坚持的诚信和和对用户的承诺。 全局观。精益开发强调整体优化的系统。无论开发的组织还是被开发的产品， 从整体上考虑优化比从各个局部去优化更高效。 图4 精益软件开发原则 对于上述的每个原则，都有一些相应的实现工具。这些工具包括价值流图（Value Stream Mapping），基于集合的开发（set-based development），拉系统（pull system），排队论（queuing theory），等等。和其它敏捷方法相比，精益软件更重要的是不断完善开发过程的一种思维方式。因此，将精益模式与其他敏捷开发模式一起使用将会取得很好的效果。 5. 参考文献[1]. 敏捷开发宣言 http://agilemanifesto.org/iso/zhchs/manifesto.html [2]. 敏捷开发十二条原则 http://agilemanifesto.org/iso/zhchs/principles.html [3]. 《构建之法:现代软件工程(第二版)》 邹欣 [4]. Scrum 维基百科 https://zh.wikipedia.org/wiki/Scrum [5]. 敏捷软件开发 维基百科https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91 [6]. 极限编程 维基百科 https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B [7]. Dingsøyr, Torgeir, et al. “A decade of agile methodologies: Towards explaining agile software development.” Journal of Systems and Software85.6 (2012): 1213-1221. [8]. Paetsch, Frauke, Armin Eberlein, and Frank Maurer. “Requirements Engineering and Agile Software Development.” WETICE. Vol. 3. 2003.]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台开发----自定义菜单、消息处理及获取OpenID(C#)]]></title>
    <url>%2Fpost%2F97d4a46.html</url>
    <content type="text"><![CDATA[一、成为开发者 服务器配置 登录微信公众平台官网后，在公众平台后台管理页面 开发者中心页，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，如下图所示：12345![微信服务器配置](https://img-blog.csdn.net/20160728101107260)&lt;code class=&quot;has-numbering&quot;&gt; 其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。 &lt;/code&gt; 验证URL 开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带四个参数： 1234567![这里写图片描述](https://img-blog.csdn.net/20160728101500362) &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs markdown has-numbering&quot;&gt;加密/校验流程如下： &lt;span class=&quot;hljs-bullet&quot;&gt;1. 将token、timestamp、nonce三个参数进行字典序排序 &lt;span class=&quot;hljs-bullet&quot;&gt;2. 将三个参数字符串拼接成一个字符串进行sha1加密 &lt;span class=&quot;hljs-bullet&quot;&gt;3. 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 按照该流程，在上面填写的服务器中，写入如下验证代码： 将以上代码部署到服务器端，通过微信公众平台去验证，如果验证成功，则成为开发者成功，否则失败。验证成功后显示如下图： ## 二、创建菜单 1. 新建菜单JSON文件，如下图所示： &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;has-numbering&quot;&gt; 其中，button目录下为以及菜单，sub_button下为二级菜单&lt;/code&gt;123456 &lt;/pre&gt; 2. 获取acxess_token &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;has-numbering&quot;&gt; access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效&lt;/code&gt; &lt;/pre&gt; 3. 参数说明 4. 创建菜单 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs r has-numbering&quot;&gt;注意： &lt;span class=&quot;hljs-number&quot;&gt;1、自定义菜单最多包括&lt;span class=&quot;hljs-number&quot;&gt;3个一级菜单，每个一级菜单最多包含&lt;span class=&quot;hljs-number&quot;&gt;5个二级菜单。 &lt;span class=&quot;hljs-number&quot;&gt;2、一级菜单最多&lt;span class=&quot;hljs-number&quot;&gt;4个汉字，二级菜单最多&lt;span class=&quot;hljs-number&quot;&gt;7个汉字，多出来的部分将会以“&lt;span class=&quot;hljs-keyword&quot;&gt;...”代替。 &lt;span class=&quot;hljs-number&quot;&gt;3、创建自定义菜单后，由于微信客户端缓存，需要&lt;span class=&quot;hljs-number&quot;&gt;24小时微信客户端才会展现出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345## 三、消息处理&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;has-numbering&quot;&gt; 对消息的监听操作，要放置到最初配置URL的服务器中进行操作。判断是事件还是信息。&lt;/code&gt; 消息监听 &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt; &lt;/xml&gt;123456![这里写图片描述](https://img-blog.csdn.net/20160728095800026) 2. 事件监听 &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;has-numbering&quot;&gt; 点击菜单拉取消息时的事件推送 &lt;/code&gt; 推送XML数据包示例： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;xml&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;ToUserName&gt;&lt;span class=&quot;hljs-cdata&quot;&gt;&lt;![CDATA[toUser]]&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;ToUserName&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;FromUserName&gt;&lt;span class=&quot;hljs-cdata&quot;&gt;&lt;![CDATA[FromUser]]&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;FromUserName&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;CreateTime&gt;123456789&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;CreateTime&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;MsgType&gt;&lt;span class=&quot;hljs-cdata&quot;&gt;&lt;![CDATA[event]]&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;MsgType&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;Event&gt;&lt;span class=&quot;hljs-cdata&quot;&gt;&lt;![CDATA[CLICK]]&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;Event&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;EventKey&gt;&lt;span class=&quot;hljs-cdata&quot;&gt;&lt;![CDATA[EVENTKEY]]&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;EventKey&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;xml&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;1234567![获取菜单点击事件](https://img-blog.csdn.net/20160728095350269) ## 四、获取openID &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;has-numbering&quot;&gt; 用户向公众号发送消息时，公众号方收到的消息发送者是一个OpenID，是使用用户微信号加密后的结果，每个用户对每个公众号有一个唯一的OpenID。 &lt;/code&gt; 消息返回参数如下： 解析XML，并获取OpenID:]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台开发 自定义菜单]]></title>
    <url>%2Fpost%2F2367b8c5.html</url>
    <content type="text"><![CDATA[一、自定义菜单概述自定义菜单能够帮助公众号丰富界面，让用户更好更快地理解公众号的功能。开启自定义菜单后，公众号界面如图所示： 二、申请自定义菜单个人订阅号只能编辑生成菜单，无法开发、企业订阅号通过微信认证；可以申请到自定义菜单资格服务号默认有菜单权限。# 三、获得AppId 和AppSecertAppId和AppSecret在开发者中心-开发者ID中，可以找到。# 四、获得Access Token用appid和appsecert获得access token，接口为https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET程序实现如下12345678910111213$appid = &quot;&quot;;$appsecret = &quot;&quot;;$url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret&quot;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$output = curl_exec($ch);curl_close($ch);$jsoninfo = json_decode($output, true);$access_token = $jsoninfo[&quot;access_token&quot;]; 你也可以直接在浏览器地址栏中，拼接出地址，执行后，获得如下数据1&#123;&quot;access_token&quot;:&quot;N2L7KXa084WvelONYjkJ_traBMCCvy_UKmpUUzlrQ0EA2yNp3Iz6eSUrRG0bhaR_viswd50vDuPkY5nG43d1gbm-olT2KRMxOsVE08RfeD9lvK9lMguNG9kpIkKGZEjIf8Jv2m9fFhf8bnNa-yQH3g&quot;,&quot;expires_in&quot;:7200&#125;参数说明如下参数说明access_token获取到的凭证expires_in凭证有效时间，单位：秒其中的N2L7KXa084WvelONYjkJ_traBMCCvy_UKmpUUzlrQ0EA2yNp3Iz6eSUrRG0bhaR_viswd50vDuPkY5nG43d1gbm-olT2KRMxOsVE08RfeD9lvK9lMguNG9kpIkKGZEjIf8Jv2m9fFhf8bnNa-yQH3g123456789101112131415161718192021222324252627282930313233343536373839就是access token。或者使用官方的接口调试工具，地址为：[使用网页调试工具调试自定义菜单接口](https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E8%8E%B7%E5%8F%96access_token%E6%8E%A5%E5%8F%A3%20/token) ![](http://pangguoming.com/blog/images/b4838d9e-4139-4e7c-9a41-670a5a8db7ee.jpg)点击检查问题得，得到原文 http://www.cnblogs.com/txw1958/p/weixin-58-custom-menu.html ![](http://pangguoming.com/blog/images/0aedcad8-d5fc-4046-a25b-44be477870e2.jpg)这样也获得了access token # **五、组织菜单内容****自定义类型包括如下** &lt;pre&gt;**1、click：点击推事件** 用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event 的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互； **2、view：跳转URL** 用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。 **3、scancode_push：扫码推事件** 用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。 **4、scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框** 用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。 **5、pic_sysphoto：弹出系统拍照发图** 用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。 **6、pic_photo_or_album：弹出拍照或者相册发图** 用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。 **7、pic_weixin：弹出微信相册发图器** 用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。 **8、location_select：弹出地理位置选择器** 用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。 **9、media_id：下发消息（除文本消息）** 用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。 **10、view_limited：跳转图文消息URL** 用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。接口调用请求说明http请求方式：POST（请使用https协议） https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN请求示例 1234567891011121314151617181920212223242526272829303132&#123; &quot;button&quot;:[ &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;今日歌曲&quot;, &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;歌手简介&quot;, &quot;key&quot;:&quot;V1001_TODAY_SINGER&quot; &#125;, &#123; &quot;name&quot;:&quot;菜单&quot;, &quot;sub_button&quot;:[ &#123; &quot;type&quot;:&quot;view&quot;, &quot;name&quot;:&quot;搜索&quot;, &quot;url&quot;:&quot;http://www.soso.com/&quot; &#125;, &#123; &quot;type&quot;:&quot;view&quot;, &quot;name&quot;:&quot;视频&quot;, &quot;url&quot;:&quot;http://v.qq.com/&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;赞一下我们&quot;, &quot;key&quot;:&quot;V1001_GOOD&quot; &#125;] &#125;]&#125; 参数说明 参数是否必须说明 button 是 一级菜单数组，个数应为1~3个 sub_button 否 二级菜单数组，个数应为1~5个 type 是 菜单的响应动作类型，目前有click、view两种类型 name 是 菜单标题，不超过16个字节，子菜单不超过40个字节 key click类型必须 菜单KEY值，用于消息接口推送，不超过128字节 url view类型必须 网页链接，用户点击菜单可打开链接，不超过256字节 原文 http://www.cnblogs.com/txw1958/p/weixin-58-custom-menu.html返回结果正确时的返回JSON数据包如下： {“errcode”:0,”errmsg”:”ok”} 1234错误时的返回JSON数据包如下（示例为无效菜单名长度）： &lt;pre&gt;&#123;&quot;errcode&quot;:40018,&quot;errmsg&quot;:&quot;invalid button name size&quot;&#125; # 六、提交菜单内容给服务器菜单的JSON结构为 1&#123;&quot;button&quot;:[&#123;&quot;name&quot;:&quot;天气预报&quot;,&quot;sub_button&quot;:[&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;北京天气&quot;,&quot;key&quot;:&quot;天气北京&quot;&#125;,&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;上海天气&quot;,&quot;key&quot;:&quot;天气上海&quot;&#125;,&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;广州天气&quot;,&quot;key&quot;:&quot;天气广州&quot;&#125;,&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;深圳天气&quot;,&quot;key&quot;:&quot;天气深圳&quot;&#125;,&#123;&quot;type&quot;:&quot;view&quot;,&quot;name&quot;:&quot;本地天气&quot;,&quot;url&quot;:&quot;http://m.hao123.com/a/tianqi&quot;&#125;]&#125;,&#123;&quot;name&quot;:&quot;方倍工作室&quot;,&quot;sub_button&quot;:[&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;公司简介&quot;,&quot;key&quot;:&quot;company&quot;&#125;,&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;趣味游戏&quot;,&quot;key&quot;:&quot;游戏&quot;&#125;,&#123;&quot;type&quot;:&quot;click&quot;,&quot;name&quot;:&quot;讲个笑话&quot;,&quot;key&quot;:&quot;笑话&quot;&#125;]&#125;]&#125;将以下代码保存为menu.php，并且在浏览器中运行该文件（比如 http://127.0.0.1/menu.php），将直接向微信服务器提交菜单， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 &lt;?php $access_token = &quot;&quot;; $jsonmenu = &apos;&#123; &quot;button&quot;:[ &#123; &quot;name&quot;:&quot;天气预报&quot;, &quot;sub_button&quot;:[ &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;北京天气&quot;, &quot;key&quot;:&quot;天气北京&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;上海天气&quot;, &quot;key&quot;:&quot;天气上海&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;广州天气&quot;, &quot;key&quot;:&quot;天气广州&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;深圳天气&quot;, &quot;key&quot;:&quot;天气深圳&quot; &#125;, &#123; &quot;type&quot;:&quot;view&quot;, &quot;name&quot;:&quot;本地天气&quot;, &quot;url&quot;:&quot;http://m.hao123.com/a/tianqi&quot; &#125;] &#125;, &#123; &quot;name&quot;:&quot;方倍工作室&quot;, &quot;sub_button&quot;:[ &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;公司简介&quot;, &quot;key&quot;:&quot;company&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;趣味游戏&quot;, &quot;key&quot;:&quot;游戏&quot; &#125;, &#123; &quot;type&quot;:&quot;click&quot;, &quot;name&quot;:&quot;讲个笑话&quot;, &quot;key&quot;:&quot;笑话&quot; &#125;] &#125;] &#125;&apos;; $url = &quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;.$access_token; $result = https_request($url, $jsonmenu); var_dump($result); function https_request($url,$data = null)&#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE); if (!empty($data))&#123; curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($curl); curl_close($curl); return $output; &#125; ?&gt; 原文 http://www.cnblogs.com/txw1958/p/weixin-58-custom-menu.html或者使用官方的调试接口 使用网页调试工具调试该接口 提交成功后，重新关注后即可看到菜单。菜单效果类似如下：原文 http://www.cnblogs.com/txw1958/p/weixin-58-custom-menu.html # 七、响应菜单点击事件在消息接口中处理event事件,其中的click代表菜单点击,通过响应菜单结构中的key值回应消息，view事件无须响应，将直接跳转过去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;?php/* 【版权声明】 本软件产品的版权归方倍工作室所有，受《中华人民共和国计算机软件保护条例》等知识产权法律及国际条约与惯例的保护。您获得的只是本软件的使用权。 您不得: * 在未得到授权的情况下删除、修改本软件及其他副本上一切关于版权的信息； * 销售、出租此软件产品的任何部分； * 从事其他侵害本软件版权的行为。 如果您未遵守本条款的任一约定，方倍工作室有权立即终止本条款的执行，且您必须立即终止使用本软件并销毁本软件产品的任何副本。这项要求对各种拷贝形式有效。 您同意承担使用本软件产品的风险，在适用法律允许的最大范围内，方倍工作室在任何情况下不就因使用或不能使用本软件产品所发生的特殊的、意外的、非直接或间接的损失承担赔偿责任。即使已事先被告知该损害发生的可能性。 如使用本软件所添加的任何信息，发生版权纠纷，方倍工作室不承担任何责任。 方倍工作室对本条款拥有最终解释权。 CopyRight 2013 方倍工作室 All Rights Reserved */ define(&quot;TOKEN&quot;, &quot;weixin&quot;);$wechatObj = new wechatCallbackapiTest();if (!isset($_GET[&apos;echostr&apos;])) &#123; $wechatObj-&gt;responseMsg();&#125;else&#123; $wechatObj-&gt;valid();&#125;class wechatCallbackapiTest&#123; public function valid() &#123; $echoStr = $_GET[&quot;echostr&quot;]; if($this-&gt;checkSignature())&#123; echo $echoStr; exit; &#125; &#125; private function checkSignature() &#123; $signature = $_GET[&quot;signature&quot;]; $timestamp = $_GET[&quot;timestamp&quot;]; $nonce = $_GET[&quot;nonce&quot;]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode( $tmpArr ); $tmpStr = sha1( $tmpStr ); if( $tmpStr == $signature )&#123; return true; &#125;else&#123; return false; &#125; &#125; public function responseMsg() &#123; $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;]; if (!empty($postStr))&#123; $postObj = simplexml_load_string($postStr, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA); $RX_TYPE = trim($postObj-&gt;MsgType); switch ($RX_TYPE) &#123; case &quot;text&quot;: $resultStr = $this-&gt;receiveText($postObj); break; case &quot;event&quot;: $resultStr = $this-&gt;receiveEvent($postObj); break; default: $resultStr = &quot;&quot;; break; &#125; echo $resultStr; &#125;else &#123; echo &quot;&quot;; exit; &#125; &#125; private function receiveText($object) &#123; $funcFlag = 0; $contentStr = &quot;你发送的内容为：&quot;.$object-&gt;Content; $resultStr = $this-&gt;transmitText($object, $contentStr, $funcFlag); return $resultStr; &#125; private function receiveEvent($object) &#123; $contentStr = &quot;&quot;; switch ($object-&gt;Event) &#123; case &quot;subscribe&quot;: $contentStr = &quot;欢迎关注方倍工作室&quot;; case &quot;unsubscribe&quot;: break; case &quot;CLICK&quot;: switch ($object-&gt;EventKey) &#123; case &quot;company&quot;: $contentStr[] = array(&quot;Title&quot; =&gt;&quot;公司简介&quot;, &quot;Description&quot; =&gt;&quot;方倍工作室提供移动互联网相关的产品及服务&quot;, &quot;PicUrl&quot; =&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;weixin://addfriend/pondbaystudio&quot;); break; default: $contentStr[] = array(&quot;Title&quot; =&gt;&quot;默认菜单回复&quot;, &quot;Description&quot; =&gt;&quot;您正在使用的是方倍工作室的自定义菜单测试接口&quot;, &quot;PicUrl&quot; =&gt;&quot;http://discuz.comli.com/weixin/weather/icon/cartoon.jpg&quot;, &quot;Url&quot; =&gt;&quot;weixin://addfriend/pondbaystudio&quot;); break; &#125; break; default: break; &#125; if (is_array($contentStr))&#123; $resultStr = $this-&gt;transmitNews($object, $contentStr); &#125;else&#123; $resultStr = $this-&gt;transmitText($object, $contentStr); &#125; return $resultStr; &#125; private function transmitText($object, $content, $funcFlag = 0) &#123; $textTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;FuncFlag&gt;%d&lt;/FuncFlag&gt;&lt;/xml&gt;&quot;; $resultStr = sprintf($textTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content, $funcFlag); return $resultStr; &#125; private function transmitNews($object, $arr_item, $funcFlag = 0) &#123; //首条标题28字，其他标题39字 if(!is_array($arr_item)) return; $itemTpl = &quot; &lt;item&gt; &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt; &lt;/item&gt;&quot;; $item_str = &quot;&quot;; foreach ($arr_item as $item) $item_str .= sprintf($itemTpl, $item[&apos;Title&apos;], $item[&apos;Description&apos;], $item[&apos;PicUrl&apos;], $item[&apos;Url&apos;]); $newsTpl = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[]]&gt;&lt;/Content&gt;&lt;ArticleCount&gt;%s&lt;/ArticleCount&gt;&lt;Articles&gt;$item_str&lt;/Articles&gt;&lt;FuncFlag&gt;%s&lt;/FuncFlag&gt;&lt;/xml&gt;&quot;; $resultStr = sprintf($newsTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), count($arr_item), $funcFlag); return $resultStr; &#125;&#125;?&gt; 原文 http://www.cnblogs.com/txw1958/p/weixin-58-custom-menu.html # 八、菜单中获取OpenID由于菜单中只能填写固定的url地址，对于想要菜单中获取用户的OpenID的情况，可以使用OAuth2.0授权的方式来实现。URL中填写的地址为一个固定的回调地址。原理方法可以参考 微信公众平台开发(99) 自定义菜单获取OpenID]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#开发微信公众平台-就这么简单（附Demo）]]></title>
    <url>%2Fpost%2F702a1c40.html</url>
    <content type="text"><![CDATA[阅读目录： 服务号和订阅号 URL配置 创建菜单 查询、删除菜单 接受消息 发送消息（图文、菜单事件响应） 示例Demo下载 后记 最近公司在做微信开发，其实就是接口开发，网上找了很多资料，当然园友也写了很多教程，但都是理论说了一大堆，实用指导或代码很少。如果你自己仔细研究下，其实就那么点东西，C#实现起来也很简单，原本不想写这篇文章的，但是本人当时摸索走了很多弯路，这边总结下，希望初次接触微信公众平台的朋友别像当时的我一样。 自己动手，丰衣足食。 服务号和订阅号 服务号是公司申请的微信公共账号，订阅号是个人申请的，我个人也申请了一个，不过没怎么用。 服务号 1个月(30天)内仅可以发送1条群发消息。 发给订阅用户(粉丝)的消息，会显示在对方的聊天列表中。 在发送消息给用户时，用户将收到即时的消息提醒。 服务号会在订阅用户(粉丝)的通讯录中。 可申请自定义菜单。 订阅号 每天(24小时内)可以发送1条群发消息。 发给订阅用户(粉丝)的消息，将会显示在对方的订阅号文件夹中。 在发送消息给订阅用户(粉丝)时，订阅用户不会收到即时消息提醒。 在订阅用户(粉丝)的通讯录中，订阅号将被放入订阅号文件夹中。 订阅号不支持申请自定义菜单。 URL配置 启用开发模式需要先成为开发者，而且编辑模式和开发模式只能选择一个，进入微信公众平台-开发模式，如下： 需要填写url和token，当时本人填写这个的时候花了好久，我本以为填写个服务器的url就可以了（80端口），但是不行，主要是没有仔细的阅读提示信息，所以总是提示 从上面可以看出，点击提交后微信会向我们填写的服务器发送几个参数，然后需要原样返回出来，所以在提交url的时候，先在服务器创建接口测试返回echostr参数内容。代码： 1234567891011121314151617181920 1 //成为开发者url测试，返回echoStr 2 public void InterfaceTest() 3 &#123; 4 string token = &quot;填写的token&quot;; 5 if (string.IsNullOrEmpty(token)) 6 &#123; 7 return; 8 &#125; 9 10 string echoString = HttpContext.Current.Request.QueryString[&quot;echoStr&quot;];11 string signature = HttpContext.Current.Request.QueryString[&quot;signature&quot;];12 string timestamp = HttpContext.Current.Request.QueryString[&quot;timestamp&quot;];13 string nonce = HttpContext.Current.Request.QueryString[&quot;nonce&quot;];14 15 if (!string.IsNullOrEmpty(echoString))16 &#123;17 HttpContext.Current.Response.Write(echoString);18 HttpContext.Current.Response.End();19 &#125;20 &#125; 在一般处理程序ashx的ProcessRequest的方法内调用上面的方法，url填写的就是这个ashx的服务器地址，token是一个服务器标示，可以随便输入，代码中的token要和申请填写的一致，成为开发者才能做开发。 创建菜单 我们添加一些微信服务号，聊天窗口下面有些菜单，这个可以在编辑模式简单配置，也可以在开发模式代码配置。微信公众平台开发者文档：http://mp.weixin.qq.com/wiki/index.php?title=自定义菜单创建接口，可以看到创建菜单的一些要点，下面的使用网页调试工具调试该接口，只是调试接口是否可用，并不是直接创建菜单的，菜单分为两种： click： 用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event 的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互。 view： 用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的url值 （即网页链接），达到打开网页的目的，建议与网页授权获取用户基本信息接口结合，获得用户的登入个人信息。 click菜单需要填一个key，这个是在我们菜单点击事件的时候会用到，view只是一个菜单超链接。菜单数据是json格式，官网是php示例，其实C#实现起来也很简单，就是post发送一个json数据，示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 1 public partial class createMenu : System.Web.UI.Page 2 &#123; 3 protected void Page_Load(object sender, EventArgs e) 4 &#123; 5 FileStream fs1 = new FileStream(Server.MapPath(&quot;.&quot;)+&quot;\\menu.txt&quot;, FileMode.Open); 6 StreamReader sr = new StreamReader(fs1, Encoding.GetEncoding(&quot;GBK&quot;)); 7 string menu = sr.ReadToEnd(); 8 sr.Close(); 9 fs1.Close();10 GetPage(&quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=access_token&quot;, menu);11 &#125;12 public string GetPage(string posturl, string postData)13 &#123;14 Stream outstream = null;15 Stream instream = null;16 StreamReader sr = null;17 HttpWebResponse response = null;18 HttpWebRequest request = null;19 Encoding encoding = Encoding.UTF8;20 byte[] data = encoding.GetBytes(postData);21 // 准备请求...22 try23 &#123;24 // 设置参数25 request = WebRequest.Create(posturl) as HttpWebRequest;26 CookieContainer cookieContainer = new CookieContainer();27 request.CookieContainer = cookieContainer;28 request.AllowAutoRedirect = true;29 request.Method = &quot;POST&quot;;30 request.ContentType = &quot;application/x-www-form-urlencoded&quot;;31 request.ContentLength = data.Length;32 outstream = request.GetRequestStream();33 outstream.Write(data, 0, data.Length);34 outstream.Close();35 //发送请求并获取相应回应数据36 response = request.GetResponse() as HttpWebResponse;37 //直到request.GetResponse()程序才开始向目标网页发送Post请求38 instream = response.GetResponseStream();39 sr = new StreamReader(instream, encoding);40 //返回结果网页（html）代码41 string content = sr.ReadToEnd();42 string err = string.Empty;43 Response.Write(content);44 return content;45 &#125;46 catch (Exception ex)47 &#123;48 string err = ex.Message;49 return string.Empty;50 &#125;51 &#125;52 &#125; menu.text里面的内容就是json示例菜单，大家可以从示例复制下来，按照你的需要修改一些就行了。 关于access_token，其实就是一个请求标示，获取方式：https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=appid&amp;secret=secret；appid和secret是开发者标示，在你的信息里面可以看到，通过这个链接返回一个json数据，就可以得到access_token值。 需要注意的是：access_token有一定的时效性，失效的话就需要重新获取下，这个在本机就可以创建，不需要上传到服务器，创建菜单正确，返回{“errcode”:0,”errmsg”:”ok”}提示信息。这边就不截图了，大家试下就可以看到效果，一般创建菜单是一到两分钟生效，实在不行就重新关注下。 查询、删除菜单 查询和删除菜单也很简单，只不过是get请求，不需要传数据，看下示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142 1 public partial class selectMenu : System.Web.UI.Page 2 &#123; 3 protected void Page_Load(object sender, EventArgs e) 4 &#123; 5 GetPage(&quot;https://api.weixin.qq.com/cgi-bin/menu/get?access_token=access_token&quot;); 6 //GetPage(&quot;https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=access_token&quot;); 7 &#125; 8 public string GetPage(string posturl) 9 &#123;10 Stream instream = null;11 StreamReader sr = null;12 HttpWebResponse response = null;13 HttpWebRequest request = null;14 Encoding encoding = Encoding.UTF8;15 // 准备请求...16 try17 &#123;18 // 设置参数19 request = WebRequest.Create(posturl) as HttpWebRequest;20 CookieContainer cookieContainer = new CookieContainer();21 request.CookieContainer = cookieContainer;22 request.AllowAutoRedirect = true;23 request.Method = &quot;GET&quot;;24 request.ContentType = &quot;application/x-www-form-urlencoded&quot;;25 //发送请求并获取相应回应数据26 response = request.GetResponse() as HttpWebResponse;27 //直到request.GetResponse()程序才开始向目标网页发送Post请求28 instream = response.GetResponseStream();29 sr = new StreamReader(instream, encoding);30 //返回结果网页（html）代码31 string content = sr.ReadToEnd();32 string err = string.Empty;33 Response.Write(content);34 return content;35 &#125;36 catch (Exception ex)37 &#123;38 string err = ex.Message;39 return string.Empty;40 &#125;41 &#125;42 &#125; access_token获取方式上面已经讲过了，查询菜单返回的是json数据，其实就是我们创建菜单的menu.txt里面的内容。 删除成功返回信息提示：{“errcode”:0,”errmsg”:”ok”}，这个也只要在本地运行就可以了。 接受消息 微信公众平台开发者文档：http://mp.weixin.qq.com/wiki/index.php?title=接收普通消息，我们使用微信就是要对用户发送的信息进行处理，这边以接受普通消息为例，语音、图片消息等，举一反三可得。 从文档上可以看出接受消息获得的是一个xml格式文件，当时有点犯傻的是，我要在哪边进行接受消息啊？还郁闷了半天，其实就是你一开始填写的url，是不是很汗颜啊，哈哈。 123456781 &lt;xml&gt;2 &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;3 &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; 4 &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;5 &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;6 &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;7 &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;8 &lt;/xml&gt; 我们在ashx添加下面代码： 1234567891011121314151617181920212223242526 1 public void ProcessRequest(HttpContext param_context) 2 &#123; 3 string postString = string.Empty; 4 if (HttpContext.Current.Request.HttpMethod.ToUpper() == &quot;POST&quot;) 5 &#123; 6 using (Stream stream = HttpContext.Current.Request.InputStream) 7 &#123; 8 Byte[] postBytes = new Byte[stream.Length]; 9 stream.Read(postBytes, 0, (Int32)stream.Length);10 postString = Encoding.UTF8.GetString(postBytes);11 Handle(postString);12 &#125;13 &#125;14 &#125;15 16 /// &lt;summary&gt;17 /// 处理信息并应答18 /// &lt;/summary&gt;19 private void Handle(string postStr)20 &#123;21 messageHelp help = new messageHelp();22 string responseContent = help.ReturnMessage(postStr);23 24 HttpContext.Current.Response.ContentEncoding = Encoding.UTF8;25 HttpContext.Current.Response.Write(responseContent);26 &#125; messageHelp是消息处理帮助类，这边提供下部分代码，完整的可以下载来，获取的postString是xml，格式如上，我们这边只需要转换成XmlDocument进行解析就行了： 123456789101112131415161718192021222324252627282930 1 //接受文本消息 2 public string TextHandle(XmlDocument xmldoc) 3 &#123; 4 string responseContent = &quot;&quot;; 5 XmlNode ToUserName = xmldoc.SelectSingleNode(&quot;/xml/ToUserName&quot;); 6 XmlNode FromUserName = xmldoc.SelectSingleNode(&quot;/xml/FromUserName&quot;); 7 XmlNode Content = xmldoc.SelectSingleNode(&quot;/xml/Content&quot;); 8 if (Content != null) 9 &#123;10 responseContent = string.Format(ReplyType.Message_Text, 11 FromUserName.InnerText, 12 ToUserName.InnerText, 13 DateTime.Now.Ticks, 14 &quot;欢迎使用微信公共账号，您输入的内容为：&quot; + Content.InnerText+&quot;\r\n&lt;a href=\&quot;http://www.cnblogs.com\&quot;&gt;点击进入&lt;/a&gt;&quot;);15 &#125;16 return responseContent;17 &#125;18 /// &lt;summary&gt;19 /// 普通文本消息20 /// &lt;/summary&gt;21 public static string Message_Text22 &#123;23 get &#123; return @&quot;&lt;xml&gt;24 &lt;ToUserName&gt;&lt;![CDATA[&#123;0&#125;]]&gt;&lt;/ToUserName&gt;25 &lt;FromUserName&gt;&lt;![CDATA[&#123;1&#125;]]&gt;&lt;/FromUserName&gt;26 &lt;CreateTime&gt;&#123;2&#125;&lt;/CreateTime&gt;27 &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;28 &lt;Content&gt;&lt;![CDATA[&#123;3&#125;]]&gt;&lt;/Content&gt;29 &lt;/xml&gt;&quot;; &#125;30 &#125; 上面的代码就是接受消息，并做一些处理操作，返回消息。 发送消息（图文、菜单事件响应） 这边发送消息我分为三种：普通消息、图文消息和菜单事件响应。普通消息其实上面说接受消息的时候讲到了，完整的代码下边下载来看。 我们先看下图文消息和菜单事件响应，微信公众平台开发者文档：http://mp.weixin.qq.com/wiki/index.php?title=回复图文消息#.E5.9B.9E.E5.A4.8D.E5.9B.BE.E6.96.87.E6.B6.88.E6.81.AF，xml格式为： 123456789101112131415161718192021 1 &lt;xml&gt; 2 &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; 3 &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; 4 &lt;CreateTime&gt;12345678&lt;/CreateTime&gt; 5 &lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt; 6 &lt;ArticleCount&gt;2&lt;/ArticleCount&gt; 7 &lt;Articles&gt; 8 &lt;item&gt; 9 &lt;Title&gt;&lt;![CDATA[title1]]&gt;&lt;/Title&gt; 10 &lt;Description&gt;&lt;![CDATA[description1]]&gt;&lt;/Description&gt;11 &lt;PicUrl&gt;&lt;![CDATA[picurl]]&gt;&lt;/PicUrl&gt;12 &lt;Url&gt;&lt;![CDATA[url]]&gt;&lt;/Url&gt;13 &lt;/item&gt;14 &lt;item&gt;15 &lt;Title&gt;&lt;![CDATA[title]]&gt;&lt;/Title&gt;16 &lt;Description&gt;&lt;![CDATA[description]]&gt;&lt;/Description&gt;17 &lt;PicUrl&gt;&lt;![CDATA[picurl]]&gt;&lt;/PicUrl&gt;18 &lt;Url&gt;&lt;![CDATA[url]]&gt;&lt;/Url&gt;19 &lt;/item&gt;20 &lt;/Articles&gt;21 &lt;/xml&gt; 图文消息分为两种，我们先看下效果，找的圆通速递的微信服务号做示例： 刚开始做的时候，我以为这两种应该不是用的同一个接口，但是在文档中找了半天也没有找到除这个之外的，就试了下两个图文消息，发现就是这个接口发送的，如果多个的话，item中的Description会失效，只会显示Title，大家试下就知道了，示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 1 //事件 2 public string EventHandle(XmlDocument xmldoc) 3 &#123; 4 string responseContent = &quot;&quot;; 5 XmlNode Event = xmldoc.SelectSingleNode(&quot;/xml/Event&quot;); 6 XmlNode EventKey = xmldoc.SelectSingleNode(&quot;/xml/EventKey&quot;); 7 XmlNode ToUserName = xmldoc.SelectSingleNode(&quot;/xml/ToUserName&quot;); 8 XmlNode FromUserName = xmldoc.SelectSingleNode(&quot;/xml/FromUserName&quot;); 9 if (Event!=null)10 &#123;11 //菜单单击事件12 if (Event.InnerText.Equals(&quot;CLICK&quot;))13 &#123;14 if (EventKey.InnerText.Equals(&quot;click_one&quot;))//click_one15 &#123;16 responseContent = string.Format(ReplyType.Message_Text,17 FromUserName.InnerText,18 ToUserName.InnerText, 19 DateTime.Now.Ticks, 20 &quot;你点击的是click_one&quot;);21 &#125;22 else if (EventKey.InnerText.Equals(&quot;click_two&quot;))//click_two23 &#123;24 responseContent = string.Format(ReplyType.Message_News_Main, 25 FromUserName.InnerText, 26 ToUserName.InnerText, 27 DateTime.Now.Ticks, 28 &quot;2&quot;,29 string.Format(ReplyType.Message_News_Item,&quot;我要寄件&quot;,&quot;&quot;,30 &quot;http://www.soso.com/orderPlace.jpg&quot;,31 &quot;http://www.soso.com/&quot;)+32 string.Format(ReplyType.Message_News_Item, &quot;订单管理&quot;, &quot;&quot;,33 &quot;http://www.soso.com/orderManage.jpg&quot;,34 &quot;http://www.soso.com/&quot;));35 &#125;36 else if (EventKey.InnerText.Equals(&quot;click_three&quot;))//click_three37 &#123;38 responseContent = string.Format(ReplyType.Message_News_Main,39 FromUserName.InnerText,40 ToUserName.InnerText,41 DateTime.Now.Ticks,42 &quot;1&quot;,43 string.Format(ReplyType.Message_News_Item, &quot;标题&quot;, &quot;摘要&quot;,44 &quot;http://www.soso.com/jieshao.jpg&quot;,45 &quot;http://www.soso.com/&quot;));46 &#125;47 &#125;48 &#125;49 return responseContent;50 &#125;51 /// &lt;summary&gt;52 /// 图文消息主体53 /// &lt;/summary&gt;54 public static string Message_News_Main55 &#123;56 get57 &#123;58 return @&quot;&lt;xml&gt;59 &lt;ToUserName&gt;&lt;![CDATA[&#123;0&#125;]]&gt;&lt;/ToUserName&gt;60 &lt;FromUserName&gt;&lt;![CDATA[&#123;1&#125;]]&gt;&lt;/FromUserName&gt;61 &lt;CreateTime&gt;&#123;2&#125;&lt;/CreateTime&gt;62 &lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;63 &lt;ArticleCount&gt;&#123;3&#125;&lt;/ArticleCount&gt;64 &lt;Articles&gt;65 &#123;4&#125;66 &lt;/Articles&gt;67 &lt;/xml&gt; &quot;;68 &#125;69 &#125;70 /// &lt;summary&gt;71 /// 图文消息项72 /// &lt;/summary&gt;73 public static string Message_News_Item74 &#123;75 get76 &#123;77 return @&quot;&lt;item&gt;78 &lt;Title&gt;&lt;![CDATA[&#123;0&#125;]]&gt;&lt;/Title&gt; 79 &lt;Description&gt;&lt;![CDATA[&#123;1&#125;]]&gt;&lt;/Description&gt;80 &lt;PicUrl&gt;&lt;![CDATA[&#123;2&#125;]]&gt;&lt;/PicUrl&gt;81 &lt;Url&gt;&lt;![CDATA[&#123;3&#125;]]&gt;&lt;/Url&gt;82 &lt;/item&gt;&quot;;83 &#125;84 &#125; 需要注意的是：XmlNode Event = xmldoc.SelectSingleNode(“/xml/Event”)表示获取的是事件类型，XmlNode EventKey = xmldoc.SelectSingleNode(“/xml/EventKey”)表示事件标示，就是我们创建菜单添加click的key，通过key我们就可以判断出是点的哪个菜单。 还有一点是回复超链接，有时候在服务号会发送一些链接，我们打开直接就会链接到相关网址，只需要在回复内容中添加：点击进入，就可以了。 示例Demo下载 下载地址：http://pan.baidu.com/s/1eSAxJns 后记 关于微信公众平台当然还有许多其他的东西，本篇只是一些经验之谈，希望可以起到抛砖引玉的作用。有时候我们发现一些新鲜事物，觉得很难，就远远的看着，如果你用心的去感受它，其实也就这么回事。]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#微信接口之推送模板消息功能示例]]></title>
    <url>%2Fpost%2F647eef3c.html</url>
    <content type="text"><![CDATA[本文实例讲述了C#微信接口之推送模板消息功能。分享给大家供大家参考，具体如下： ?1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public string SendTempletMessge(){ string strReturn = string.Empty; try { #region 获取access_token string apiurl = “https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=你的appid&amp;secret=你的secret”; WebRequest request = WebRequest.Create(@apiurl); request.Method = “POST”; WebResponse response = request.GetResponse(); Stream stream = response.GetResponseStream(); Encoding encode = Encoding.UTF8; StreamReader reader = new StreamReader(stream, encode); string detail = reader.ReadToEnd(); var jd = JsonConvert.DeserializeObject(detail); string token = (String)jd.access_token; #endregion #region 组装信息推送，并返回结果（其它模版消息于此类似） string url = “https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=“ + token; string temp = “{\”touser\”: \”” + UserInfo.OpenID + “\”,” + “\”template_id\”: \”f3kRRjJeyLDf4tndtg-OJeRvgEdgjjDxCy4T9kuwM70\”, “ + “\”topcolor\”: \”#FF0000\”, “ + “\”data\”: “ + “{\”first\”: {\”value\”: \”您好，您有一条回款通知信息\”},” + “\”keyword1\”: { \”value\”: \”单位名称\”},” + “\”keyword2\”: { \”value\”: \”日期\”},” + “\”keyword3\”: { \”value\”: \”金额\”},” + “\”keyword4\”: { \”value\”: \”业务员\”},” + “\”remark\”: {\”value\”: \”\” }}}”; #endregion //核心代码 GetResponseData(temp, @url); strReturn = “推送成功”; } catch (Exception ex) { strReturn = ex.Message; } return strReturn;}/// /// 返回JSon数据/// /// 要处理的JSON数据/// 要提交的URL/// 返回的JSON处理字符串public string GetResponseData(string JSONData, string Url){ byte[] bytes = Encoding.UTF8.GetBytes(JSONData); HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url); request.Method = “POST”; request.ContentLength = bytes.Length; request.ContentType = “json”; Stream reqstream = request.GetRequestStream(); reqstream.Write(bytes, 0, bytes.Length); //声明一个HttpWebRequest请求 request.Timeout = 90000; //设置连接超时时间 request.Headers.Set(“Pragma”, “no-cache”); HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream streamReceive = response.GetResponseStream(); Encoding encoding = Encoding.UTF8; StreamReader streamReader = new StreamReader(streamReceive, encoding); string strResult = streamReader.ReadToEnd(); streamReceive.Dispose(); streamReader.Dispose(); return strResult;}涉及到的实体：?1234public class WXApi{ public string access_token { set; get; }}更多关于C#相关内容感兴趣的读者可查看本站专题：《C#常见控件用法教程》、《WinForm控件用法总结》、《C#数据结构与算法教程》、《C#面向对象程序设计入门教程》及《C#程序设计之线程使用技巧总结》希望本文所述对大家C#程序设计有所帮助。]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务 面试]]></title>
    <url>%2Fpost%2Fb80346fe.html</url>
    <content type="text"><![CDATA[1、什么是微服务？ 就目前而言，对于微服务业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分一组小的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调、互相配合，为用户提供最总价值。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）,每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产环境、类生产环境等。另外，应避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 2、微服务之间是如何独立通讯的？ 3、SpringCloud和Dubbo有哪些区别？ DubboSpringCloud服务注册中心ZookeeperEureka服务调用方式RPCREST API服务监控Dubbo-monitorSpring BootAdmin断路器不完善Spring Cloud Netflix Hystrix服务网关无Spring Cloud Netflix Zuul分布式配置无Spring Cloud Config服务跟踪无Spring Cloud Sleuth消息总线无Spring Cloud Bus数据流无Spring Cloud Stream批量任务无 Spring Cloud Task 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。 总体来说，两者各有优势。虽说后者服务调用的功能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的依赖，这在强调快速演化的微服务环境下，显得更加合适。 品牌机与组装机的区别：很明显SpringCloud比dubbo的功能更强大，覆盖面更广，而且能够与SpringFramework、SpringBoot、SpringData、SpringBatch等其他Spring项目完美融合，这些对于微服务至关重要。使用Dubbo构建的微服务架构就像组装电脑、各环节我们选择自由度高，但是最总可能会因为内存质量而影响整体，但对于高手这也就不是问题。而SpringCloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性。 在面临微服务基础框架选型时Dubbo与SpringCloud只能二选一。 4、SpringBoot和SpringCloud,请你谈谈对他们的理解？ 1）、SpringBoot专注于快速方便的开发单个个体微服务。 2）、SpringCloud是关注全局的微服务协调、整理、治理的框架，它将SpringBoot开发的单体整合并管理起来。 3）、SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。 5、什么是服务熔断？什么是服务降级？ 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand 服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。 6、微服务的优缺点是什么？说下你在项目开发中碰到的问题优点：1）、每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。 2）、开发简单，开发效率提高，一个服务可能就是专一的只干一件事。 3）、微服务能够被小团队开发，这个团队可以是2到5个开发人员组成。 4）、微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。 5）、微服务能使用不同的语言开发。 6）、易于第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成集成工具，如Jenkins、Hudson等。 7）、微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作体现价值。 8）、微服务允许你融合最新技术。 9）、微服务知识业务逻辑代码，不会和HTML和CSS其他界面组件混合。 10）、每个微服务都有自己的存储能力，可以有自己的数据库，也可以由统一的数据库。缺点：1）、开发人员要处理分布式系统的复杂性。 2）、多服务运维难度，随着服务的增加，运维的压力也在增加。 3）、系统部署依赖。 4）、服务间通讯成本。 5）、数据一致性。 6）、系统集成测试。 7）、性能监控….. 7、你所知道的微服务技术栈有哪些?请举例一二微服务的技术栈（各项功能的实现所使用的技术）具体如下： 微服务条目 落地的技术 备注服务开发SpringBoot、Spring、SpringMVC 服务配置管理Netfilx公司的Archaius、阿里的Diamond等 服务注册与发现Eureka、Consul、Zookeeper 服务调用RPC、Rest、gRPC 服务熔断器Hystrix、Envoy等 负载均衡Nginx、Ribbon 服务接口调用（客户端调用服务的简化工具）Feign等 消息队列Kafka、RabbitMQ、ActiveMQ等 服务配置中心配置管理SpringCloudConfig、Chef等 服务路由（API网关）Zuul等 服务监控Zabbix、Naggios、Metrics、Spectator等 全链路追踪Zipkin、Brave、Dapper等 服务部署Docker、OpenStack、Kubernetes等 数据流操作开发包SpringCloud Stream 事件消息总线Spring Cloud Bus 8、Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？ 1）、Zookeeper保证了CP（C：一致性，P：分区容错性），Eureka保证了AP（A：高可用） （1）、当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。 （2）、Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现是发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况： ①、Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。 ②、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用） ③、当网络稳定时，当前实例新的注册信息会被同步到其他节点。 因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个微服务瘫痪。]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC工作原理]]></title>
    <url>%2Fpost%2Fd99054cc.html</url>
    <content type="text"><![CDATA[SpringMVC的工作原理图： SpringMVC流程1、 用户发送请求至前端控制器DispatcherServlet。 2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet调用HandlerAdapter处理器适配器。 5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6、 Controller执行完成返回ModelAndView。 7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9、 ViewReslover解析后返回具体View。 10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11、 DispatcherServlet响应用户。 组件说明：以下组件通常使用框架提供实现： DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用：根据请求的url查找HandlerHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 3、处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行HandlerHandler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 5、视图解析器View resolver(不需要工程师开发),由框架提供作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 6、视图View(需要工程师开发jsp…)View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…） 核心架构的具体流程步骤如下：1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；6、View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。 下边两个组件通常情况下需要开发： Handler：处理器，即后端控制器用controller表示。 View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。 在将SpringMVC之前我们先来看一下什么是MVC模式 MVC：MVC是一种设计模式 MVC的原理图： 分析： M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） V-View 视图（做界面的展示 jsp，html……） C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面） springMVC是什么： springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上sring的整合，但是这里有一个疑惑就是，springMVC和spring是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，springMVC是spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC就是spring的一个子模块，所以根本不需要同spring进行整合。 SpringMVC的原理图： 看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解） 第一步:用户发起请求到前端控制器（DispatcherServlet） 第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找 第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain） 第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler） 第五步：处理器适配器去执行Handler 第六步：Handler执行完给处理器适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView 第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析 第九步：视图解析器像前端控制器返回View 第十步：前端控制器对视图进行渲染 第十一步：前端控制器向用户响应结果 看到这些步骤我相信大家很感觉非常的乱，这是正常的，但是这里主要是要大家理解springMVC中的几个组件： 前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。 处理器映射器（HandlerMapping）：根据URL去查找处理器 处理器（Handler）：（需要程序员去写代码处理逻辑的） 处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用） 视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7系统不能用telnet命令的两种解决方法]]></title>
    <url>%2Fpost%2F6fd35722.html</url>
    <content type="text"><![CDATA[电脑专业人员对telnet命令都不陌生了，Telnet当成一种通信协议，在日常工作中，经常面对网络问题的人都会用到telnet命令，因为简单有效，可以帮助更快的找出问题。要是在使用过程中碰到win7纯净版系统不能用telnet命令的问题怎么办呢？不要担心，为此小编给大家推荐win7系统不能用telnet命令的两种解决方法。 解决方法1: 1、 首先，我们打开控制面板； 2、找到：程序-卸载程序，并点击进入； 3、 在：卸载或更改程序对话框里，左边，找到并点击：打开或关闭windows功能； 4、在：打开或关闭windows功能对话框里，下拉，找到并打勾：telnet客户端，并按确定； 5、 稍等片刻……就会安装完成，即返回上一层对话框，你全部都点关闭就可以了。 解决方法2: 1、 用telnet命令测试端口方法很简单。大家都可以学习一下！首先，打开：命令提示符，或者：点开始，然后输入：CMD再回车； 2、就可以正常测试命令了； 3、 我们先来测试一下，telnet 192.168.1.191，在不加端口的情况下，telnet 的默认端口是23，返回信息是：无法打开到主机的连接，而不是说：telnet 不是内部或外部命令，也不是可运行的程序或批处理文件。即表示命令是可以使用的了； 4、我们再来测试命令：telnet 192.168.1.191 80，这次我们加了端口80，光标一闪，就到了这个界面，即表示连接192.168.1.191的80端口是正常的； 5、 更多的telnet命令，我们可以用“帮助”来看看，输入 ：telnet /?。 以上教程帮助大家解决win7系统不能用telnet命令的问题，大家可以选择一款合适的方法进行处理，设置之后telnet命令就恢复正常了。]]></content>
      <tags>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO框架Netty教程（一） – Hello Netty]]></title>
    <url>%2Fpost%2Fb77d46d8.html</url>
    <content type="text"><![CDATA[先啰嗦两句，如果你还不知道Netty是做什么的能做什么。那可以先简单的搜索了解一下。我只能说Netty是一个NIO的框架，可以用于开发分布式的Java程序。具体能做什么，各位可以尽量发挥想象。技术，是服务于人而不是局限住人的。 如果你已经万事具备，那么我们先从一段代码开始。程序员们习惯的上手第一步，自然是”Hello world”，不过Netty官网的例子却偏偏抛弃了”Hello world”。那我们就自己写一个最简单的”Hello world”的例子，作为上手。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1 /** 2 * Netty 服务端代码 3 * 4 * @author lihzh 5 * @alia OneCoder 6 * @blog http://www.coderli.com 7 */ 8 public class HelloServer &#123; 9 10 public static void main(String args[]) &#123; 11 // Server服务启动器 12 ServerBootstrap bootstrap = new ServerBootstrap( 13 new NioServerSocketChannelFactory( 14 Executors.newCachedThreadPool(), 15 Executors.newCachedThreadPool())); 16 // 设置一个处理客户端消息和各种消息事件的类(Handler) 17 bootstrap 18 .setPipelineFactory(new ChannelPipelineFactory() &#123; 19 @Override 20 public ChannelPipeline getPipeline() 21 throws Exception &#123; 22 return Channels 23 .pipeline(new HelloServerHandler()); 24 &#125; 25 &#125;); 26 // 开放8000端口供客户端访问。 27 bootstrap.bind(new InetSocketAddress(8000)); 28 &#125; 29 30 private static class HelloServerHandler extends 31 SimpleChannelHandler &#123; 32 33 /** 34 * 当有客户端绑定到服务端的时候触发，打印&quot;Hello world, I&apos;m server.&quot; 35 * 36 * @alia OneCoder 37 * @author lihzh 38 */ 39 @Override 40 public void channelConnected( 41 ChannelHandlerContext ctx, 42 ChannelStateEvent e) &#123; 43 System.out.println(&quot;Hello world, I&apos;m server.&quot;); 44 &#125; 45 &#125; 46 &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Netty 客户端代码 * * @author lihzh * @alia OneCoder * @blog http://www.coderli.com */ public class HelloClient &#123; public static void main(String args[]) &#123; // Client服务启动器 ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory( Executors.newCachedThreadPool(), Executors.newCachedThreadPool())); // 设置一个处理服务端消息和各种消息事件的类(Handler) bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123; @Override public ChannelPipeline getPipeline() throws Exception &#123; return Channels.pipeline(new HelloClientHandler()); &#125; &#125;); // 连接到本地的8000端口的服务端 bootstrap.connect(new InetSocketAddress( &quot;127.0.0.1&quot;, 8000)); &#125; private static class HelloClientHandler extends SimpleChannelHandler &#123; /** * 当绑定到服务端的时候触发，打印&quot;Hello world, I&apos;m client.&quot; * * @alia OneCoder * @author lihzh */ @Override public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) &#123; System.out.println(&quot;Hello world, I&apos;m client.&quot;); &#125; &#125; &#125; 既然是分布式的，自然要分多个服务。Netty中，需要区分Server和Client服务。所有的Client都是绑定在Server上的，他们之间是不能通过Netty直接通信的。（自己采用的其他手段，不包括在内。）。白话一下这个通信过程，Server端开放端口，供Client连接，Client发起请求，连接到Server指定的端口，完成绑定。随后便可自由通信。其实就是普通Socket连接通信的过程。Netty框架是基于事件机制的，简单说，就是发生什么事，就找相关处理方法。就跟着火了找119，抢劫了找110一个道理。所以，这里，我们处理的是当客户端和服务端完成连接以后的这个事件。什么时候完成的连接，Netty知道，他告诉我了，我就负责处理。这就是框架的作用。Netty，提供的事件还有很多，以后会慢慢的接触和介绍。你应该已经可以上手了：）]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于JT/T808协议的车辆监控平台架构方案]]></title>
    <url>%2Fpost%2F45e44734.html</url>
    <content type="text"><![CDATA[技术支持QQ：78772895 1、接入网关应用采用mina/netty+spring架构，独立于其他应用，主要负责维护接入终端的tcp链接、上行以及下行消息的解码、编码、流量控制，黑白名单等安全控制，网关同时支持交通部JT/T808-2011、JT/T808-2013两个版本全部的808协议，网关应用提供二次开发接口，支持协议扩展而不需要改动任何原有代码。接入网关采用json消息通过MQ消息队列与业务平台进行交互，支持ActiveMQ和RabbitMQ，能够无缝接入各种异构系统。 本网关应用已历经并通过多次交通部部标的检测，性能稳定，适用于物联网（车联网）领域应用，特别是基于交通部808协议或者其扩展协议的智能终端监控平台，如车辆GPS定位监控平台。经测试在普通pc机上，单个网关应用至少可支持同时1w以上终端同时在线，具备至少600wGPS数据/小时的数据处理能力（见附件性能测试报告）。 2、消息处理应用，采用spring+mysql+redis+mongoDB框架，是基于事件驱动的责任链设计模式处理终端上行消息、批量存储消息、gps纠偏、发布终端重要消息（告警，上下线等）等平台业务处理，提供消息处理二次开发接口而不需要改动任何原有代码，实现个性格业务处理能力。 3、平台接口层是基于spring-boot的微服务架构，底层封装了基于元数据的几大高度抽象的restful风格接口（包括CRUD接口、复杂查询接口、下发消息接口等个性化定制接口），业务系统无需再单独开发数据库相关操作的代码（增加新的数据库表只需要建立entity映射，即可实现增上改查等功能），只需关注业务逻辑开发即可。同时模块也提供提供二次开发接口，而不需要改动任何原有代码，实现个性格业务处理以及自定义接口能力。 4、展现层web端对JQuery EasyUI进行了二次封装，提供部分js常用组件，对于普通的CRUD操作只需按照模板开发相关的界面即可完美展现,web端同时集成了WDR对终端上下线、告警等重要信息实时推送提醒消息。 5、框架集成了redis缓存，通过简单的注解就能使用缓存； 6、在业务功能目前实现了： a、支持JT/T808协议的全部指令，如拍照、文本下发、监听、点名等； b、平台告警设置：原地设防、围栏告警（圆形、矩形、多边形）、超速告警； c、车辆监控：区域查车、车辆上下线提示、告警实时提示、车辆实时跟踪、历史轨迹、油耗、里程等； d、车辆管理：车辆信息维护、多媒体信息、上行消息、下行消息、告警查询等； e、账号维护：企业注册、企业信息维护、修改密码等； f、各种统计报表。 7、接口层同时也提供了开放平台，开放平台遵循标准oauth2.0，提供几大基于元数据的高度抽象的restful风格的增删改查数据接口以及部分个性化定制的业务接口；开放平台支持接口调用频率控制（基于令牌桶算法），支持ip黑白名单、接口调用权限等功能。 网关程序下载地址：http://download.csdn.net/detail/gaoshbo/9340739 平台体验网址： http://elink.legaoyi.com，登陆用户：test007，密码：123456 分布式高可用高并发平台见： http://670624517.iteye.com/blog/2389492]]></content>
      <tags>
        <tag>车联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式高并发物联网（车联网-JT808协议）平台架构方案]]></title>
    <url>%2Fpost%2F6d4ef9e7.html</url>
    <content type="text"><![CDATA[技术支持QQ：78772895 1、车载终端网关采用mina/netty+spring架构，独立于其他应用，主要负责维护接入终端的tcp链接、上行以及下行消息的解码、编码、流量控制，黑白名单等安全控制，网关同时支持交通部JT/T808-2011、JT/T808-2013两个版本全部的808协议，网关应用提供二次开发接口，支持以插件形式协议扩展而不需要改动任何原有代码。接入网关采用json消息通过MQ消息队列与业务平台进行交互，支持ActiveMQ和RabbitMQ，能够无缝接入各种异构系统。 本网关应用已历经并通过多次交通部部标的检测，性能稳定，适用于物联网（车联网）领域应用，特别是基于交通部808协议或者其扩展协议的智能终端监控平台，如车辆GPS定位监控平台。经测试在普通pc机上，单个网关应用至少可支持同时1w以上终端同时在线，具备至少600wGPS数据/小时的数据处理能力（见附件性能测试报告）。 本网关可水平扩展成支持高可用高并发的分布式架构 2、上行消息处理服务，采用spring+mysql+redis+mongoDB框架，是基于事件驱动的责任链设计模式处理终端上行消息、批量存储消息、发布终端重要消息（告警，上下线等）等平台业务处理，提供以插件形式消息处理二次开发接口而不需要改动任何原有代码，实现个性格业务处理能力。本服务可水平扩展成支持高可用高并发的分布式架构 3、平台服务层是基于spring-boot的微服务架构，同时集成了服务注册中心，接口网关，支持高并发高可用的分布式架构；底层封装了基于元数据的几大高度抽象的restful风格接口（包括CRUD接口、复杂查询接口、下发消息接口等个性化定制接口），业务系统无需再单独开发数据库相关操作的代码（增加新的数据库表只需要建立entity映射，即可实现增上改查等功能），只需关注业务逻辑开发即可。同时模块也提供提供二次开发接口，而不需要改动任何原有代码，实现个性格业务处理以及自定义接口能力。 4、展现层web端对JQuery EasyUI进行了二次封装，提供部分js常用组件，对于普通的CRUD操作只需按照模板开发相关的界面即可完美展现,web端同时集成了WDR对终端上下线、告警等重要信息实时推送提醒消息。 5、框架集成了redis缓存，通过简单的注解就能使用缓存； 6、在业务功能目前实现了： a、支持JT/T808协议的全部指令，如拍照、文本下发、监听、点名等； b、平台告警设置：原地设防、围栏告警（圆形、矩形、多边形）、超速告警； c、车辆监控：区域查车、车辆上下线提示、告警实时提示、车辆实时跟踪、历史轨迹、油耗、里程等； d、车辆管理：车辆信息维护、多媒体信息、上行消息、下行消息、告警查询等； e、账号维护：企业注册、企业信息维护、修改密码等； f、各种统计报表。 7、开放平台遵循标准oauth2.0，提供几大基于元数据的高度抽象的restful风格的增删改查数据接口以及部分个性化定制的业务接口；开放平台支持接口调用频率控制（基于令牌桶算法），支持ip黑白名单、接口调用权限等功能。 试用版网关程序下载地址： http://download.csdn.net/detail/gaoshbo/9340739 **，需要正版可联系QQ:78772895** 平台体验网址： http://elink.legaoyi.com，登陆用户：test007，密码：123456 ** **]]></content>
      <tags>
        <tag>车联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty和Tomcat的区别、性能对比]]></title>
    <url>%2Fpost%2Ff29275a5.html</url>
    <content type="text"><![CDATA[一、Netty和Tomcat有什么区别？ Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。 有人说netty的性能就一定比tomcat性能高，其实不然，tomcat从6.x开始就支持了nio模式，并且后续还有arp模式——一种通过jni调用apache网络库的模式，相比于旧的bio模式，并发性能得到了很大提高，特别是arp模式，而netty是否比tomcat性能更高，则要取决于netty程序作者的技术实力了。为什么Netty受欢迎？ netty是一款收到大公司青睐的框架，在我看来，netty能够受到青睐的原因有三：并发高传输快封装好Netty为什么并发高 Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。 NIO 2.0里终于有AIO了，Linux上用AIO，Windows上用IOCP，都支持了概念上的最后一种IOasynchronous I/O 就IO而言：概念上有5中模型：blocking I/O，nonblocking I/O，I/O multiplexing (select and poll)，signal driven I/O (SIGIO)，asynchronous I/O (the POSIX aio_functions)。 然后呢 不同的操作系统对上述模型支持不同: unix支持io多路复用，不同系统叫法不同 :freebsd里面叫 kqueue；linux 是epoll。而windows: 2000的时候就诞生了IOCP支持最后一种异步I/O java是一种跨平台语言，为了支持异步IO,诞生了nio,Java1.4引入的NIO 1.0是基于I/O复用的。在各个平台上会选择不同的复用方式。Linux用的epoll，BSD上用kqueue，Windows上应该是重叠I/O（肯定不是IOCP） 但是nio直接使用比较难用，所以有了mina，netty这些针对网络io部分（tcp/udp-传输层）的封装（nio也有非网络io部分），为了使nio更易用。http是应用层的协议。servlet3.0则是另外一种东西，不是对协议的封装，javaee6众多规范中的一个，但凡javaee6的实现（或者像tomcat这种web容器部分的实现），都会支持servlet3.0，servlet理论上可以支持多种应用层协议（不单单只是http），而servlet3.0以后提供的异步特性与javase提供的nio或aio无直接关系，就是使用bio一样可以实现servlet3.0中提供的异步特性。异步只是一种概念，异步与否要看，上层使用的异步，而支持的下层完全可能是阻塞的。 tomcat就是针对http层的，所以我建议http还是选择tomcat(或者其他成熟的http-server)，并不是说netty不好，而是你的选择问题。 netty是一个网络组件，tcp,udp,http都可以弄，但是官方文档都是些hello wolrd级别的。如果你非常了解http结构，完全可以基于netty搞出一个比tomcat牛的http server。如果做tcp开发，netty不二之选！ 现在高并发分布式网站架构一般采用nginx（前端负载均衡）+ Netty/Tomcat（HTTP） Netty是基于Java NIO开发的，而Tomcat是Apache下的针对HTTP的服务器项目，前者更像一个中间件框架，后者更像一个工具]]></content>
      <tags>
        <tag>tomcat</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(十一) 整合spring cloud云架构 - SSO单点登录之OAuth2.0登录流程(2)]]></title>
    <url>%2Fpost%2F65b9e284.html</url>
    <content type="text"><![CDATA[上一篇是站在巨人的肩膀上去研究OAuth2.0，也是为了快速帮助大家认识OAuth2.0，闲话少说，我根据框架中OAuth2.0的使用总结，画了一个简单的流程图（根据用户名+密码实现OAuth2.0的登录认证）： 上面的图很清楚的描述了当前登录login的流程，现在我们针对于login做成相关的微服务，解析如下： 请求方式：POST服务URL： http://localhost:8080/user/login参数类型:application/jsonHeaders: Content-Type: application/json Authorization: Basic QXkjkdkYkhfeyKOKKHUM67ejfjeSfnrRdk5nPT0=Body:{ “userName”:”admin”, —也可以是手机号码等 “password”: “e10adc3949ba59abbe56e057f20f883e”}返回值类型: application/json返回的结果集： { “code”: “200”, “message”: “Success”, “version”: “v1.0”, “data”: { “userInfo”: { “userId”: “00001”, “pwd”: “e10adc3949ba59abbe56e057f20f883e”, “userName”: “admin”, “mobile”: “15875500000”, “telephone”: “”, “wechat”: “”, “email”: “xxx@qq.com“, “status”: “1”, “createTime”: “2017-06-26” }, “roleIds”: “100”, “tokenInfo”: { “accessToken”:”4de55a69-e372-4766-acd3-1c419d6f2fda”, “tokenType”: “bearer”, “webTokent”:”uHSLjfJoQwU4t4PAqCzH1SN0fp7PUWKluPNS+x1dZ8R9Gx+NJkBI7w==”, “refreshToken”:”d3d71594-5c3f-4a68-a7e5-b8d21c4fa73b”, “expiresIn”: 34644, “scope”: “read write” } }}备注： 可以使用Postman工具进行测试框架设计思想： 提供独立的commonservice-sso的微服务、提供component-sso的依赖组件、提供针对于用户登录的微服务客户端user-service微服务接口。整个执行的流程如下：user-service —&gt; commonservice-sso —&gt; component-sso这里还没有讲解到服务网关，后面会涉及到服务网关和sso单点登录之间如何实现服务认证和鉴权。从现在开始，我这边会将近期研发的spring cloud微服务云架构的搭建过程和精髓记录下来，帮助更多有兴趣研发spring cloud框架的朋友，大家来一起探讨spring cloud架构的搭建过程及如何运用于企业项目。]]></content>
      <tags>
        <tag>spring cloud</tag>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合spring cloud云架构 - SSO单点登录之OAuth2.0登录认证(1)]]></title>
    <url>%2Fpost%2F8f5cc6b5.html</url>
    <content type="text"><![CDATA[之前写了很多关于spring cloud的文章，今天我们对OAuth2.0的整合方式做一下笔记，首先我从网上找了一些关于OAuth2.0的一些基础知识点，帮助大家回顾一下知识点： 一、oauth中的角色client：调用资源服务器API的应用 Oauth 2.0 Provider：包括Authorization Server和Resource Server （1）Authorization Server：认证服务器，进行认证和授权 （2）Resource Server：资源服务器，保护受保护的资源user：资源的拥有者 二、下面详细介绍一下Oauth 2.0 ProviderAuthorization Server:（1）/oauth/authorize （2）TokenEndpoint：获取token的服务，Default URL: /oauth/token Resource Server:OAuth2AuthenticationProcessingFilter：给带有访问令牌的请求加载认证 三、下面再来详细介绍一下Authorization Server:一般情况下，创建两个配置类，一个继承AuthorizationServerConfigurerAdapter，一个继承WebSecurityConfigurerAdapter，再去复写里面的方法。 主要出现的两种注解：1、@EnableAuthorizationServer：声明一个认证服务器，当用此注解后，应用启动后将自动生成几个Endpoint：（注：其实实现一个认证服务器就是这么简单，加一个注解就搞定，当然真正用到生产环境还是要进行一些配置和复写工作的。） /oauth/authorize：验证 /oauth/token：获取token /oauth/confirm_access：用户授权 /oauth/error：认证失败 /oauth/check_token：资源服务器用来校验token /oauth/token_key：如果jwt模式则可以用此来从认证服务器获取公钥 以上这些endpoint都在源码里的endpoint包里面。 2、@Beans：需要实现AuthorizationServerConfigurer AuthorizationServerConfigurer包含三种配置： ClientDetailsServiceConfigurer：client客户端的信息配置，client信息包括：clientId、secret、scope、authorizedGrantTypes、authorities （1）scope：表示权限范围，可选项，用户授权页面时进行选择 （2）authorizedGrantTypes：有四种授权方式 Authorization Code：用验证获取code，再用code去获取token（用的最多的方式，也是最安全的方式） Implicit: 隐式授权模式 Client Credentials (用來取得 App Access Token) Resource Owner Password Credentials （3）authorities：授予client的权限 这里的具体实现有多种，in-memory、JdbcClientDetailsService、jwt等。 AuthorizationServerSecurityConfigurer：声明安全约束，哪些允许访问，哪些不允许访问 AuthorizationServerEndpointsConfigurer：声明授权和token的端点以及token的服务的一些配置信息，比如采用什么存储方式、token的有效期等 client的信息的读取：在ClientDetailsServiceConfigurer类里面进行配置，可以有in-memory、jdbc等多种读取方式。 jdbc需要调用JdbcClientDetailsService类，此类需要传入相应的DataSource. 下面再介绍一下如何管理token:[AuthorizationServerTokenServices](http://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/token/AuthorizationServerTokenServices.html &quot;AuthorizationServerTokenServices&quot;)接口:声明必要的关于token的操作 （1）当token创建后，保存起来，以便之后的接受访问令牌的资源可以引用它。 （2）访问令牌用来加载认证 接口的实现也有多种，[DefaultTokenServices](http://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/token/DefaultTokenServices.html &quot;DefaultTokenServices&quot;)是其默认实现，他使用了默认的InMemoryTokenStore，不会持久化token； token存储方式共有三种分别是：（1）InMemoryTokenStore：存放内存中，不会持久化 （2）JdbcTokenStore：存放数据库中 （3）Jwt: json web token 授权类型：可以通过AuthorizationServerEndpointsConfigurer来进行配置，默认情况下，支持除了密码外的所有授权类型。相关授权类型的一些类： （1）authenticationManager：直接注入一个AuthenticationManager，自动开启密码授权类型 （2）userDetailsService：如果注入UserDetailsService，那么将会启动刷新token授权类型，会判断用户是否还是存活的 （3）authorizationCodeServices：AuthorizationCodeServices的实例，auth code 授权类型的服务 （4）implicitGrantService：imlpicit grant （5）tokenGranter： endpoint的URL的配置：（1）AuthorizationServerEndpointsConfigurer的pathMapping()方法，有两个参数，第一个是默认的URL路径，第二个是自定义的路径 （2）WebSecurityConfigurer的实例，可以配置哪些路径不需要保护，哪些需要保护。默认全都保护。 自定义UI:（1）有时候，我们可能需要自定义的登录页面和认证页面。登陆页面的话，只需要创建一个login为前缀名的网页即可，在代码里，设置为允许访问，这样，系统会自动执行你的登陆页。此登陆页的action要注意一下，必须是跳转到认证的地址。 （2）另外一个是授权页，让你勾选选项的页面。此页面可以参考源码里的实现，自己生成一个controller的类，再创建一个对应的web页面即可实现自定义的功能。 下面梳理一下授权获取token流程：（1）端口号换成你自己的认证服务器的端口号，client_id也换成你自己的，response_type类型为code。 localhost:8080/uaa/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com（2）这时候你将获得一个code值：http://www.baidu.com/?code=G0C20Z （3）使用此code值来获取最终的token： curl -X POST -H “Cant-Type: application/x-www-form-urlencoded” -d ‘grant_type=authorization_code&amp;code=G0C20Z&amp;redirect_uri=http://www.baidu.com‘ “http://client:secret@localhost:8080/uaa/oauth/token“ 返回值： {“access_token”:”b251b453-cc08-4520-9dd0-9aedf58e6ca3”,”token_type”:”bearer”,”expires_in”:2591324,”scope”:”app”} （4）用此token值来调用资源服务器内容（如果资源服务器和认证服务器在同一个应用中，那么资源服务器会自己解析token值，如果不在，那么你要自己去做处理） curl -H “Authorization: Bearer b251b453-cc08-4520-9dd0-9aedf58e6ca3” “localhost:8081/service2（此处换上你自己的url）” 四、Resource Server：保护资源，需要令牌才能访问在配置类上加上注解@EnableResourceServer即启动。使用ResourceServerConfigurer进行配置： （1）tokenServices：ResourceServerTokenServices的实例，声明了token的服务 （2）resourceId：资源Id，由auth Server验证。 （3）其它一些扩展点，比如可以从请求中提取token的tokenExtractor （4）一些自定义的资源保护配置，通过HttpSecurity来设置 使用token的方式也有两种： （1）Bearer Token（https传输方式保证传输过程的安全）:主流 （2）Mac（http+sign） 如何访问资源服务器中的API？ 如果资源服务器和授权服务器在同一个应用程序中，并且您使用DefaultTokenServices，那么您不必太考虑这一点，因为它实现所有必要的接口，因此它是自动一致的。如果您的资源服务器是一个单独的应用程序，那么您必须确保您匹配授权服务器的功能，并提供知道如何正确解码令牌的ResourceServerTokenServices。与授权服务器一样，您可以经常使用DefaultTokenServices，并且选项大多通过TokenStore（后端存储或本地编码）表示。 （1）在校验request中的token时，使用RemoteTokenServices去调用AuthServer中的/auth/check_token。 （2）共享数据库，使用Jdbc存储和校验token，避免再去访问AuthServer。 （3）使用JWT签名的方式，资源服务器自己直接进行校验，不借助任何中间媒介。 五、oauth client在客户端获取到token之后，想去调用下游服务API时，为了能将token进行传递，可以使用RestTemplate.然后使用restTemplate进行调用Api。 注： scopes和authorities的区别： scopes是client权限，至少授予一个scope的权限，否则报错。 authorities是用户权限。 以上是我从网上找到的一篇写的不错的博客，希望可以帮助大家快速了解OAuth2.0,下一篇文章我们正式介绍OAuth2.0在当前框架中的使用。 从现在开始，我这边会将近期研发的spring cloud微服务云架构的搭建过程和精髓记录下来，帮助更多有兴趣研发spring cloud框架的朋友，大家来一起探讨spring cloud架构的搭建过程及如何运用于企业项目。]]></content>
      <tags>
        <tag>spring cloud</tag>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Could not load file or assembly 'System.Data.SQLite' or one of its dependencies. An attempt was made to load a program]]></title>
    <url>%2Fpost%2F350f2fa8.html</url>
    <content type="text"><![CDATA[今天同事在一个服务器（winserver 2008 x64)上新建了一个IIS（7） 网站，但是报了如下错误： **Could not load file or assembly &apos;System.Data.SQLite&apos; or one of its dependencies. An attempt was made to load a program with an incorrect format. ** 如下图: ![](http://pangguoming.com/blog/images/25688db3-c583-403b-9eed-ea9346c36f55.jpg) 刚开始以为是权限问题，设置了所有权限还是报错； 然后又尝试了应用程序池.NET版本等其他方式，还是没找到原因； 最后在网上搜索到了解决办法，原来应用程序池的高级选项里面有关于兼容WIN32程序的选项； System.Data.SQLite是分了操作系统版本的，有X86，X64之分；因此应用程序池应该选择兼容WIN32; ![](http://pangguoming.com/blog/images/769c1de8-c46c-4496-96c3-8df7391dc6fd.jpg)]]></content>
      <tags>
        <tag>iis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台APP----对Cordova,APPCan,DCloud,APICloud四大平台的分析]]></title>
    <url>%2Fpost%2F8dc5f965.html</url>
    <content type="text"><![CDATA[前言：移动开发是未来一个很重要的IT领域，而跨平台开发将是这一领域最重要的事情。 —-谷震平 一 兵器谱在国外，最大的是Cordova（PhoneGap，2011年广泛流行），在2012年12月开源。在国内，按时间顺序，有： 2012年，AppCan 2013年，DCloud 2014年9月，APICloud#### 二 Cordova Cordova是Apache软件基金会的一个产品。其前身是PhoneGap，由Nitobi开发，2011年10月，Adobe收够了Nitobi，并且PhoneGap项目也被贡献给Apache软件基金会。Apache在2012年12月，发布了Cordova，截止到2015年12月，最新版面是3.0。 该框架的目标用户群体是原生开发者，其设计初衷是希望用户群体能够通过跨平台开发的方法降低原生开发的成本。为此，开发人员需要安装原生开发环境，配置工程，使用HTML5、CSS3、JS和原生SDK生成应用。 Cordova的优势很明显，可以使用的框架、原生接口、支持平台都很多。但是，外国人写的东西，公司使用后，出现的技术问题难以解决。同时，其在使用jQuery Mobile、Sencha Touch等前端框架的时候，有特效启动慢、页面切换慢、数据请求慢的特点。## 三 APPCan AppCan成立于2010年，2011年推出产品并测试，2012年正式推出品牌，2013年商业模式成型，2014年开发者注册约70w。AppCan不是开源平台，同时，企业版和部分插件是收费的。换句话说，AppCan只是一个卖软件的商业公司。我们认为：这会对其市场的占有率有着直接影响，闭源而没有垄断，所以前景不会太好。## 四 DCloud DCloud大部分产品开源，W3C会员单位，HTML5中国产业联盟的发起公司之一，在HTML5这个行业有一定的江湖地位。旗下四款产品：HBuilder、5+ Runtime、MUI、流应用都是弥补并扩展HTML5特性的产品。该公司的理念就是解决HTML5的性能、工具、能力三方面的问题。MUI是一款不错的前端框架，性能比 jQuery Mobile、Bootstrap好很多，主要区别： 设计思路不同，MUI坚持用原生JS做，不依赖jQuery或者Angularjs。* MUI调用了5+ Runtime的底层原生加速，比不带原生加速的框架更快。 但是，DCloud毕竟是个新平台，发展才2年，新产品内部存在的Bug还需要很多的测试。在其官方社区中，不少开发者也在呼吁DCloud尽快完善文档和框架。#### 五 APICloud APICloud提供原生应用的功能模块（设备访问，界面布局，开放SDK等），开发者可以通过JS调用。前端工程师负责页面布局，UI展现，及简单的交互，原生模块负责性能方面和功能实现，两者结合形成一个完整的应用。同时APICloud提供了云数据库的功能，前端不必了解PHP，Node.js等后端语言，通过JS接口或Restful API实现数据库的增删改查。 但是APICloud的更新速度很快，版本不太稳定。而且，它是为不懂APP开发的人士准备的，不适合科技公司和程序员。## 六 兵器谱PK 由上表可知，4个平台的定位是不同的，导致其产品的功能特性不一样。## 七 优缺点对比]]></content>
      <tags>
        <tag>h5 app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两台centos之间传送文件]]></title>
    <url>%2Fpost%2Ff0c34e8f.html</url>
    <content type="text"><![CDATA[最近在CentOS系统中（主机A）读数据。由于A主机只是作为数据读取，具体的Deep Learning 实验，需要在主机B（ CentOS ）中进行，需要将主机A上的数据传输。由于主机A并不是一直开着CentOS系统，且数据量比较（40G+），所以用优盘copy的方法有点不现实，经过查找资料，发现了两种方法。 注意：两台主机都是CentOS 6.5 版本的系统，主机A：IP 192.168.1.102 主机B：192.168.1.33 1、用命令行的方式A，B 机上的SSH都允许root登录，B主机的IP：192.168.1.33，要把A主机上的/home/data文件夹传送到主机B上，运行命令 注意：这里的scp命令，前面不能加sudo ，加上sudo后会报错。 [root@localhost Desktop]# scp /home/data root@192.168.1.33:/home/new-data 上面的命令中/home/data 是A主机中要传的文件夹，后面的信息是B主机的信息。 输入上面的命令会提示输入B主机的root 密码，对于要传的文件夹来说scp命令是不允许的会提示 /home/data: not a regular file123456789101112131415so，需要先将文件夹进行压缩，然后再用刚才的命令进行传递数据 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;[root@localhost Desktop]#tar jcvf /home/data.tar.bz2 /home/data #创建.tar.bz2文件，压缩率高（由于数据量比较大，压缩时间比较长） &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;[root@localhost Desktop]#tar -xvjf data.tar.bz2 #解压.tar.bz2文件 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;pre&gt; &lt;pre&gt;1234567891011121314 # 2、用NFS方式首先稍微介绍一下NFS。NFS（ Network File System ）即，网络文件系统，允许网络中的计算机之间通过TCP/IP 网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。下面看一下NFS服务器和客户端的具体配置过程 ## 服务器的配置（1）安装nfs 所需的包，nfs-utils 和 rpcbind，注意：在centos的一些版本中安装nfs-utils的时候会安装rpcbind &lt;pre&gt;&lt;code class=&quot;language-sql hljs&quot;&gt;yum &lt;span class=&quot;hljs-keyword&quot;&gt;install -y nfs-utils&lt;/span&gt;&lt;/code&gt; （2）修改配置文件（创建共享的文件路径） &lt;pre&gt;&lt;code class=&quot;language-perl hljs&quot;&gt;&amp;&lt;span class=&quot;hljs-keyword&quot;&gt;lt;pre name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;code&quot; class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;html&quot;&amp;&lt;span class=&quot;hljs-keyword&quot;&gt;gt;[root@localhost Desktop]&lt;span class=&quot;hljs-comment&quot;&gt;#vim /etc/exports &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;1234/home/ 192.168.1.0/24 (rw,all_squash) #文件里面添加的内容 &lt;pre&gt; 其中的/home/ 是要共享的目录 192.168.1.0/24 是允许访问的主机，可以是一个IP，也可以是一个网段 。（）里是共享的权限 ，其中 rw是读写，all_squash是普通用户身份 （3）修改后，启动NFS服务 1. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;[root@localhost Desktop]# /etc/init.d/rpcbind start #输入该命令后无反应 &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 2. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; 3. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;div class=&quot;hljs-ln-line&quot;&gt;[root@localhost Desktop]# /etc/init.d/nfs start &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 4. &lt;div class=&quot;hljs-ln-numbers&quot;&gt; &lt;div class=&quot;hljs-ln-code&quot;&gt; &lt;/div&gt;&lt;/div&gt; ## 客户端的配置（主机B） （1）安装nfs所需的软件包（和服务器的安装方式一样） （2）查看服务器共享了哪些目录 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;showmount -e 192.168.1.102&lt;/code&gt;12345678910会提示如下错误![](http://pangguoming.com/blog/images/e316d79a-ca1c-41c6-ac63-41a9ed1899b5.jpg)在网上查找，发现是防火墻的问题 介绍网址 [NFS错误：clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)](http://www.cnblogs.com/jankie/archive/2012/11/14/2769585.html)被访问的NFS服务器上的防火墙没有添加规则，我所做的处理是直接将防火墙关闭，需在服务器配置 &lt;pre&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt; service iptables stop&lt;/code&gt; 服务器配置完后，再查看共享目录就没问题了。 （3）客户端mount nfs &lt;pre&gt;&lt;code class=&quot;language-ruby hljs&quot;&gt;mount -t nfs &lt;span class=&quot;hljs-number&quot;&gt;192.168.&lt;span class=&quot;hljs-number&quot;&gt;1.102&lt;span class=&quot;hljs-symbol&quot;&gt;:/home /mnt/new_data&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;```]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 开机自动连网]]></title>
    <url>%2Fpost%2Fb3d4a4ec.html</url>
    <content type="text"><![CDATA[新安装好的CentOS7桌面版，默认的网络都是关闭的，在图形页面中，开启后，重启后网络又关闭了。下面配置开机自动连网。## 工具/原料* CentOS7.2 ## 方法/步骤1. 首先打开终端，用ifconfig查看网络2. 进入 /etc/sysconfig/network-scripts/目录cd /etc/sysconfig/network-scripts/3. 找到ifcfg文件，这个文件名可以在前面的ifconfig中查看。我这里的是 ifcfg-enp2s04. 打开 ifcfg-enp2s0 文件vim ifcfg-enp2s05. 找到ONBOOT=no6. 修改为ONBOOT=yes，并保存7.]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular2 -- 生命周期钩子]]></title>
    <url>%2Fpost%2Fcddbe360.html</url>
    <content type="text"><![CDATA[#### 组件生命周期钩子指令和组件的实例有一个生命周期：新建、更新和销毁。 每个接口都有唯一的一个钩子方法，它们的名字是由接口名加上 ng前缀构成的。比如，OnInit接口的钩子方法叫做ngOnInit。 指令和组件 ngOnInit：当Angular初始化完成数据绑定的输入属性后，用来初始化指令或者组件。 ngOnChanges：当Angular设置了一个被绑定的输入属性后触发。该回调方法会收到一个包含当前值和原值的changes对象。 ngDoCheck：用来检测所有变化（无论是Angular本身能检测还是无法检测的），并作出相应行动。在每次执行“变更检测”时被调用。 ngOnDestory：在Angular销毁指令或组件之前做一些清理工作，比如退订可观察对象和移除事件处理器，以免导致内存泄漏。 只适用于组件 ngAfterContentInit：当Angular把外来内容投影进自己的视图之后调用。 ngAfterContentChecked：当Angular检查完那些投影到自己视图中的外来内容的数据绑定之后调用。 ngAfterViewInit：在Angular创建完组件的视图后调用。 ngAfterViewChecked：在Angular检查完组件视图中的绑定后调用。#### 生命周期的顺序 ngOnChanges：当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit之前。 ngOnInit：在第一轮ngOnChanges完成之后调用。 ngDoCheck：在每个Angular变更检测周期中调用。 ngAfterContentInit：当把内容投影进组件之后调用。 ngAfterContentChecked：每次完成被投影组件内容的变更检测之后调用。 ngAfterViewInit：初始化完组件及其子视图之后调用。 ngAfterViewChecked：每次做完组件视图和子视图的变更检测之后调用。 ngOnDestroy：当Angular每次销毁指令/组件之前调用。作者：Yeaseon链接：https://www.jianshu.com/p/8f4c15186d7b來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <tags>
        <tag>Angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7.2使用rpm安装jdk8]]></title>
    <url>%2Fpost%2F9b17f383.html</url>
    <content type="text"><![CDATA[①下载jdk去jdk下载页面找到要下载的jdk，用wget下载 `wget –no-check-certificate –no-cookies –header “Cookie: oraclelicense=accept-securebackup-cookie” http://download.oracle.com/otnpub/java/jdk/8u131b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm1234### ②安装jdk&lt;pre&gt;&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;rpm &lt;span class=&quot;hljs-selector-tag&quot;&gt;-ivh &lt;span class=&quot;hljs-selector-tag&quot;&gt;jdk-8u131-linux-x64&lt;span class=&quot;hljs-selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; ### ③配置环境变量(告诉电脑jdk在哪里) &lt;pre&gt;&lt;code class=&quot;hljs dts&quot;&gt;vim &lt;span class=&quot;hljs-meta-keyword&quot;&gt;/etc/profile &lt;span class=&quot;hljs-comment&quot;&gt;//打开环境变量文件&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678#### 进入insert模式(按字母i) 在最后面加上下面这段，然后按esc 然后保存退出(按 :wq回车)&lt;pre class=&quot;text&quot;&gt; JAVA_HOME=/usr/java/jdk1.8.0_131 CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin export PATH CLASSPATH JAVA_HOME &lt;pre&gt;&lt;code class=&quot;hljs dts&quot;&gt;source &lt;span class=&quot;hljs-meta-keyword&quot;&gt;/etc/profile &lt;span class=&quot;hljs-comment&quot;&gt;//重新载入&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;1234### ④检查是否完成安装&lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;java -version&lt;/span&gt;&lt;/code&gt; * * * ### rmp卸载jdk &lt;pre&gt;&lt;code class=&quot;hljs cpp&quot;&gt;rpm -qa|grep jdk &lt;span class=&quot;hljs-comment&quot;&gt;//查看版本 rpm -e jdk版本 &lt;span class=&quot;hljs-comment&quot;&gt;//卸载&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;```&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;]]></content>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卸载CentOS7-x64自带的OpenJDK并安装Sun的JDK7的方法]]></title>
    <url>%2Fpost%2Fdef2182f.html</url>
    <content type="text"><![CDATA[第一步：查看并卸载CentOS自带的OpenJDK 安装好的CentOS会自带OpenJdk,用命令 java -version ，会有下面的信息：java version “1.6.0”OpenJDK Runtime Environment (build 1.6.0-b09)OpenJDK 64-Bit Server VM (build 1.6.0-b09, mixed mode) 最好还是先卸载掉openjdk,在安装sun公司的jdk. 先查看 rpm -qa | grep java 显示如下信息： java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 卸载： rpm -e --nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 还有一些其他的命令 rpm -qa | grep gcj rpm -qa | grep jdk 如果出现找不到openjdk source的话，那么还可以这样卸载 yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 yum -y remove java java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 第二步：安装Sun JDK 7U67 如果在CentOS x64下安装32位的JAVA，则需要安装32位的glibc.i686、libgcc.i686 sudo yum install glibc.i686sudo yum install libgcc.i686 有时候，需要强制安装多个libgcc版本，此时需要： #sudo yum --setopt=protected_multilib=false install libgcc.i686 从SUN下载JDK( jdk-7u67-linux-i586.rpm ) 在 /usr 下新建 java 文件夹: mkdir /usr/java 将安装包放在 /usr/java 目录下 # cd /usr/java # rpm -ivh jdk-7u67-linux-i586.rpm ← 选择yes直到安装完毕 ``` 第三步：配置环境变量 在/etc/profile的最后加入以下几行： vi /etc/profileexport JAVA_HOME=/usr/java/jdk1.7.67_10export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin source /etc/profile ← 使配置生效reboot ← 或重启机器配置生效# 第四步： 检验安装 java -version*java version &quot;1.7.0_67&quot;* Java(TM) SE Runtime Environment (build 1.7.0_67-b01)* Java HotSpot(TM) Client VM (build 24.65-b04, mixed mode, sharing)* JDK安装成功！ &lt;div class=&quot;clearfix&quot;&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git可视化教程——Git Gui的使用]]></title>
    <url>%2Fpost%2Fb2a8ae75.html</url>
    <content type="text"><![CDATA[在Git简介一文中已经对Git进行了简单的介绍，但是理论知识过于枯燥，加上本人专业知识不够扎实，使得初学者在Git的使用上还是会有很大的困难。虽然我更推荐使用Git Bash方式对Git进行操作，但是对于大部分只是想简单地使用一下Git进行版本控制和团队开发的朋友而言，仍然更加钟情于可视化界面。所以本文对Git官方自带的可视化工具Git Gui的使用进行介绍，尽量做到图文并茂，让所有初探Git的朋友都能够快速入门，使用Git进行项目开发。 1.在本地新建版本库首先，我们打开Git GUI是这样的一个界面，选择第一项，新建版本库。然后选择你需要进行版本管理的项目路径，我选择了一个LoginDemo的项目。当你创建了版本库的时候，你可以在该项目的路径下看见多了一个.git文件夹（设置了隐藏文件不可见的话看不见）在Git Gui中，如果Unstaged Changes（未缓存的改动）中包含文件，则先点击Stage Changed，将未缓存的改动加入缓存，再点击Commit；否则需要先点击Rescan扫描项目中进行过改动的文件。注：提交描述必须要填写，不然无法提交。提交成功后，我们可以在Repository-&gt;Visualize All Branches History中看到我们提交的历史记录（这是提交到本地而不是提交到远程服务器）。至此，本地版本库就创建成功了。 2.将项目提交到远程上一步已经使用Git在本地建立起了版本库，然后我们需要将该项目提交到远程服务器以便同事或其他合作者共同参与开发。一般的开源项目使用github作为远程服务器。其实在本地简历版本库后，只需要点击push就可以直接上传。但是我们还没有将本地的Git与github建立联系以及设置安全协议。 首先，我们需要在有一个自己的github帐户，然后在github上新建一个repository，名字也叫做LoginDemo（可以和本地项目名不一样）。在Git Gui中，选择Remote-&gt;add添加远程服务器，远程服务器信息有两种填写方式，填写https地址或ssh地址，对应github项目的https和ssh地址，推荐使用ssh方式。 1.https地址这种方式需要输入你的github帐户和密码，意味着通过这种方式你只能够操作自己的项目。 2.ssh地址这种方式需要进行授权设置，在Git Gui的菜单栏，点击Help-&gt;Show SSH key-&gt;Generate SSH KEY创建密钥。然后在github的Personal settings中添加它，title随意，可以用Home，company等作为标识来区别。添加远程服务器信息。 接下来，我们便可以直接在Git Gui点击push提交至远程客户端，刷新一下github，便可以看到项目已经在repository中了。 3.从远程下载更新设想多人参与项目开发，每个人都只push到远程，完全不顾其他成员的进度，这样的开发模式无疑是有问题的。我们最好的做法是，每次push到远程的时候，先从远程把目前进度fetch下来，在和自己目前项目进度merge后，再将它push到远程。打开Git Gui，在菜单栏中选择Remote-&gt;Fetch from-&gt;LoginTest，便可以从远程服务器更新到本地，但是尚未与自己当前项目合并。 4.合并解决冲突从远程fetch后，选择Git Gui的Merge-&gt;Local Merge进行合并，选择Tracking Branch。如果本地有一个方法名叫findUser，而远程服务器中该方法的名字改变了，例如变成了findPassword，则合并遇到冲突，可以右键空白部分选择保留本地版本或远程版本进行合并（图中绿色的代码表示冲突部分）。 5.克隆github上的项目到本地在Git Gui的主界面选择克隆已有版本库。Source Location即github中项目的地址，和第二部分（将项目提交到远程）中一样，可以选择https地址或ssh地址，Target Directory是在本地存放该项目的路径。点击Clone，成功从github将项目克隆到本地。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring mvc整合freemarker详解]]></title>
    <url>%2Fpost%2Fd4e17029.html</url>
    <content type="text"><![CDATA[1.什么是FreeMarkerFreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯Java编写FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据（如下图） 2.FreeMarker特性能够生成各种文本：HTML、XML、RTF、Java源代码等等易于嵌入到你的产品中：轻量级；不需要Servlet环境插件式模板载入器：可以从任何源载入模板，如本地文件、数据库等等你可以按你所需生成文本：保存到本地文件；作为Email发送；从Web应用程序发送它返回给Web浏览器 3. springMVC整合Freemarker1.添加jar包添加freemarker的jar，还需要额外添加spring-content-support的jar包，不然会报错。 2.然后再Spring的配置文件中添加对freemarker的配置 &lt;bean class=“org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer”&gt; &lt;property name=“templateLoaderPath” value=“WEB-INF/ftl/“ /&gt; &lt;property name=“defaultEncoding” value=“UTF-8” /&gt; &lt;/bean&gt; &lt;bean class=“org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver”&gt; &lt;property name=“suffix” value=“.html” /&gt; &lt;property name=“contentType” value=“text/html;charset=UTF-8” /&gt; &lt;property name=“requestContextAttribute” value=“rc” /&gt; &lt;/bean&gt; 1234567891011121314151617181920212223242526272829303132333435* 1* 2* 3* 4* 5* 6* 7* 8* 9* 10* 11* 12## 3.写一个User类：&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs cs has-numbering&quot;&gt;package com.my.springmvc.bean;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class User &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;private String username; &lt;span class=&quot;hljs-keyword&quot;&gt;private String password; &lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getUsername() &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return username; &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setUsername(String username) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;this.username = username; &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getPassword() &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return password; &#125; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setPassword(String password) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;this.password = password; &#125;&#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 ## 4.一个FreeMarkerController类： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs java has-numbering&quot;&gt;&lt;span class=&quot;hljs-annotation&quot;&gt;@Controller &lt;span class=&quot;hljs-annotation&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/home&quot;) &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;FreeMarkerController { &lt;span class=&quot;hljs-annotation&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/index&quot;) &lt;span class=&quot;hljs-keyword&quot;&gt;public ModelAndView &lt;span class=&quot;hljs-title&quot;&gt;Add(HttpServletRequest request,HttpServletResponse response){ User user = &lt;span class=&quot;hljs-keyword&quot;&gt;new User(); user.setUsername(&lt;span class=&quot;hljs-string&quot;&gt;&quot;sg&quot;); user.setPassword(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1234&quot;); List&lt;User&gt; users = &lt;span class=&quot;hljs-keyword&quot;&gt;new ArrayList&lt;User&gt;(); users.add(user); ModelAndView mv = &lt;span class=&quot;hljs-keyword&quot;&gt;new ModelAndView(); mv.setViewName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;); mv.addObject(&lt;span class=&quot;hljs-string&quot;&gt;&quot;users&quot;,users); &lt;span class=&quot;hljs-keyword&quot;&gt;return mv; } }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819202122232425262728293031323334353637 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 ## 5.然后再WEB-INF/ftl目录下创建一个index.html文件：## &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-doctype&quot;&gt;&lt;!DOCTYPE html&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;html&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;head&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;meta &lt;span class=&quot;hljs-attribute&quot;&gt;charset=&lt;span class=&quot;hljs-value&quot;&gt;&quot;UTF-8&quot;&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;title&gt;another&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;title&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;head&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;body&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;#list &lt;span class=&quot;hljs-attribute&quot;&gt;users &lt;span class=&quot;hljs-attribute&quot;&gt;as &lt;span class=&quot;hljs-attribute&quot;&gt;user&gt; username : $&#123;user.username&#125;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;br/&gt; password : $&#123;user.password&#125; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;#list&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;body&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;html&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 ## 结果： # 4.freemarker语法介绍： ## 1. FreeMarker模板文件主要由如下4个部分组成 文本：直接输出的部分注释：&lt;#– … –&gt; 格式部分，不会输出插值：即 ${…} 或 #{…} 格式的部分，将使用数据模型中的部分替代输出指令：FreeMarker 指定，和 HTML 标记类似，名字前加 # 予以区分，不会输出 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;html&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;head&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;title&gt;Welcome!&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;title&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;head&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;body&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;#-- 注释部分 &lt;span class=&quot;hljs-attribute&quot;&gt;--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;#-- 下面使用插值 &lt;span class=&quot;hljs-attribute&quot;&gt;--&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;h1&gt;Welcome ${username} !&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;h1&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;p&gt;We have these animals:&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;p&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;u1&gt; &lt;span class=&quot;hljs-comment&quot;&gt;&lt;!-- 使用FTL指令 --&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;#list &lt;span class=&quot;hljs-attribute&quot;&gt;animals &lt;span class=&quot;hljs-attribute&quot;&gt;as &lt;span class=&quot;hljs-attribute&quot;&gt;animal&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;li&gt;${animal.name} for ${animal.price} Euros&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;li&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;#list&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;u1&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;body&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;html &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243* 1* 2* 3* 4* 5* 6* 7* 8* 9* 10* 11* 12* 13* 14* 15* 16* 17* 18* 19## 2.控制语句&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs r has-numbering&quot;&gt;&lt;&lt;span class=&quot;hljs-comment&quot;&gt;#if condition&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#elseif condition2&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#elseif condition3&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#else&gt;&lt;&lt;span class=&quot;hljs-comment&quot;&gt;#switch value&gt; &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#case refValue1&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#break&gt; &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#case refValue2&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#break&gt; &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#case refValueN&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#break&gt; &lt;&lt;span class=&quot;hljs-comment&quot;&gt;#default&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;... &lt;/&lt;span class=&quot;hljs-comment&quot;&gt;#switch&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 ## 3判断变量是否存在 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs cs has-numbering&quot;&gt;&lt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;if readonly??&gt;&lt;/#&lt;span class=&quot;hljs-keyword&quot;&gt;if&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819 * 1 ## 4.防止空指针报错变量名后用 ! 加默认值：$&#123;foo!”Default”&#125;，如果 foo 为 null 则输出 Default ## 5.普通的变量这是最简单的情况，直接&lt;span id=&quot;MathJax-Element-1-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&lt;math xmlns=&quot; http://www.w3.org/1998/math/mathml&quot;=&quot;&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;变&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;量&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;名&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;称&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;，&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;如&lt;/mo&gt;&lt;/mrow&gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-3&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-4&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-5&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-6&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-7&quot; class=&quot;mo&quot;&gt;变&lt;span id=&quot;MathJax-Span-8&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-9&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-10&quot; class=&quot;mo&quot;&gt;量&lt;span id=&quot;MathJax-Span-11&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-12&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-13&quot; class=&quot;mo&quot;&gt;名&lt;span id=&quot;MathJax-Span-14&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-15&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-16&quot; class=&quot;mo&quot;&gt;称&lt;span id=&quot;MathJax-Span-17&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-18&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-19&quot; class=&quot;mo&quot;&gt;，&lt;span id=&quot;MathJax-Span-20&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-21&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-22&quot; class=&quot;mo&quot;&gt;如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;变量名称，如&#123;name&#125;&lt;/span&gt;&lt;/span&gt;需要注意的是有的变量是需要转义的如双引号 ## 6..遍历List集合 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs smalltalk has-numbering&quot;&gt;&lt;&lt;span class=&quot;hljs-symbol&quot;&gt;#list [&lt;span class=&quot;hljs-comment&quot;&gt;&quot;克里斯埃文斯&quot;, &lt;span class=&quot;hljs-comment&quot;&gt;&quot;斯嘉丽约翰逊&quot;, &lt;span class=&quot;hljs-comment&quot;&gt;&quot;小罗伯特唐尼&quot;] as x&gt; &lt;span class=&quot;hljs-char&quot;&gt;$&#123;x&#125; &lt;/&lt;span class=&quot;hljs-symbol&quot;&gt;#list&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; * 1 * 2 * 3 * 4 此外,迭代集合对象时,还包含两个特殊的循环变量:item_index:当前变量的索引值item_has_next:是否存在下一个对象也可以使用&lt;#break&gt;指令跳出迭代 ## 7.运算符 FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %比较运算符 表达式中支持的比较运算符有如下几个:1,=或者==:判断两个值是否相等.2,!=:判断两个值是否不等.3,&gt;或者gt:判断左边值是否大于右边值4,&gt;=或者gte:判断左边值是否大于等于右边值5,&lt;或者lt:判断左边值是否小于右边值6,&lt;=或者lte:判断左边值是否小于等于右边值 注意:=和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替&gt;会有更好的效果,因为FreeMarker会把&gt;解释成FTL标签的结束字符,当然,也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt; 逻辑运算符 和普通程序一样，freemarker也有&amp;&amp;，|| ，!三种 ## 8.变量的声明 &lt;#assign num=0/&gt; ## 9.include指令 include指令的作用类似于JSP的包含指令,用于包含指定页.include指令的语法格式如下:&lt;#include filename [options]&gt;在上面的语法格式中,两个参数的解释如下:filename:该参数指定被包含的模板文件options:该参数可以省略,指定包含时的选项,包含encoding和parse两个选项,其中encoding指定包含页面时所用的解码集,而parse指定被包含文件是否作为FTL文件来解析,如果省略了parse选项值,则该选项默认是true. ## 10.import指令 该指令用于导入FreeMarker模板中的所有变量,并将该变量放置在指定的Map对象中,import指令的语法格式如下:&lt;#import “/lib/common.ftl” as com&gt;上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中. ## 11 macro的使用 这个可以用来实现自定义指令，一般用来做公共组件，例如分页条最后说下list中含有map的遍历，这种情况可以使用点语法或方括号语法.假如有下面的数据模型:Map root = new HashMap();Book book = new Book();Author author = new Author();author.setName(“annlee”);author.setAddress(“gz”);book.setName(“struts2”);book.setAuthor(author);root.put(“info”,”struts”);root.put(“book”, book); 为了访问数据模型中名为struts2的书的作者的名字,可以使用如下语法:book.author.name //全部使用点语法book[“author”].namebook.author[“name”] //混合使用点语法和方括号语法book[“author”][“name”] //全部使用方括号语法 参考：http://blog.csdn.net/walkcode/article/details/26393211http://blog.csdn.net/win_man/article/details/51317957http://rongjih.blog.163.com/blog/static/3357446120127632757911/http://qtdebug.com/spring-web/11.%20Freemarker%20%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B.htmlhttp://blog.csdn.net/walkcode/article/details/26393211http://blog.csdn.net/shimiso/article/details/8778793]]></content>
      <tags>
        <tag>spring mvc</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka 主要内容介绍]]></title>
    <url>%2Fpost%2F90d7057.html</url>
    <content type="text"><![CDATA[1. kafka介绍1.1. 主要功能根据官网的介绍，ApacheKafka®是一个分布式流媒体平台，它主要有3种功能： 1：It lets you publish and subscribe to streams of records.发布和订阅消息流，这个功能类似于消息队列，这也是kafka归类为消息队列框架的原因 2：It lets you store streams of records in a fault-tolerant way.以容错的方式记录消息流，kafka以文件的方式来存储消息流 3：It lets you process streams of records as they occur.可以再消息发布的时候进行处理 1.2. 使用场景1：Building real-time streaming data pipelines that reliably get data between systems or applications.在系统或应用程序之间构建可靠的用于传输实时数据的管道，消息队列功能 2：Building real-time streaming applications that transform or react to the streams of data。构建实时的流数据处理程序来变换或处理数据流，数据处理功能 1.3. 详细介绍Kafka目前主要作为一个分布式的发布订阅式的消息系统使用，下面简单介绍一下kafka的基本机制 1.3.1 消息传输流程 Producer即生产者，向Kafka集群发送消息，在发送消息之前，会对消息进行分类，即Topic，上图展示了两个producer发送了分类为topic1的消息，另外一个发送了topic2的消息。 Topic即主题，通过对消息指定主题可以将消息分类，消费者可以只关注自己需要的Topic中的消息 Consumer即消费者，消费者通过与kafka集群建立长连接的方式，不断地从集群中拉取消息，然后可以对这些消息进行处理。 从上图中就可以看出同一个Topic下的消费者和生产者的数量并不是对应的。 1.3.2 kafka**服务器消息存储策略** 谈到kafka的存储，就不得不提到分区，即partitions，创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。 在每个分区中，消息以顺序存储，最晚接收的的消息会最后被消费。 1.3.3 与生产者的交互 生产者在向kafka集群发送消息的时候，可以通过指定分区来发送到指定的分区中 也可以通过指定均衡策略来将消息发送到不同的分区中 如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的分区中 1.3.4 与消费者的交互 在消费者消费消息时，kafka使用offset来记录当前消费的位置 在kafka的设计中，可以有多个不同的group来同时消费同一个topic下的消息，如图，我们有两个不同的group同时消费，他们的的消费的记录位置offset各不项目，不互相干扰。 对于一个group而言，消费者的数量不应该多余分区的数量，因为在一个group中，每个分区至多只能绑定到一个消费者上，即一个消费者可以消费多个分区，一个分区只能给一个消费者消费 因此，若一个group中的消费者数量大于分区数量的话，多余的消费者将不会收到任何消息。 ## 2. Kafka安装与使用### 2.1. 下载 你可以在kafka官网 http://kafka.apache.org/downloads下载到最新的kafka安装包，选择下载二进制版本的tgz文件，根据网络状态可能需要fq，这里我们选择的版本是0.11.0.1，目前的最新版### 2.2. 安装 Kafka是使用scala编写的运行与jvm虚拟机上的程序，虽然也可以在windows上使用，但是kafka基本上是运行在linux服务器上，因此我们这里也使用linux来开始今天的实战。 首先确保你的机器上安装了jdk，kafka需要java运行环境，以前的kafka还需要zookeeper，新版的kafka已经内置了一个zookeeper环境，所以我们可以直接使用 说是安装，如果只需要进行最简单的尝试的话我们只需要解压到任意目录即可，这里我们将kafka压缩包解压到/home目录### 2.3. 配置 在kafka解压目录下下有一个config的文件夹，里面放置的是我们的配置文件 consumer.properites 消费者配置，这个配置文件用于配置于2.5节中开启的消费者，此处我们使用默认的即可 producer.properties 生产者配置，这个配置文件用于配置于2.5节中开启的生产者，此处我们使用默认的即可 server.properties kafka服务器的配置，此配置文件用来配置kafka服务器，目前仅介绍几个最基础的配置1. 1. broker.id 申明当前kafka服务器在集群中的唯一ID，需配置为integer,并且集群中的每一个kafka服务器的id都应是唯一的，我们这里采用默认配置即可 2. listeners 申明此kafka服务器需要监听的端口号，如果是在本机上跑虚拟机运行可以不用配置本项，默认会使用localhost的地址，如果是在远程服务器上运行则必须配置，例如： listeners=PLAINTEXT:// 192.168.180.128:9092。并确保服务器的9092端口能够访问 3.zookeeper.connect 申明kafka所连接的zookeeper的地址 ，需配置为zookeeper的地址，由于本次使用的是kafka高版本中自带zookeeper，使用默认配置即可 zookeeper.connect=localhost:2181### 2.4. 运行1. 启动zookeepercd进入kafka解压目录，输入bin/zookeeper-server-start.sh config/zookeeper.properties启动zookeeper成功后会看到如下的输出 2.启动kafkacd进入kafka解压目录，输入bin/kafka-server-start.sh config/server.properties启动kafka成功后会看到如下的输出 ### 2.5. 第一个消息 2.5.1 创建一个topic Kafka通过topic对同一类的数据进行管理，同一类的数据使用同一个topic可以在处理数据时更加的便捷 在kafka解压目录打开终端，输入bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic `test 创建一个名为test的topic![](http://pangguoming.com/blog/images/fdb953d2-392b-492a-ac3d-b46f9dabe583.png) 在创建topic后可以通过输入bin/kafka-topics.sh –list –zookeeper localhost:2181 来查看已经创建的topic` ` 2.4.2创建一个消息消费者 在kafka解压目录打开终端，输入 bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test` `--from-beginning` ` 可以创建一个用于消费topic为test的消费者` ![](http://pangguoming.com/blog/images/0b3f99cb-c30e-4e48-90aa-9060581e44e5.png) 消费者创建完成之后，因为还没有发送任何数据，因此这里在执行后没有打印出任何数据 不过别着急，不要关闭这个终端，打开一个新的终端，接下来我们创建第一个消息生产者 2.4.3 创建一个消息生产者 在kafka解压目录打开一个新的终端，输入 ` bin/kafka-console-producer.sh --broker-list localhost:9092 --topictest 在执行完毕后会进入的编辑器页面`在发送完消息之后，可以回到我们的消息消费者终端中，可以看到，终端中已经打印出了我们刚才发送的消息## 3. 使用java程序 跟上节中一样，我们现在在java程序中尝试使用kafka 3.1 创建Topicpublic static void main(String[] args) { //创建topic Properties props = new Properties(); props.put(“bootstrap.servers”, “192.168.180.128:9092”); AdminClient adminClient = AdminClient.create(props); ArrayList topics = new ArrayList(); NewTopic newTopic = new NewTopic(“topic-test”, 1, (short) 1); topics.add(newTopic); CreateTopicsResult result = adminClient.createTopics(topics); try { result.all().get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); }} 使用AdminClient API可以来控制对kafka服务器进行配置，我们这里使用NewTopic(String name, int numPartitions, short replicationFactor)的构造方法来创建了一个名为“topic-test”，分区数为1，复制因子为1的Topic.3.2 Producer生产者发送消息public static void main(String[] args){ Properties props = new Properties(); props.put(“bootstrap.servers”, “192.168.180.128:9092”); props.put(“acks”, “all”); props.put(“retries”, 0); props.put(“batch.size”, 16384); props.put(“linger.ms”, 1); props.put(“buffer.memory”, 33554432); props.put(“key.serializer”, “org.apache.kafka.common.serialization.StringSerializer”); props.put(“value.serializer”, “org.apache.kafka.common.serialization.StringSerializer”); Producer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(props); for (int i = 0; i &lt; 100; i++) producer.send(new ProducerRecord&lt;String, String&gt;(“topic-test”, Integer.toString(i), Integer.toString(i))); producer.close();}使用producer发送完消息可以通过2.5中提到的服务器端消费者监听到消息。也可以使用接下来介绍的java消费者程序来消费消息3.3 Consumer消费者消费消息public static void main(String[] args){ Properties props = new Properties(); props.put(“bootstrap.servers”, “192.168.12.65:9092”); props.put(“group.id”, “test”); props.put(“enable.auto.commit”, “true”); props.put(“auto.commit.interval.ms”, “1000”); props.put(“key.deserializer”, “org.apache.kafka.common.serialization.StringDeserializer”); props.put(“value.deserializer”, “org.apache.kafka.common.serialization.StringDeserializer”); final KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;String,String&gt;(props); consumer.subscribe(Arrays.asList(“topic-test”),new ConsumerRebalanceListener() { public void onPartitionsRevoked(Collection collection) { } public void onPartitionsAssigned(Collection collection) { //将偏移设置到最开始 consumer.seekToBeginning(collection); } }); while (true) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) System.out.printf(“offset = %d, key = %s, value = %s%n”, record.offset(), record.key(), record.value()); }}这里我们使用Consume API 来创建了一个普通的java消费者程序来监听名为“topic-test”的Topic，每当有生产者向kafka服务器发送消息，我们的消费者就能收到发送的消息。## 4. 使用spring-kafkaSpring-kafka是正处于孵化阶段的一个spring子项目，能够使用spring的特性来让我们更方便的使用kafka4.1 基本配置信息与其他spring的项目一样，总是离不开配置，这里我们使用java配置来配置我们的kafka消费者和生产者。1. 引入pom文件 org.apache.kafka kafka-clients 0.11.0.1 org.apache.kafka kafka-streams 0.11.0.1 org.springframework.kafka spring-kafka 1.3.0.RELEASE1. 创建配置类我们在主目录下新建名为KafkaConfig的类@Configuration@EnableKafkapublic class KafkaConfig {}1. 配置Topic在kafkaConfig类中添加配置//topic config Topic的配置开始 @Bean public KafkaAdmin admin() { Map&lt;String, Object&gt; configs = new HashMap&lt;String, Object&gt;(); configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,”192.168.180.128:9092”); return new KafkaAdmin(configs); } @Bean public NewTopic topic1() { return new NewTopic(“foo”, 10, (short) 2); }//topic的配置结束1. 配置生产者Factort及Template//producer config start @Bean public ProducerFactory&lt;Integer, String&gt; producerFactory() { return new DefaultKafkaProducerFactory&lt;Integer,String&gt;(producerConfigs()); } @Bean public Map&lt;String, Object&gt; producerConfigs() { Map&lt;String, Object&gt; props = new HashMap&lt;String,Object&gt;(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, “192.168.180.128:9092”); props.put(“acks”, “all”); props.put(“retries”, 0); props.put(“batch.size”, 16384); props.put(“linger.ms”, 1); props.put(“buffer.memory”, 33554432); props.put(“key.serializer”, “org.apache.kafka.common.serialization.IntegerSerializer”); props.put(“value.serializer”, “org.apache.kafka.common.serialization.StringSerializer”); return props; } @Bean public KafkaTemplate&lt;Integer, String&gt; kafkaTemplate() { return new KafkaTemplate&lt;Integer, String&gt;(producerFactory()); }//producer config end5.配置ConsumerFactory//consumer config start @Bean public ConcurrentKafkaListenerContainerFactory&lt;Integer,String&gt; kafkaListenerContainerFactory(){ ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt;(); factory.setConsumerFactory(consumerFactory()); return factory; } @Bean public ConsumerFactory&lt;Integer,String&gt; consumerFactory(){ return new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(consumerConfigs()); } @Bean public Map&lt;String,Object&gt; consumerConfigs(){ HashMap&lt;String, Object&gt; props = new HashMap&lt;String, Object&gt;(); props.put(“bootstrap.servers”, “192.168.180.128:9092”); props.put(“group.id”, “test”); props.put(“enable.auto.commit”, “true”); props.put(“auto.commit.interval.ms”, “1000”); props.put(“key.deserializer”, “org.apache.kafka.common.serialization.IntegerDeserializer”); props.put(“value.deserializer”, “org.apache.kafka.common.serialization.StringDeserializer”); return props; }//consumer config end4.2 创建消息生产者//使用spring-kafka的template发送一条消息 发送多条消息只需要循环多次即可public static void main(String[] args) throws ExecutionException, InterruptedException { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(KafkaConfig.class); KafkaTemplate&lt;Integer, String&gt; kafkaTemplate = (KafkaTemplate&lt;Integer, String&gt;) ctx.getBean(“kafkaTemplate”); String data=”this is a test message”; ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; send = kafkaTemplate.send(“topic-test”, 1, data); send.addCallback(new ListenableFutureCallback&lt;SendResult&lt;Integer, String&gt;&gt;() { public void onFailure(Throwable throwable) { } public void onSuccess(SendResult&lt;Integer, String&gt; integerStringSendResult) { } });}4.3 创建消息消费者我们首先创建一个一个用于消息监听的类，当名为”topic-test”的topic接收到消息之后，我们的这个listen方法就会调用。public class SimpleConsumerListener { private final static Logger logger = LoggerFactory.getLogger(SimpleConsumerListener.class); private final CountDownLatch latch1 = new CountDownLatch(1); @KafkaListener(id = “foo”, topics = “topic-test”) public void listen(byte[] records) { //do something here this.latch1.countDown(); }} 我们同时也需要将这个类作为一个Bean配置到KafkaConfig中@Beanpublic SimpleConsumerListener simpleConsumerListener(){ return new SimpleConsumerListener();}默认spring-kafka会为每一个监听方法创建一个线程来向kafka服务器拉取消息#]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#异步编程]]></title>
    <url>%2Fpost%2F1e33e198.html</url>
    <content type="text"><![CDATA[什么是异步编程什么是异步编程呢？举个简单的例子： 123456789101112131415161718192021222324252627using System.Net.Http;using System.Threading.Tasks;using static System.Console;namespace Core&#123; class Async &#123; static void Main() &#123; Start(); End(); &#125; static void Wait()=&gt;WriteLine(&quot;waiting...&quot;); static void End()=&gt;WriteLine(&quot;end...&quot;); static int Start() &#123; WriteLine(&quot;start...&quot;); HttpClient client = new HttpClient(); Waiting(); var result = client.GetStringAsync(&quot;https://www.visualstudio.com/&quot;); string str = result.Result; return str.Length; &#125; &#125;&#125; 上面这段代码中，Main方法中的代码是按照自上而下的顺序执行的。网络状况不佳时，Start()方法是比较耗时（注意，这里在Start方法中调用了异步方法GetStringAsync，但该方法在此处是以同步方式执行的，具体原因下文会进行说明），在Start()方法执行完毕之前，整个程序处于阻塞状态。而异步编程可以很好的解决这个问题，一句简单的话来概括异步编程就是，程序无须按照代码顺序自上而下的执行。 async/awaitC#5.0新增了async和await关键字，使用这两个关键字可以大大简化异步编程 使用 async 关键字可将方法、lambda 表达式或匿名方法标记为异步，即，方法中应该包含一个或多个await表达式，但async关键字本身不会创建异步操作。 1234public async Task Asy()&#123; //do something...&#125; 这里需要注意一点，若使用async关键字标记的方法中没有使用await关键字（编译器会给出警告但不报错），那么该方法将会以同步方式执行。 定义异步方法的几点要求定义一个异步方法应满足以下几点： 使用async关键字来修饰方法 在异步方法中使用await关键字（不使用编译器会给出警告但不报错），否则异步方法会以同步方式执行 尽量不使用void作为返回类型，若希望异步方法返回void类型，请使用Task 异步方法名称以Async结尾 异步方法中不能声明使用ref或out关键字修饰的变量 下面定义一个异步方法StartAsync()： 123456static async Task&lt;int&gt; StartAsync()&#123; HttpClient client = new HttpClient(); var str = await client.GetStringAsync(&quot;https://www.visualstudio.com/&quot;); return str.Length;&#125; 异步方法的返回类型 Task如果在调用匿名方法时使用了await关键字，且匿名方法的返回类型是Task，那么我们得到的返回类型是T。若未使用await关键字，则返回类型是Task。未使用await，调用GetStringAsync方法时result是Task类型。 从上图我们可以看到调用GetStringAsync方法时未使用await关键字，result是Task类型，我们可以通过GetType()方法来获取result的详细类型信息： 从上图可以看到result的类型全名是System.Threading.Tasks.Task从上图我们可以看到使用await关键字时，result是string类型，而匿名方法GetStringAsync的返回类型是TaskTask如果在调用匿名方法时使用了await关键字，且匿名方法的返回类型是Task，那么我们得到的返回类型是void。若为使用await关键字，则得到的返回类型是Task。 void不建议使用void作为异步方法的返回值。因为使用Task或Task任务作为返回值，其属性携带有关其状态和历史记录的信息，如任务是否完成、异步方法是否导致异常或已取消以及最终结果是什么。而await运算符可访问这些属性。# 异步方法执行流程异步程序执行流程上图是微软官方提供的讲解异步程序执行流程的图示，并附有解释说明：&gt; The numbers in the diagram correspond to the following steps.&gt;&gt; 1. An event handler calls and awaits the AccessTheWebAsync async method.&gt; 2. AccessTheWebAsync creates an HttpClient instance and calls the GetStringAsyncasynchronous method to download the contents of a website as a string.&gt; 3. Something happens in GetStringAsync that suspends its progress. Perhaps it must wait for a website to download or some other blocking activity. To avoid blocking resources, GetStringAsync yields control to its caller, AccessTheWebAsync.&gt; GetStringAsync returns a Task where TResult is a string, and AccessTheWebAsync assigns the task to thegetStringTask variable. The task represents the ongoing process for the call to GetStringAsync, with a commitment to produce an actual string value when the work is complete.&gt; 4. Because getStringTask hasn’t been awaited yet, AccessTheWebAsync can continue with other work that doesn’t depend on the final result from GetStringAsync. That work is represented by a call to the synchronous method DoIndependentWork.&gt; 5. DoIndependentWork is a synchronous method that does its work and returns to its caller.&gt; 6. AccessTheWebAsync has run out of work that it can do without a result from getStringTask. AccessTheWebAsync next wants to calculate and return the length of the downloaded string, but the method can’t calculate that value until the method has the string.&gt; Therefore, AccessTheWebAsync uses an await operator to suspend its progress and to yield control to the method that called AccessTheWebAsync. AccessTheWebAsync returns a Task to the caller. The task represents a promise to produce an integer result that’s the length of the downloaded string.&gt; &gt;&gt; Note&gt; If GetStringAsync (and therefore getStringTask) is complete before AccessTheWebAsync awaits it, control remains inAccessTheWebAsync. The expense of suspending and then returning to AccessTheWebAsync would be wasted if the called asynchronous process (getStringTask) has already completed and AccessTheWebSync doesn’t have to wait for the final result.&gt; Inside the caller (the event handler in this example), the processing pattern continues. The caller might do other work that doesn’t depend on the result from AccessTheWebAsync before awaiting that result, or the caller might await immediately. The event handler is waiting for AccessTheWebAsync, and AccessTheWebAsync is waiting for GetStringAsync.&gt;&gt; &gt;&gt; 7. GetStringAsync completes and produces a string result. The string result isn’t returned by the call to GetStringAsync in the way that you might expect. (Remember that the method already returned a task in step Instead, the string result is stored in the task that represents the completion of the method, getStringTask. The await operator retrieves the result from getStringTask. The assignment statement assigns the retrieved result to urlContents.&gt; 8. When AccessTheWebAsync has the string result, the method can calculate the length of the string. Then the work ofAccessTheWebAsync is also complete, and the waiting event handler can resume. In the full example at the end of the topic, you can confirm that the event handler retrieves and prints the value of the length result.&gt; If you are new to asynchronous programming, take a minute to consider the difference between synchronous and asynchronous behavior. A synchronous method returns when its work is complete (step 5), but an async method returns a task value when its work is suspended (steps 3 and 6). When the async method eventually completes its work, the task is marked as completed and the result, if any, is stored in the task.解释虽是英文，但并没有太难的单词，是可以看懂其意思的。通过上面的说明，我们可以知道：在遇到awiat关键字之前，程序是按照代码顺序自上而下以同步方式执行的。在遇到await关键字之后，系统做了以下工作：1. 异步方法将被挂起2. 将控制权返回给调用者3. 使用线程池中的线程（而非额外创建新的线程）来计算await表达式的结果，所以await不会造成程序的阻塞4. 完成对await表达式的计算之后，若await表达式后面还有代码则由执行await表达式的线程（不是调用方所在的线程）继续执行这些代码使用一段代码来进行验证：123456789101112131415static void Main()&#123; Task&lt;int&gt; task = StartAsync(); Thread.Sleep(5000); End();&#125;static async Task&lt;int&gt; StartAsync()&#123; WriteLine(&quot;start...&quot;); HttpClient client = new HttpClient(); var result = client.GetStringAsync(&quot;https://www.visualstudio.com/&quot;); string str = await result; return str.Length;&#125;执行代码从上图左侧的调用栈中可以看到，在遇到await关键字之前，异步方法StartAsync自上而下同步执行。注意，这里异步方法GetStringAsync方法是被挂起的，不会造成程序的阻塞，控制权回到调用者StartAsync中，仔细看英文解释中的第3步。然后在Debug Console中输入System.Threading.Thread.Current查看当前工作线程信息，以及System.Threading.Thread.CurrentThread.IsThreadPoolThread查看当前线程是否在线程池中。从上图我们看到，当前线程Id是1，不在线程池中。继续执行程序：遇到await关键字后，异步方法StartAsync被挂起，控制权也回到了调用者Main方法中。从上图我们可以看到异步方法StartAsync中的result变量的Status属性值是WaitingForActivation，Result属性值是Not yet computed。代码继续执行，将Main方法所在线程接挂起5秒，系统使用线程池中的线程计算await表达式的值：从上图我们可以看到，程序已经成功计算出await表达式的值，变量result的Status属性值变成了RanToCompletion。完成对await表达式的计算之后，程序继续执行后面的代码(return str.Length)。再看此时的工作线程信息：我们看到，当前线程Id是5且存在于线程池中。从这里我们可以得知异步是借助于多线程来实现的。# TaskTask类拥有执行异步方法的两个方法：Task.Run(),Task.Run&lt;T&gt;，Task.Run以及Task.Run&lt;T&gt;使用线程池中的线程来执行代码，它和使用await关键字的区别是：Task.Run直接使用线程池中的线程，而使用await的异步方法是在遇到await关键字后才使用多线程。# Thread线程.aspx)是前面所说的异步（async/await）和任务（Task）的基础。和线程紧密相关的另外一个概念是进程，这里不多赘述。# ThreadPool线程也是对象，频繁的创建和销毁线程比较影响性能，.NET提供线程池.aspx)使得我们能够复用线程对象从而避免频繁创建和销毁线程。# 结语自己创建线程比较麻烦但能够更好的控制程序的运行，使用async/await关键字来编码显得较为简洁，但对程序的控制力度会有所降低。# 参考文章：Asynchronous Programming with async and await (C#)asyncawait走进异步编程的世界 - 开始接触 async/awaitC#执行异步操作的几种方式比较和总结thread task parallel plinq async await多线程 任务及异步编程走进异步编程的世界 - 在 GUI 中执行异步操作Async/Await - Best Practices in Asynchronous Programming### 版权声明]]></content>
      <tags>
        <tag>C#</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb 按配置文件mongodb.conf启动]]></title>
    <url>%2Fpost%2F125f6c25.html</url>
    <content type="text"><![CDATA[命令如下 mongod –config /etc/mongodb.conf`]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven镜像更换为阿里云中央仓库]]></title>
    <url>%2Fpost%2F87881984.html</url>
    <content type="text"><![CDATA[前言maven仓库默认在国外，使用难免很慢，尤其是下载依赖的时候，换为国内镜像，让你感受飞一般的感觉。国内支持maven镜像的有阿里云，开源中国等，这里换为阿里云的。 更换修改maven配置文件settings.xml (当然也可以在用户home目录.m2下面添加一个settings.xml文件) $ cd $M2_HOME/conf/ $ sudo vim settings.xml12345678910在中加入 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mirror&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;id&gt;nexus-aliyun&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;id&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;mirrorOf&gt;central&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mirrorOf&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;name&gt;Nexus aliyun&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;name&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;url&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;mirror&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 保存即可。 ## 结束语 好了，开始享受100倍下载速度吧]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目碰到"‘webpack-dev-server’不是内部或外部命令，也不是可运行的程序或批处理文件"报错]]></title>
    <url>%2Fpost%2Fe9348c48.html</url>
    <content type="text"><![CDATA[最近公司里做vue项目，svn了前端同事的项目代码，装好环境，运行项目（安装步骤随便百度一下，很详细），控制台里报错“‘webpack-dev-server’不是内部或外部命令，也不是可运行的程序或批处理文件，随机百度解决方法，有的说需要重新装依赖包，有的说扩展用户权限，都做了，但是报错依旧。 原因： 随机自己新建一个vue项目（https://segmentfault.com/a/1190000009871504），发现没有报错，于是可以肯定是svn下来的项目代码有问题， 解决办法： 最后将项目里的“node_modules”文件夹删除，然后在cmd中cd到项目目录，依次运行命令：npm install和npm run build，最后运行npm run dev后项目成功运行。]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql启动报错cannot allocate memory for the buffer pool处理]]></title>
    <url>%2Fpost%2F2a08fb3a.html</url>
    <content type="text"><![CDATA[今天启动mysql服务器时失败了。去/var/log/mysql/查看error.log，报错信息如下： 160123 22:29:26 InnoDB: Initializing buffer pool, size = 200.0M InnoDB: mmap(214630400 bytes) failed; errno 12160123 22:29:26 InnoDB: Completed initialization of buffer pool 160123 22:29:26 InnoDB: Fatal error: cannot allocate memory for the buffer pool 原来是无法给innodb分配足够的内存， 我的阿里云服务器是最低配的，总共就500M内存，于是到/etc/mysql/my.cnf中改了如下选项： innodb_buffer_pool_size=50M 再重新运行/etc/init.d/mysql start就成功了。 看来需要好好学习一下mysqll]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费桌面视频录像工具OBS的简单操作介绍]]></title>
    <url>%2Fpost%2F11bb85fd.html</url>
    <content type="text"><![CDATA[本帖最后由 felix0911 于 2014-5-21 09:32 编辑0起点，傻瓜操作，为什么不尝试录制一个自己的游戏视频，来展现自己牛逼风骚的操作呢？(本教学不包括后期制作，特效背景音乐等部分） 视频录制程序Open Broadcaster Software OBS对于很多经常接触实况直播主的玩家来说肯定不能再熟。良好亲民的操作性，完全免费的程序，上佳的录像质量，生成文件无需特别转码可以直接被各大视频网站接收，使得frap、屏幕录像专家、Camtasia Studio之类的收费共享软件可以直接搬去大街上睡了。不会英文的玩家也不用担心，OBS官网提供的就是国际版，可以自行更改语言。1.1 下载与安装 (地球人都明白的就不累赘了）https://obsproject.com/download 点击绿色download下载安装程序&lt;ignore_js_op&gt;1.2 配置程序&lt;ignore_js_op&gt;安装完成首先进入的应该是这样的程序界面，&lt;ignore_js_op&gt;我们选中第二个按钮settings（选项）&lt;ignore_js_op&gt;在language(语言)选单里找中文，确定之后重启。&lt;ignore_js_op&gt;然后就可以继续我们的初始配置了1.3 一般&lt;ignore_js_op&gt;我们在这里不需要做太多的更改，设定档名称 指的是你这个设定档配置的名称，因为这个版本不支持多个设定档添加的内容所以不做更改也无所谓去掉 显示日志窗口 的选项可以不用在每次开启时花时间去关掉日志，没有理由不去掉吧。1.4 编码&lt;ignore_js_op&gt;编码部分，主要影响的是采样数据，比特率越高采得视频数据就越清晰，音频就越自然。这个数值其实是为在线视频直播准备的，因为采样率直接影响传输数据大小，设定合理采样率对一个在线直播播放播主非常重要，通常会根据网络和供应商提供的数据进行设定，扯的比较远。我们可以跳过这个条目1.5 广播设定&lt;ignore_js_op&gt;初始设定是默认为在线直播模式，我们录制单机视频需要将模式切换到“只输出文件”选项&lt;ignore_js_op&gt;档案路径 就是录制结束后视频存放的地点和名称1.5 广播设定&lt;ignore_js_op&gt;基本解析度 就是你希望录制视频原始未压缩的视频的清晰度，低清：640480 即我们所说的480P 普清：1280720 即我们所说的720P 高清：19201080 即我们所说的1080P 视网络情况及硬件能力自行设定，我一般选720P的普清 压缩分辨率 指实际显示的视频大小，真实大小还是按照你在基本解析率里设定的大小，实际大小小于基本解析率设定的大小之后，多出部分会按黑边显示，所以建议设定“无”即不压缩 FPS 即我们所说的视频帧数，所谓：D3野蛮人一个完整投掷动作花费40F的F指的就是这个概念，通常电影电视都会以60帧每秒的形式呈现，每秒30帧以上人眼就感觉不到钝滞感了。这个值会影响到视频的流畅清晰度，建议设定60帧 启用时停用Aero Aero就是win7 vista的毛玻璃特效，勾选可以大幅减少录制视频时的计算机的计算，减少CPU负荷1.6 音效/高级/麦克风噪音闸不需要做出额外设置，使用初始值就好2.1 录像准备&lt;ignore_js_op&gt;场景：录制多个目标时需要设置这个选项来更改录制目标，我们可以不用管来源：录制对象。我们需要选择建立一个游戏源 选项卡来对付D3&lt;ignore_js_op&gt;来源栏空白处右键，添加—游戏源&lt;ignore_js_op&gt;应用程序里选中diablo3 确定 也可以是你想录的任何游戏，录制游戏使用游戏源特制的插件效果会更好&lt;ignore_js_op&gt;单击麦克风或者扬声器图标可以禁止录制过程中的麦克风声音或者内置音乐被录制进视频，当然如果你想要保留解说，你可以适当调低内置音乐的声音；或者像我一样录制展示视频，直接禁用麦克风的声音。2.2 录制&lt;ignore_js_op&gt;在设定里勾选“总是在最上层”，确保你可以直接对它面板进行操作&lt;ignore_js_op&gt;全部准备妥当之后，点击 开始录制 ，当缩略视频出现之后就表示程序正常工作了，&lt;ignore_js_op&gt;全部录制结束的时候，点击 停止录制 *视频就完成了。最后在开始设定的目录下寻找录制完成的视频，观察效果然后上传整个步骤就全部完成了。你也打算录一个视频来为自己的帖子增光添彩吗？试试OBS吧，你不会失望的]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS7下zip解压和unzip压缩文件]]></title>
    <url>%2Fpost%2F169b92a0.html</url>
    <content type="text"><![CDATA[1、安装zip、unzip应用。 1yum install zip unzip 2、压缩和解压文件 以下命令均在/home目录下操作 cd /home #进入/home目录 a、把/home目录下面的mydata目录压缩为mydata.zip zip -r mydata.zip mydata #压缩mydata目录 b、把/home目录下面的mydata.zip解压到mydatabak目录里面 unzip mydata.zip -d mydatabak c、把/home目录下面的abc文件夹和123.txt压缩成为abc123.zip zip -r abc123.zip abc 123.txt d、把/home目录下面的wwwroot.zip直接解压到/home目录里面 unzip wwwroot.zip e、把/home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到/home目录里面 unzip abc*.zip f、查看把/home目录下面的wwwroot.zip里面的内容 unzip -v wwwroot.zip g、验证/home目录下面的wwwroot.zip是否完整 unzip -t wwwroot.zip h、把/home目录下面wwwroot.zip里面的所有文件解压到第一级目录 unzip -j wwwroot.zip]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>zip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch客户端注解使用介绍]]></title>
    <url>%2Fpost%2Fbad2908a.html</url>
    <content type="text"><![CDATA[The best elasticsearch highlevel java rest api—–bboss 1.ElasticSearch客户端bboss提供了一系列注解@ESId 用于标识实体对象中作为docid的属性，该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，默认为true-保存，false不保存，字段名称为属性名称。ESId可用于添加和修改文档 @ESParentId 用于标识实体对象中作为parentid的属性，该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，默认为true-保存，false不保存，字段名称为属性名称。ESParentId可用于添加和修改文档 @ESVersion 用于标识实体对象中作为文档版本信息的属性，该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，true-保存，默认为false不保存，字段名称为属性名称。ESVersion可用于添加/修改文档操作 @ESVersionType 用于标识实体对象中作为文档版本类型信息的属性，该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，true-保存，默认为false不保存，字段名称为属性名称。ESVersionType可用于添加/修改文档操作 @ESRetryOnConflict 用于标识实体对象中作为文档修改操作版本冲突重试次数信息的属性，数字类型。该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，true-保存，默认为false不保存，字段名称为属性名称。ESRetryOnConflict可用于添加/修改文档操作 @ESRouting 用于标识实体对象中作为文档添加/修改操作路由信息的属性，字符串或者数字类型。该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，true-保存，默认为false不保存，字段名称为属性名称。ESRouting可用于添加/修改文档操作 @ESDocAsUpsert 用于标识实体对象中控制文档修改操作时，文档不存在时是否添加文档的信息的属性，布尔值。该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，true-保存，默认为false不保存，字段名称为属性名称。ESDocAsUpsert可用于添加/修改文档操作 @ESSource 用于标识实体对象中控制文档修改操作时，返回值是否包含文档source数据的控制变量的属性，布尔值。该注解只有一个persistent 布尔值属性，用于控制被本注解标注的字段属性是否作为普通文档属性保存，true-保存，默认为false不保存，字段名称为属性名称。ESSource可用于修改文档操作 @Column 该注解用于指定日期格式，和JsonFormat属性结合一起使用： @JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss.SSS”) @Column(dataformat = “yyyy-MM-dd HH:mm:ss.SSS”)123456789101112131415161718192021222324@JsonIgnore 标注实体属性不作为es字段保存，使用示例：@JsonIgnore private Integer sqlEndElapsed; # 2.注解的使用示例 &lt;pre class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@ESId(persistent = &lt;span class=&quot;hljs-keyword&quot;&gt;false) &lt;span class=&quot;hljs-keyword&quot;&gt;protected String id; &lt;span class=&quot;hljs-meta&quot;&gt;@ESParentId &lt;span class=&quot;hljs-keyword&quot;&gt;protected String parentId; &lt;span class=&quot;hljs-meta&quot;&gt;@ESVersion &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;int version; &lt;span class=&quot;hljs-meta&quot;&gt;@ESVersionType &lt;span class=&quot;hljs-keyword&quot;&gt;protected String versionType; &lt;span class=&quot;hljs-meta&quot;&gt;@ESRetryOnConflict &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;int retryOnConflict; &lt;span class=&quot;hljs-meta&quot;&gt;@ESRouting &lt;span class=&quot;hljs-keyword&quot;&gt;protected String routing; &lt;span class=&quot;hljs-meta&quot;&gt;@ESDocAsUpsert &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;boolean docAsUpsert; &lt;span class=&quot;hljs-meta&quot;&gt;@ESSource &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;boolean returnSource;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; # 3.结合控制注解的批量文档修改操作 &lt;pre class=&quot;hljs cs&quot;&gt;&lt;code class=&quot;language-java hljs&quot;&gt; &lt;span class=&quot;hljs-meta&quot;&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;span class=&quot;hljs-function&quot;&gt; &lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;testOrmBulk&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;){ ClientInterface clientUtil = ElasticSearchHelper.getRestClientUtil(); List&lt;OnlineGoodsInfoUpdateParams&gt; onlineGoodsInfoUpdateParamss = &lt;span class=&quot;hljs-keyword&quot;&gt;new ArrayList&lt;&gt;(); OnlineGoodsInfoUpdateParams onlineGoodsInfoUpdateParams = &lt;span class=&quot;hljs-keyword&quot;&gt;new OnlineGoodsInfoUpdateParams(); onlineGoodsInfoUpdateParams.setId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;); onlineGoodsInfoUpdateParams.setParentId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ppaa&quot;); onlineGoodsInfoUpdateParams.setType(&lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;); onlineGoodsInfoUpdateParams.setIndex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ddd&quot;); onlineGoodsInfoUpdateParams.setGoodsName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dddd&quot;); onlineGoodsInfoUpdateParams.setDocAsUpsert(&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true); onlineGoodsInfoUpdateParams.setRetryOnConflict(&lt;span class=&quot;hljs-number&quot;&gt;3); onlineGoodsInfoUpdateParams.setReturnSource(&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true); onlineGoodsInfoUpdateParams.setRouting(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;); onlineGoodsInfoUpdateParams.setVersion(&lt;span class=&quot;hljs-number&quot;&gt;1); onlineGoodsInfoUpdateParams.setVersionType(ClientInterface.VERSION_TYPE_INTERNAL); onlineGoodsInfoUpdateParamss.add(onlineGoodsInfoUpdateParams); onlineGoodsInfoUpdateParams = &lt;span class=&quot;hljs-keyword&quot;&gt;new OnlineGoodsInfoUpdateParams(); onlineGoodsInfoUpdateParams.setId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;); onlineGoodsInfoUpdateParams.setParentId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ppaa&quot;); onlineGoodsInfoUpdateParams.setType(&lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;); onlineGoodsInfoUpdateParams.setIndex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ddd&quot;); onlineGoodsInfoUpdateParams.setGoodsName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dddd&quot;); &lt;span class=&quot;hljs-comment&quot;&gt;/** * 设置更新文档控制变量 */ onlineGoodsInfoUpdateParams.setDocAsUpsert(&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true); onlineGoodsInfoUpdateParams.setRetryOnConflict(&lt;span class=&quot;hljs-number&quot;&gt;3); onlineGoodsInfoUpdateParams.setReturnSource(&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;true); onlineGoodsInfoUpdateParams.setRouting(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;); onlineGoodsInfoUpdateParams.setVersion(&lt;span class=&quot;hljs-number&quot;&gt;1); onlineGoodsInfoUpdateParams.setVersionType(ClientInterface.VERSION_TYPE_INTERNAL); onlineGoodsInfoUpdateParamss.add(onlineGoodsInfoUpdateParams); String response = clientUtil.updateDocuments(&lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;,onlineGoodsInfoUpdateParamss); System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(response); }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678 我们可以看到执行updateDocuments方法时，生成的原生bulk报文如下，注意其中的控制参数信息：&lt;pre class=&quot;hljs json&quot;&gt;&lt;code class=&quot;language-json hljs&quot;&gt;&#123; &lt;span class=&quot;hljs-attr&quot;&gt;&quot;update&quot; : &#123; &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_index&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_type&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_id&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;parent&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;ppaa&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_routing&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;retry_on_conflict&quot;:&lt;span class=&quot;hljs-number&quot;&gt;3,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;_version&quot;:&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;_version_type&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;internal&quot; &#125; &#125;&#123;&lt;span class=&quot;hljs-attr&quot;&gt;&quot;doc&quot;:&#123;&lt;span class=&quot;hljs-attr&quot;&gt;&quot;parentId&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;ppaa&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;type&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;index&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;ddd&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;routing&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;goodsName&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;dddd&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;brandId&quot;:&lt;span class=&quot;hljs-number&quot;&gt;0,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;brandName&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;shopCustomCategoryId&quot;:&lt;span class=&quot;hljs-number&quot;&gt;0,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;goodsType&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;quantityOfPacking&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;freePostage&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;postage&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;goodsDescription&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;packingDescription&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;salesUnit&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;minimumUnit&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;minSalesPrice&quot;:&lt;span class=&quot;hljs-number&quot;&gt;0.0&#125;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;doc_as_upsert&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;true,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;_source&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;true&#125;&#123; &lt;span class=&quot;hljs-attr&quot;&gt;&quot;update&quot; : &#123; &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_index&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_type&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_id&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;parent&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;ppaa&quot;, &lt;span class=&quot;hljs-attr&quot;&gt;&quot;_routing&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;retry_on_conflict&quot;:&lt;span class=&quot;hljs-number&quot;&gt;3,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;_version&quot;:&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;_version_type&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;internal&quot; &#125; &#125;&#123;&lt;span class=&quot;hljs-attr&quot;&gt;&quot;doc&quot;:&#123;&lt;span class=&quot;hljs-attr&quot;&gt;&quot;parentId&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;ppaa&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;type&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;tt&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;index&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;ddd&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;routing&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;goodsName&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;dddd&quot;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;brandId&quot;:&lt;span class=&quot;hljs-number&quot;&gt;0,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;brandName&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;shopCustomCategoryId&quot;:&lt;span class=&quot;hljs-number&quot;&gt;0,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;goodsType&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;quantityOfPacking&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;freePostage&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;postage&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;goodsDescription&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;packingDescription&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;salesUnit&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;minimumUnit&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;null,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;minSalesPrice&quot;:&lt;span class=&quot;hljs-number&quot;&gt;0.0&#125;,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;doc_as_upsert&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;true,&lt;span class=&quot;hljs-attr&quot;&gt;&quot;_source&quot;:&lt;span class=&quot;hljs-literal&quot;&gt;true&#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; reponse报文这里不做介绍，如果被标准的returnSource属性为true，那么在response中将包含文档的source字段信息。 # 4.参考资料 https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docs-bulk.html https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docs-update.html https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docs-index_.html https://my.oschina.net/bboss/blog/1556866 https://my.oschina.net/bboss/blog/1801273]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue2.0路由-适合刚接触新手简单理解]]></title>
    <url>%2Fpost%2Faea0d8fe.html</url>
    <content type="text"><![CDATA[vue路由:vue-router vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。 下载方式:npm install vue-router html: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue路由&lt;/title&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; &lt;router-link to=&quot;/news&quot;&gt;新闻&lt;/router-link&gt; &lt;router-link to=&apos;/about&apos;&gt;关于&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript: 1234567891011121314151617181920212223242526272829&lt;script&gt; //组件 const Home = &#123; template:&apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; const News = &#123; template:&apos;&lt;h3&gt;我是新闻&lt;/h3&gt;&apos; &#125; const About = &#123; template:&apos;&lt;h3&gt;我是关于&lt;/h3&gt;&apos; &#125; //配置路由 const routes = [ &#123;path:&apos;/home&apos;, component :Home&#125;, &#123;path:&apos;/news&apos;, component:News&#125;, &#123;path:&apos;/about&apos;,component:About&#125;, //重定向 &#123;path:&apos;*&apos;,redirect:&apos;/home&apos;&#125; ] //生成路由实例 const router = new VueRouter(&#123; routes &#125;) //挂载到vue上 new Vue(&#123; router, el:&apos;#box&apos; &#125;)&lt;/script&gt; CSS: 1234567&lt;style&gt; .router-link-active&#123; background: #ccc; padding: 5px; text-decoration: none; &#125;&lt;/style&gt; 总体: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue路由&lt;/title&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .router-link-active&#123; background: #ccc; padding: 5px; text-decoration: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; &lt;router-link to=&quot;/news&quot;&gt;新闻&lt;/router-link&gt; &lt;router-link to=&apos;/about&apos;&gt;关于&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //组件 const Home = &#123; template:&apos;&lt;h3&gt;我是主页&lt;/h3&gt;&apos; &#125;; const News = &#123; template:&apos;&lt;h3&gt;我是新闻&lt;/h3&gt;&apos; &#125; const About = &#123; template:&apos;&lt;h3&gt;我是关于&lt;/h3&gt;&apos; &#125; //配置路由 const routes = [ &#123;path:&apos;/home&apos;, component :Home&#125;, &#123;path:&apos;/news&apos;, component:News&#125;, &#123;path:&apos;/about&apos;,component:About&#125;, //重定向 &#123;path:&apos;*&apos;,redirect:&apos;/home&apos;&#125; ] //生成路由实例 const router = new VueRouter(&#123; routes &#125;) //挂载到vue上 new Vue(&#123; router, el:&apos;#box&apos; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-自定义组件传值]]></title>
    <url>%2Fpost%2F15e52425.html</url>
    <content type="text"><![CDATA[项目中，我们经常会遇到自定义组件传值的问题，方法很多种，但是原理很简单，下述文档总结实际项目中使用的传值方式。 父组件传递给子组件某一值，子组件内会修改该值，然后父组件需要获取新值 ​ 在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop给子组件下发数据，子组件通过事件给父组件发送消息。 常规prop-event父组件 &lt;prop-event-value :address=“address” @update=“val =&gt; address = val” key=“4”&gt;&lt;/prop-event-value&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;span class=&quot;javascript&quot;&gt; import propEventValue from &lt;span class=&quot;hljs-string&quot;&gt;&apos;./components/prop-event-value.vue&apos; export &lt;span class=&quot;hljs-keyword&quot;&gt;default { name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;app&apos;, components: { propEventValue }, data() { &lt;span class=&quot;hljs-keyword&quot;&gt;return { address: &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos; } } } &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456789101112131415161718192021222324252627子组件 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-vue hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;template&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;div&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;p&gt;prop-event&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;p&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;label &lt;span class=&quot;hljs-attribute&quot;&gt;for=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot;&gt;地址&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;label&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;input &lt;span class=&quot;hljs-attribute&quot;&gt;type=&lt;span class=&quot;hljs-value&quot;&gt;&quot;text&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;id=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;v-model=&lt;span class=&quot;hljs-value&quot;&gt;&quot;tempAddress&quot;&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;div&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;template&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;span class=&quot;javascript&quot;&gt; export &lt;span class=&quot;hljs-keyword&quot;&gt;default &#123; name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;prop-event&apos;, props: [&lt;span class=&quot;hljs-string&quot;&gt;&apos;address&apos;], data() &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return &#123; tempAddress: &lt;span class=&quot;hljs-keyword&quot;&gt;this.address &#125; &#125;, watch: &#123; tempAddress(newVal) &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;this.$emit(&lt;span class=&quot;hljs-string&quot;&gt;&apos;update&apos;, newVal) &#125; &#125; &#125; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 需要注意：不要直接在子组件内操作父组件的内容 ​ 组件实例的作用域是孤立的。每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。如果你这么做了，Vue 会在控制台给出警告。 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript hljs has-numbering&quot;&gt;export &lt;span class=&quot;hljs-keyword&quot;&gt;default { name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;prop-event&apos;, props: [&lt;span class=&quot;hljs-string&quot;&gt;&apos;address&apos;], watch: { address(newVal) { &lt;span class=&quot;hljs-keyword&quot;&gt;this.$emit(&lt;span class=&quot;hljs-string&quot;&gt;&apos;update&apos;, newVal) } } }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;123456789101112131415161718192021222324如将上述代码替换子组件，内容会报错！ ![自定义组件传值-emit](https://img-blog.csdn.net/20171223165403736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlnYW5nMjU4NTExNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) ## 修饰符.sync父组件 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-vue hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;my-sync-value &lt;span class=&quot;hljs-attribute&quot;&gt;:address.sync=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;key=&lt;span class=&quot;hljs-value&quot;&gt;&quot;5&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;my-sync-value&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;span class=&quot;javascript&quot;&gt; import mySyncValue from &lt;span class=&quot;hljs-string&quot;&gt;&apos;./components/my-sync-value.vue&apos; export &lt;span class=&quot;hljs-keyword&quot;&gt;default &#123; name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;app&apos;, components: &#123; mySyncValue &#125;, data() &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return &#123; address: &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos; &#125; &#125; &#125; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 子组件 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-vue hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;template&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;div&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;p&gt;my-sync&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;p&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;label &lt;span class=&quot;hljs-attribute&quot;&gt;for=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot;&gt;地址&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;label&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;input &lt;span class=&quot;hljs-attribute&quot;&gt;type=&lt;span class=&quot;hljs-value&quot;&gt;&quot;text&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;id=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;v-model=&lt;span class=&quot;hljs-value&quot;&gt;&quot;tempAddress&quot;&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;div&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;template&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;span class=&quot;javascript&quot;&gt; export &lt;span class=&quot;hljs-keyword&quot;&gt;default { name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;my-sync&apos;, props: [&lt;span class=&quot;hljs-string&quot;&gt;&apos;address&apos;], data() { &lt;span class=&quot;hljs-keyword&quot;&gt;return { tempAddress: &lt;span class=&quot;hljs-keyword&quot;&gt;this.address } }, watch: { tempAddress(newVal) { &lt;span class=&quot;hljs-comment&quot;&gt;// 必须是这个update:address &lt;span class=&quot;hljs-keyword&quot;&gt;this.$emit(&lt;span class=&quot;hljs-string&quot;&gt;&apos;update:address&apos;, newVal) } } } &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819202122232425262728prop-update:[prop]语法糖，与prop-event对比的优势：父组件无需监听事件`@update=&quot;val =&gt; address = val&quot;`，自动监听update:[prop]事件。 ## 双向数据绑定v-model所以要让组件的 `v-model` 生效，它应该 (从 2.2.0 起是可配置的)： * 接受一个 `value` prop * 在有新的值时触发 `input` 事件并将新值作为参数父组件 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-vue hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;my-vmodel-value &lt;span class=&quot;hljs-attribute&quot;&gt;v-model=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;key=&lt;span class=&quot;hljs-value&quot;&gt;&quot;6&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;my-vmodel-value&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;span class=&quot;javascript&quot;&gt; import myVmodelValue from &lt;span class=&quot;hljs-string&quot;&gt;&apos;./components/my-vmodel-value.vue&apos; export &lt;span class=&quot;hljs-keyword&quot;&gt;default &#123; name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;app&apos;, components: &#123; myVmodelValue &#125;, data() &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return &#123; address: &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos; &#125; &#125; &#125; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 子组件 &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-Vue hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;template&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;div&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;p&gt;my-vmodel&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;p&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;label &lt;span class=&quot;hljs-attribute&quot;&gt;for=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot;&gt;姓名&lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;label&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;input &lt;span class=&quot;hljs-attribute&quot;&gt;type=&lt;span class=&quot;hljs-value&quot;&gt;&quot;text&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;id=&lt;span class=&quot;hljs-value&quot;&gt;&quot;address&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;v-model=&lt;span class=&quot;hljs-value&quot;&gt;&quot;tempAddress&quot;&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;div&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;template&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&lt;&lt;span class=&quot;hljs-title&quot;&gt;script&gt;&lt;span class=&quot;javascript&quot;&gt; export &lt;span class=&quot;hljs-keyword&quot;&gt;default { name: &lt;span class=&quot;hljs-string&quot;&gt;&apos;my-vmodel&apos;, props: [&lt;span class=&quot;hljs-string&quot;&gt;&apos;value&apos;], data() { &lt;span class=&quot;hljs-keyword&quot;&gt;return { tempAddress: &lt;span class=&quot;hljs-keyword&quot;&gt;this.value } }, watch: { tempAddress(newVal) { &lt;span class=&quot;hljs-comment&quot;&gt;// 必须是input &lt;span class=&quot;hljs-keyword&quot;&gt;this.$emit(&lt;span class=&quot;hljs-string&quot;&gt;&apos;input&apos;, newVal) } } } &lt;span class=&quot;hljs-tag&quot;&gt;&lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;12345678910111213141516171819202122prop-input语法糖，父组件v-model默认监听input事件 需要注意，这里必须触发input事件，当然也可以自定v-model属性值和事件，请参照[自定义组件的v-model](https://cn.vuejs.org/v2/guide/components.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model) ## vuex通过store传值，这里后续单独讲述vuex。 ## 单向数据流​ 上述已经提及，在子组件内部改变 prop，Vue会在控制台给出告警。但经常开发周静，我们很容易忍不住修改prop中的数据，如： * Prop 作为初始值传入后，子组件想把它当作局部数据来用； * Prop 作为原始数据传入，由子组件处理成其它数据输出。对这两种情况，正确的应对方式是： 问题1：定义一个局部变量，并用 prop 的值初始化它： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-Javascript hljs javascript has-numbering&quot;&gt;props: [&lt;span class=&quot;hljs-string&quot;&gt;&apos;initialCounter&apos;], data: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-params&quot;&gt;() &#123; &lt;span class=&quot;hljs-keyword&quot;&gt;return &#123; counter: &lt;span class=&quot;hljs-keyword&quot;&gt;this.initialCounter &#125; &#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; 问题2：定义一个计算属性，处理 prop 的值并返回： &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-javascript hljs has-numbering&quot;&gt;props: [&lt;span class=&quot;hljs-string&quot;&gt;&apos;size&apos;], computed: { normalizedSize: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-params&quot;&gt;() { &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this.size.trim().toLowerCase() } }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;``` 特别需要注意：在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sequence在Oracle中的使用]]></title>
    <url>%2Fpost%2F439129a.html</url>
    <content type="text"><![CDATA[Oracle中，当需要建立一个自增字段时，需要用到sequence。sequence也可以在mysql中使用，但是有些差别，日后再补充，先把oracle中sequence的基本使用总结一下，方便日后查阅。 1、创建sequence： [sql] view plain copy1. create sequence SEQ_ON_USER 2. minvalue 13. maxvalue 9999999999999999999999999994. start with 1 5. increment by 1 6. nocache;说明： minvalue：序列最小值 maxvalue/nomaxvalue：序列最大值/没有最大值 start with 1：序列从1开始 increment by 1：每次增加1 cache/nocache：nocache不缓存。cache缓存。开启缓存，效率高，只是如果数据库宕机了，缓存丢失，会出现序列跳号情况。2、查看已有sequence：[sql] view plain copy1. select * from user_sequences; 3、删除指定sequence：[sql] view plain copy1. DROP SEQUENCE SEQ_ON_USER； 4、查看指定sequence的当前值：两种方式：[sql] view plain copy1. select last_number from user_sequences wheresequence_name=‘SEQ_ON_USER’; [sql] view plain copy1. select SEQ_ON_USER.nextval from sys.dual; 5、创建触发器使用sequence设置主键自动插入。[sql] view plain copy1. create or replace trigger “SEQ_ON_USER_GENERATOR” before 2. insert on databasename1.T_USER for each row 3. declare 4. mid number,5. begin 6. select SEQ_ON_USER.nextval into mid from dual; 7. :new.id:=mid;8. end 9.10. create trigger SEQ_ON_USER_Trigger 11.12. before insert on T_USER for each row 13. begin 14. select SEQ_ON_USER.nextval into :new.id from dual; 15. end SEQ_ON_USER_Trigger; 6、代码中使用sequence.nextval插入主键值。]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios post提交的Content-Type]]></title>
    <url>%2Fpost%2Fa688014c.html</url>
    <content type="text"><![CDATA[使用axios的坑jQuery.ajax的post提交默认的请求头的Content-Type: application/x-www-form-urlencoded而axios.post提交的请求头是Content-Type: application/json。 application/json是一个趋势，但是如果改一个旧项目，把jQuery.ajax全部换成axios.post时，需要对请求做一些配置。 改之前的代码： // 没有指定请求头的content-type var data = {age: 18}; $.ajax({ url: ‘’, type: ‘POST’, data: data dataType: ‘json’, success: function(result) { // do something } })` 使用axios的代码 &lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import axios &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;&apos;axios&apos;; &lt;span class=&quot;hljs-keyword&quot;&gt;import qs &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;&apos;qs&apos;; &lt;span class=&quot;hljs-keyword&quot;&gt;var data = {age: &lt;span class=&quot;hljs-number&quot;&gt;18}; &lt;span class=&quot;hljs-keyword&quot;&gt;var url = &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;; axios.post( url, qs.stringify(data), {headers: {&lt;span class=&quot;hljs-string&quot;&gt;&apos;Content-Type&apos;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;application/x-www-form-urlencoded&apos;}} ).then(result =&gt; { &lt;span class=&quot;hljs-comment&quot;&gt;// do something })&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;```&lt;/pre&gt;]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6和CentOS 7防火墙的关闭]]></title>
    <url>%2Fpost%2Fa50aed64.html</url>
    <content type="text"><![CDATA[CentOS6.5查看防火墙的状态： 1[linuxidc@localhost ~]$service iptable status 显示结果：12345[linuxidc@localhost ~]$service iptable statusRedirecting to /bin/systemctl status iptable.service● iptable.service Loaded: not-found (Reason: No such file or directory) Active: inactive (dead) –表示防火墙已经关闭 CentOS 6.5关闭防火墙12[root@localhost ~]#servcie iptables stop –临时关闭防火墙[root@localhost ~]#chkconfig iptables off –永久关闭防火墙 CentOS 7.2关闭防火墙CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙步骤。firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）12[root@localhost ~]#firewall-cmd –statenot running 检查防火墙的状态：从centos7开始使用systemctl来管理服务和程序，包括了service和chkconfig。12[root@localhost ~]#systemctl list-unit-files|grep firewalld.service –防火墙处于关闭状态firewalld.service disabled 或者1234[root@localhost ~]#systemctl status firewalld.service● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) 关闭防火墙：systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动12[root@localhost ~]#systemctl stop firewalld.service[root@localhost ~]#systemctl disable firewalld.service12345678启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service;echo $?查看已启动的服务列表：systemctl list-unit-files|grep enabled## Centos 7 firewall 命令：查看已经开放的端口：firewall-cmd –list-ports1234开启端口 &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs brainfuck has-numbering&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;firewall&lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-comment&quot;&gt;cmd &lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-comment&quot;&gt;zone=public &lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-comment&quot;&gt;add&lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-comment&quot;&gt;port=80/tcp &lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-literal&quot;&gt;-&lt;span class=&quot;hljs-comment&quot;&gt;permanent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;命令含义：–zone #作用域–add-port=80/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效重启防火墙 firewall-cmd –reload #重启firewall systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）12345678 ## CentOS 7 以下版本 iptables 命令如要开放80，22，8080 端口，输入以下命令即可 &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs lasso has-numbering&quot;&gt;/sbin/iptables &lt;span class=&quot;hljs-attribute&quot;&gt;-I INPUT &lt;span class=&quot;hljs-attribute&quot;&gt;-p tcp &lt;span class=&quot;hljs-subst&quot;&gt;--dport &lt;span class=&quot;hljs-number&quot;&gt;80 &lt;span class=&quot;hljs-attribute&quot;&gt;-j ACCEPT /sbin/iptables &lt;span class=&quot;hljs-attribute&quot;&gt;-I INPUT &lt;span class=&quot;hljs-attribute&quot;&gt;-p tcp &lt;span class=&quot;hljs-subst&quot;&gt;--dport &lt;span class=&quot;hljs-number&quot;&gt;22 &lt;span class=&quot;hljs-attribute&quot;&gt;-j ACCEPT /sbin/iptables &lt;span class=&quot;hljs-attribute&quot;&gt;-I INPUT &lt;span class=&quot;hljs-attribute&quot;&gt;-p tcp &lt;span class=&quot;hljs-subst&quot;&gt;--dport &lt;span class=&quot;hljs-number&quot;&gt;8080 &lt;span class=&quot;hljs-attribute&quot;&gt;-j ACCEPT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;然后保存： /etc/rc.d/init.d/iptables save1234查看打开的端口： &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs avrasm has-numbering&quot;&gt;/etc/init&lt;span class=&quot;hljs-preprocessor&quot;&gt;.d/iptables status&lt;/span&gt;&lt;/code&gt;关闭防火墙1） 永久性生效，重启后不会复原开启： chkconfig iptables on关闭： chkconfig iptables off2） 即时生效，重启后复原开启： service iptables start关闭： service iptables stop查看防火墙状态： service iptables status下面说下CentOS7和6的默认防火墙的区别CentOS 7默认使用的是firewall作为防火墙，使用iptables必须重新设置一下1、直接关闭防火墙systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动2、设置 iptables serviceyum -y install iptables-services如果要修改防火墙配置，如增加防火墙端口3306vi /etc/sysconfig/iptables增加规则-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT保存退出后systemctl restart iptables.service #重启防火墙使配置生效systemctl enable iptables.service #设置防火墙开机启动最后重启系统使设置生效即可。systemctl start iptables.service #打开防火墙systemctl stop iptables.service #关闭防火墙 ### 解决主机不能访问虚拟机CentOS中的站点 前阵子在虚拟机上装好了CentOS6.2，并配好了apache+php+mysql，但是本机就是无法访问。一直就没去折腾了。 具体情况如下&gt; 1. 本机能ping通虚拟机&gt; 2. 虚拟机也能ping通本机&gt; 3.虚拟机能访问自己的web&gt; 4.本机无法访问虚拟机的web&gt;&gt; &lt;div&gt; &lt;div&gt;后来发现是**防火墙将80端口屏蔽了的缘故。** &lt;div&gt; &lt;div&gt;检查是不是服务器的80端口被防火墙堵了，可以通过命令：telnet server_ip 80 来测试。 &lt;div&gt; &lt;div&gt;解决方法如下： /sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT &lt;div&gt;然后保存： /etc/rc.d/init.d/iptables save &lt;div&gt;重启防火墙 /etc/init.d/iptables restart &lt;div&gt; &lt;div&gt;CentOS防火墙的关闭，关闭其服务即可： 查看CentOS防火墙信息：/etc/init.d/iptables status 关闭CentOS防火墙服务：/etc/init.d/iptables stop]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos后台运行jar]]></title>
    <url>%2Fpost%2F78a5faa3.html</url>
    <content type="text"><![CDATA[## jar后台运行nohup java -jar xx.jar &gt;/dev/null &amp;123456789101112 * 1&gt; 此处的“&gt;/dev/null”作用是将终端输出信息输出到空洞中，即不保存输出信息，若要查看输出信息需指定输出到那个文件，例如“&gt;/xxx/yyy.out”&gt; &gt; * * * ## 关闭后台进程先查看后台进程pid &lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;hljs dos has-numbering&quot;&gt;ps -&lt;span class=&quot;hljs-stream&quot;&gt;aux&lt;/span&gt;&lt;/code&gt; 1记住进程pid，然后kill命令关闭 kill [pid]` 1 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/pwc1996/article/details/48913063]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS查询端口占用和清除端口占用的程序]]></title>
    <url>%2Fpost%2Fa3fd360d.html</url>
    <content type="text"><![CDATA[1、查询端口号占用，根据端口查看进程信息 [root@server2 ~]# lsof -i:80COMMAND PID USER FD TYPE DEVICE SIZE NODE NAMEhttpd 5014 root 3u IPv4 14346 TCP server2:http (LISTEN)2、根据进程号查看进程对应的可执行程序ps -f -p 进程号 ps -f -p 5014UID PID PPID C STIME TTY TIME CMDroot 5014 1 0 17:26 ? 00:00:00 /usr/local/apache/bin/httpd -k3、根据可执行程序查看动态链接ldd 可执行文件名 ldd /usr/local/apache/bin/httpd linux-vdso.so.1 =&gt; (0x00007fff9dc90000) libaprutil-0.so.0 =&gt; /usr/local/apache/lib/libaprutil-0.so.0 (0x00002af026fcd000)4、根据端口号得到其占用的进程的详细信息 netstat -tlnp|grep 80tcp 0 0 192.168.33.10:80 0.0.0.0: LISTEN 5014/httpdtcp 0 0 0.0.0.0:48054 0.0.0.0: LISTEN 5386/java 这一步骤等于刚才上面的一二两个步骤 5、根据端口号查询，查询其占用进程ID netstat -tlnp|grep 80|awk ‘{print 7}’|awk -F ‘/‘ ‘{print1}’5014或则是用下面的命令 netstat -pan|grep 80 NETSTAT [-a] [-b] [-e] [-n] [-o] [-p proto] [-r] [-s] [-v] [interval]-a 显示所有连接和监听端口。-b 显示包含于创建每个连接或监听端口的可执行组件。在某些情况下已知可执行组件拥有多个独立组件，并且在这些情况下包含于创建连接或监听端口的组件序列被显示。这种情况下，可执行组件名 在底部的 []中，顶部是其调用的组件，等等，直到 TCP/IP 部分。注意此选项 可能需要很长时间，如果没有足够权限可能失败。 -e 显示以太网统计信息。此选项可以与 -s选项组合使用。-n 以数字形式显示地址和端口号。-o 显示与每个连接相关的所属进程 ID。-pproto 显示 proto 指定的协议的连接；proto 可以是下列协议之一: TCP、UDP、TCPv6 或UDPv6。 如果与 -s 选项一起使用以显示按协议统计信息，proto 可以是下列协议之一:IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。-r 显示路由表。-s 显示按协议统计信息。默认地，显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；-p 选项用于指定默认情况的子集。-v 与 -b 选项一起使用时将显示包含于 为所有可执行组件创建连接或监听端口的组件。interval 重新显示选定统计信息，每次显示之间 暂停时间间隔(以秒计)。按 CTRL+C 停止重新 显示统计信息。如果省略，netstat 显示当前 配置信息(只显示一次) 6、一次性的清除占用80端口的程序 lsof -i :80|grep -v “PID”|awk ‘{print “kill -9”,$2}’|sh 7、手工终止进程的运行 kill 5014如果终止不了，可以强制终止kill -9 5014lsof -i:80]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Maven 打包可执行Jar文件！]]></title>
    <url>%2Fpost%2F9ebb6412.html</url>
    <content type="text"><![CDATA[Maven pom.xml 必须包含 [plain] view plain copy1. jar[html] view plain copy1. &lt;build&gt; 2. &lt;plugins&gt; 3. &lt;plugin&gt; 4. &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 5. &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; 6. &lt;configuration&gt; 7. &lt;fork&gt;true&lt;/fork&gt; 8. &lt;/configuration&gt; 9. &lt;/plugin&gt; 10. &lt;/plugins&gt; 11. &lt;/build&gt; 完整pox.xml[html] view plain copy1. &lt;project xmlns=“http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance&quot; 2. xsi:schemaLocation=“http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; 3. &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 4.5. &lt;groupId&gt;com.feedback&lt;/groupId&gt; 6. &lt;artifactId&gt;feedback-service&lt;/artifactId&gt; 7. &lt;version&gt;0.1.0&lt;/version&gt; 8. &lt;packaging&gt;jar&lt;/packaging&gt; 9.10. &lt;properties&gt; 11. &lt;java.version&gt;1.8&lt;/java.version&gt; 12. &lt;/properties&gt; 13.14. &lt;parent&gt; 15. &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 16. &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; 17. &lt;version&gt;1.3.0.RELEASE&lt;/version&gt; 18. &lt;/parent&gt; 19.20. &lt;dependencies&gt; 21. 22. &lt;dependency&gt; 23. &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 24. &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 25. &lt;/dependency&gt; 26. &lt;dependency&gt; 27. &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 28. &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; 29. &lt;/dependency&gt; 30.31. 32. &lt;dependency&gt; 33. &lt;groupId&gt;mysql&lt;/groupId&gt; 34. &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; 35. &lt;/dependency&gt; 36.37. 38. &lt;dependency&gt; 39. &lt;groupId&gt;commons-lang&lt;/groupId&gt; 40. &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; 41. &lt;version&gt;2.6&lt;/version&gt; 42. &lt;/dependency&gt; 43. &lt;/dependencies&gt; 44.45. 46. &lt;build&gt; 47. &lt;plugins&gt; 48. &lt;plugin&gt; 49. &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 50. &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; 51. &lt;configuration&gt; 52. &lt;fork&gt;true&lt;/fork&gt; 53. &lt;/configuration&gt; 54. &lt;/plugin&gt; 55. &lt;/plugins&gt; 56. &lt;/build&gt; 57. &lt;/project&gt; 进入到项目目录下运行：mvn clean package会在项目目录下target文件夹中生成jar如上生成的jar文件在：D:\programmer\eclipse\feedback-service\target 文件夹中java -jar 运行jar包 即可java -jar 运行jar包时使用外部配置文件application.propertieslinux下执行jar[plain] view plain copy1. nohup java -Xmx512M -Xms512M -Djava.security.egd=/dev/urandom -jar message-service-1.0-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;1 &amp;Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。 &gt;/dev/null 2&gt;&amp;1注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-)]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql 5.7安装（随机密码，修改默认密码）两个坑]]></title>
    <url>%2Fpost%2Fa89c6a9b.html</url>
    <content type="text"><![CDATA[MySql 5.7安装（随机密码，修改默认密 下载了MySql 最新版本，安装的过程中，发现了很多新特性1.data目录不见了在进行my-default.ini配置的时候（需要配置 # basedir = C:/Program Files/MySQL/MySQL Server 5.7.11# datadir = C:/Program Files/MySQL/MySQL Server 5.7.11/data）细心的同学会发现，/data这个目录不存在，但是这个data目录可不是我们手动创建的，根据官方指南C:/&gt;bin/mysqld --initializeC:/&gt;bin/mysqld --initialize-insecurecmd中输入这两个代码中的一个就可以自动在对应的目录下生成啦（前提是你的path配置正确，比如mysql的路径，如果提示net命令不是内部命令，就在path中增加“C:/Windows/System32”即可）2.随机生成了一个random string 作为密码在没有启动前，root的密码是ABC123xyz随机生成的密码在日志文件中可以查看，没错就是在initialize命令下生成的那个data文件使用记事本打开Acer.err找到“2016-02-12T15:35:00.026880Z 1 [Note] A temporary password is generated for root@localhost: Ux&lt;&lt;lCbrr8&amp;d”Ux&lt;&lt;lCbrr8&amp;d这个就是我们要找的密码了登陆成功：3.修改密码的指令果然新版本中修改密码的指令也不是那么好找的。。在成功连接之后，使用sql语句修改，以往未登录状态下的修改方法已经不能使用啦~~mysql&gt; new_password&#39;;`修改成功： 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/quentain/article/details/51543991码）两个坑]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6.8 mysql5.6.34 root密码重置]]></title>
    <url>%2Fpost%2Facd01cbe.html</url>
    <content type="text"><![CDATA[1.关闭正在运行的MySQL service mysql stop 2.启动MySQL的安全模式 mysqld_safe –skip-grant-tables 等1分钟如果还没返回的话，新开shell执行以下语句 3.使用root用户[免密码]登陆MySQL mysql -u root -p 输入密码时,直接回车 4.选择MySQL系统库 use mysql 5.查看当前系统用户root的密码 select user,host,password from user where user=“root” 查看的password是经过加密的 6.修改root用户的密码 update user set password=PASSWORD(“your_password”) where user=“root” 7.刷新一下系统的权限 flush privileges; 8.重新启动mysql service mysql restart]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
