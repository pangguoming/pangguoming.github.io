<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JavaScript,面向对象,">








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.1.2">






<meta name="description" content="前言当今 JavaScript 大行其道，各种应用对其依赖日深。web 程序员已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够">
<meta name="keywords" content="JavaScript,面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="全面理解面向对象的 JavaScript">
<meta property="og:url" content="http://pangguoming.com/blog/2014/10/14/全面理解面向对象的 JavaScript/index.html">
<meta property="og:site_name" content="庞国明-博客">
<meta property="og:description" content="前言当今 JavaScript 大行其道，各种应用对其依赖日深。web 程序员已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/image001.png">
<meta property="og:image" content="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/image003.png">
<meta property="og:updated_time" content="2019-01-26T15:14:00.161Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="全面理解面向对象的 JavaScript">
<meta name="twitter:description" content="前言当今 JavaScript 大行其道，各种应用对其依赖日深。web 程序员已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够">
<meta name="twitter:image" content="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/image001.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pangguoming.com/blog/2014/10/14/全面理解面向对象的 JavaScript/">





  <title>全面理解面向对象的 JavaScript | 庞国明-博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">庞国明-博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">此心用度八千遍，不曾厌倦</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pangguoming.com/blog/blog/2014/10/14/全面理解面向对象的 JavaScript/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="庞国明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/7269202?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="庞国明-博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">全面理解面向对象的 JavaScript</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-10-14T14:25:00+08:00">
                2014-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当今 JavaScript 大行其道，各种应用对其依赖日深。web 程序员已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够的表现。要掌握好 JavaScript，首先一点是必须摒弃一些其他高级语言如 Java、C# 等类式面向对象思维的干扰，全面地从函数式语言的角度理解 JavaScript 原型式面向对象的特点。把握好这一点之后，才有可能进一步使用好这门语言。本文适合群体：使用过 JS 框架但对 JS 语言本质缺乏理解的程序员，具有 Java、C++ 等语言开发经验，准备学习并使用 JavaScript 的程序员，以及一直对 JavaScript 是否面向对象模棱两可，但希望知道真相的 JS 爱好者。</p>
<h2 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h2><p>为了说明 JavaScript 是一门彻底的面向对象的语言，首先有必要从面向对象的概念着手 , 探讨一下面向对象中的几个概念：</p>
<ul>
<li>一切事物皆对象</li>
<li>对象具有封装和继承特性</li>
<li>对象与对象之间使用消息通信，各自存在信息隐藏</li>
</ul>
<p>以 这三点做为依据，C++ 是半面向对象半面向过程语言，因为，虽然他实现了类的封装、继承和多态，但存在非对象性质的全局函数和变量。Java、C# 是完全的面向对象语言，它们通过类的形式组织函数和变量，使之不能脱离对象存在。但这里函数本身是一个过程，只是依附在某个类上。</p>
<p>然而，面 向对象仅仅是一个概念或者编程思想而已，它不应该依赖于某个语言存在。比如 Java 采用面向对象思想构造其语言，它实现了类、继承、派生、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种手段，而非必须。换言之，一门语言可 以根据其自身特性选择合适的方式来实现面向对象。所以，由于大多数程序员首先学习或者使用的是类似 Java、C++ 等高级编译型语言（Java 虽然是半编译半解释，但一般做为编译型来讲解），因而先入为主地接受了“类”这个面向对象实现方式，从而在学习脚本语言的时候，习惯性地用类式面向对象语 言中的概念来判断该语言是否是面向对象语言，或者是否具备面向对象特性。这也是阻碍程序员深入学习并掌握 JavaScript 的重要原因之一。</p>
<p>实际上，JavaScript 语言是通过一种叫做 <strong>原型（**</strong>prototype<strong>**）</strong>的方式来实现面向对象编程的。下面就来讨论 <strong>基于类的（**</strong>class-based<strong>**）面向对象</strong>和 <strong>基于原型的 (**</strong>prototype-based<strong>**) 面向对象</strong>这两种方式在构造客观世界的方式上的差别。</p>
<h2 id="基于类的面向对象和基于原型的面向对象方式比较"><a href="#基于类的面向对象和基于原型的面向对象方式比较" class="headerlink" title="基于类的面向对象和基于原型的面向对象方式比较"></a>基于类的面向对象和基于原型的面向对象方式比较</h2><p>在基于类的面向对象方式中，<strong>对象（**</strong>object<strong>**）</strong>依靠 <strong>类（**</strong>class<strong>**）</strong>来产生。而在基于原型的面向对象方式中，<strong>对象（**</strong>object<strong>**）</strong>则是依靠 <strong>构造器（**</strong>constructor<strong>**）</strong>利用 <strong>原型（**</strong>prototype<strong>**）</strong>构造出来的。举个客观世界的例子来说明二种方式认知的差异。例如工厂造一辆车，一方面，工人必须参照一张工程图纸，设计规定这辆车应该如何制造。这里的工程图纸就好比是语言中的 <strong>类 (**</strong>class<strong>**)</strong>，而车就是按照这个 <strong>类（**</strong>class<strong>**）</strong>制造出来的；另一方面，工人和机器 ( 相当于 constructor) 利用各种零部件如发动机，轮胎，方向盘 ( 相当于 prototype 的各个属性 ) 将汽车构造出来。</p>
<p>事实上关于这两种方式谁更为彻底地表达了面向对象的思想，目前尚有争论。但笔者认为原型式面向对象是一种更为彻底的面向对象方式，理由如下：</p>
<p>首先，客观世界中的对象的产生都是其它实物对象构造的结果，而抽象的“图纸”是不能产生“汽车”的，也就是说，类是一个抽象概念而并非实体，而对象的产生是一个实体的产生；</p>
<p>其次，按照一切事物皆对象这个最基本的面向对象的法则来看，类 (class) 本身并不是一个对象，然而原型方式中的构造器 (constructor) 和原型 (prototype) 本身也是其他对象通过原型方式构造出来的对象。</p>
<p>再 次，在类式面向对象语言中，对象的状态 (state) 由对象实例 (instance) 所持有，对象的行为方法 (method) 则由声明该对象的类所持有，并且只有对象的结构和方法能够被继承；而在原型式面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承（<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources" target="_blank" rel="noopener">参考资源</a>），这也更贴近客观实际。</p>
<p>最 后，类式面向对象语言比如 Java，为了弥补无法使用面向过程语言中全局函数和变量的不便，允许在类中声明静态 (static) 属性和静态方法。而实际上，客观世界不存在所谓静态概念，因为一切事物皆对象！而在原型式面向对象语言中，除内建对象 (build-in object) 外，不允许全局对象、方法或者属性的存在，也没有静态概念。所有语言元素 (primitive) 必须依赖对象存在。但由于函数式语言的特点，语言元素所依赖的对象是随着运行时 (runtime) 上下文 (context) 变化而变化的，具体体现在 this 指针的变化。正是这种特点更贴近 “万物皆有所属，宇宙乃万物生存之根本”的自然观点。在 <a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing1" target="_blank" rel="noopener">程序清单 1</a>中 <strong>window</strong> 便类似与宇宙的概念。</p>
<h5 id="清单-1-对象的上下文依赖"><a href="#清单-1-对象的上下文依赖" class="headerlink" title="清单 1. 对象的上下文依赖"></a>清单 1. 对象的上下文依赖</h5><div class="codesection"><br><br> <script><br>     var str = “我是一个 String 对象 , 我声明在这里 , 但我不是独立存在的！”<br>     var obj = { des: “我是一个 Object 对象 , 我声明在这里，我也不是独立存在的。” };<br>     var fun = function() {<br>        console.log( “我是一个 Function 对象！谁调用我，我属于谁：”, this );<br>     };<br><br>     obj.fun = fun;<br><br>     console.log( this === window );     // 打印 true<br>     console.log( window.str === str );  // 打印 true<br>     console.log( window.obj === obj );  // 打印 true<br>     console.log( window.fun === fun );  // 打印 true<br>     fun();                              // 打印 我是一个 Function 对象！谁调用我，我属于谁：window<br>     obj.fun();                          // 打印 我是一个 Function 对象！谁调用我，我属于谁：obj<br>     fun.apply(str);                   // 打印 我是一个 Function 对象！谁调用我，我属于谁：str<br>     </script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在接受了面向对象存在一种叫做基于原型实现的方式的事实之后，下面我们就可以来深入探讨 ECMAScript 是如何依据这一方式构造自己的语言的。</span><br><span class="line"></span><br><span class="line">    ## 最基本的面向对象</span><br><span class="line"></span><br><span class="line">*ECMAScript* 是一门彻底的面向对象的编程语言（[参考资源](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources)），JavaScript 是其中的一个变种 (variant)。它提供了 6 种基本数据类型，即 Boolean、Number、String、Null、Undefined、Object。为了实现面向对象，*ECMAScript*设计出了一种非常成功的数据结构 - JSON(JavaScript Object Notation), 这一经典结构已经可以脱离语言而成为一种广泛应用的数据交互格式 （[参考资源](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources)）。</span><br><span class="line"></span><br><span class="line">应该说，具有基本数据类型和 JSON 构造语法的 ECMAScript 已经基本可以实现面向对象的编程了。开发者可以随意地用 **字面式声明（****literal notation****）**方式来构造一个对象，并对其不存在的属性直接赋值，或者用 delete 将属性删除 ( 注：JS 中的 delete 关键字用于删除对象属性，经常被误作为 C++ 中的 delete，而后者是用于释放不再使用的对象 )，如 [程序清单 2](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing2)。</span><br><span class="line"></span><br><span class="line">    ##### 清单 2. 字面式 (literal notation) 对象声明</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;codesection&quot;&gt;</span><br><span class="line">    &lt;pre class=&quot;displaycode&quot;&gt; var person = &#123; </span><br><span class="line">        name: “张三”, </span><br><span class="line">        age: 26, </span><br><span class="line">        gender: “男”, </span><br><span class="line">        eat: function( stuff ) &#123; </span><br><span class="line">            alert( “我在吃” + stuff ); </span><br><span class="line">        &#125; </span><br><span class="line">     &#125;; </span><br><span class="line">     person.height = 176; </span><br><span class="line">     delete person[ “age” ];</span><br></pre></td></tr></table></figure><br><br>在实际开发过程中，大部分初学者或者对 JS 应用没有太高要求的开发者也基本上只用到 ECMAScript 定义的这一部分内容，就能满足基本的开发需求。然而，这样的代码复用性非常弱，与其他实现了继承、派生、多态等等的类式面向对象的强类型语言比较起来显得 有些干瘪，不能满足复杂的 JS 应用开发。所以 ECMAScript 引入原型来解决对象继承问题。<br><br>    ## 使用函数构造器构造对象<br><br>除了 <strong>字面式声明（**</strong>literal notation<strong>**）</strong>方式之外，ECMAScript 允许通过 <strong>构造器（constructor）</strong>创建对象。每个构造器实际上是一个 <strong>函数（**</strong>function<strong>**） 对象</strong>, 该函数对象含有一个“prototype”属性用于实现 <strong>基于原型的继承**</strong>（<strong><strong>prototype-based inheritance</strong></strong>）<strong>和 </strong>共享属性（<strong><strong>shared properties</strong></strong>）<strong>*</strong>。<strong>*对象可以由“new 关键字 + 构造器调用”的方式来创建，如 <a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing3" target="_blank" rel="noopener">程序清单 3</a>：<br><br>    ##### 清单 3. 使用构造器 (constructor) 创建对象<br><br>    <div class="codesection"><br>    <pre class="displaycode"> // 构造器 Person 本身是一个函数对象<br>     function Person() {<br>         // 此处可做一些初始化工作<br>     }<br>     // 它有一个名叫 prototype 的属性<br>     Person.prototype = {<br>        name: “张三”,<br>        age: 26,<br>        gender: “男”,<br>        eat: function( stuff ) {<br>            alert( “我在吃” + stuff );<br>        }<br>     }<br>     // 使用 new 关键字构造对象<br>     var p = new Person();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于早期 JavaScript 的发明者为了使这门语言与大名鼎鼎的 Java 拉上关系 ( 虽然现在大家知道二者是雷锋和雷锋塔的关系 )，使用了 **new** 关键字来限定构造器调用并创建对象，以使其在语法上跟 Java 创建对象的方式看上去类似。但需要指出的是，这两门语言的 **new**含 义毫无关系，因为其对象构造的机理完全不同。也正是因为这里语法上的类似，众多习惯了类式面向对象语言中对象创建方式的程序员，难以透彻理解 JS 对象原型构造的方式，因为他们总是不明白在 JS 语言中，为什么“函数名可以作为类名”的现象。而实质上，JS 这里仅仅是借用了关键字 new，仅此而已；换句话说，ECMAScript 完全可以用其它 **非****new** 表达式来用调用构造器创建对象。</span><br><span class="line"></span><br><span class="line">    ## 彻底理解原型链 (prototype chain)</span><br><span class="line"></span><br><span class="line">在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 **隐式引用（****implicit reference****）**，这个引用称之为 **原型（****prototype****）**。进一步，每个原型可以拥有指向自己原型的 **隐式引用**（即该原型的原型），如此下去，这就是所谓的 **原型链（****prototype chain****）** （[参考资源](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources)）。在具体的语言实现中，每个对象都有一个 **__proto__ 属性**来实现对原型的 **隐式引用**。[程序清单 4](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing4)说明了这一点。</span><br><span class="line"></span><br><span class="line">    ##### 清单 4. 对象的 __proto__ 属性和隐式引用</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;codesection&quot;&gt;</span><br><span class="line">    &lt;pre class=&quot;displaycode&quot;&gt; function Person( name ) &#123; </span><br><span class="line">        this.name = name; </span><br><span class="line">     &#125; </span><br><span class="line">     var p = new Person(); </span><br><span class="line">     // 对象的隐式引用指向了构造器的 prototype 属性，所以此处打印 true </span><br><span class="line">     console.log( p.__proto__ === Person.prototype ); </span><br><span class="line"></span><br><span class="line">     // 原型本身是一个 Object 对象，所以他的隐式引用指向了</span><br><span class="line">     // Object 构造器的 prototype 属性 , 故而打印 true </span><br><span class="line">     console.log( Person.prototype.__proto__ === Object.prototype ); </span><br><span class="line"></span><br><span class="line">     // 构造器 Person 本身是一个函数对象，所以此处打印 true </span><br><span class="line">     console.log( Person.__proto__ === Function.prototype );</span><br></pre></td></tr></table></figure><br><br>有了 </pre></div></strong>原型链<strong>，便可以定义一种所谓的 </strong>属性隐藏机制*<em>， 并通过这种机制实现继承。ECMAScript 规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的 原型链中的第一个对象是该对象本身）进行赋值。反之，如果要获取某个对象属性的值，解释器自然是返回该对象原型链中首先具有该属性的对象属性值。<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#fig1" target="_blank" rel="noopener">图 1</a>说名了这中隐藏机制：<br><br>    ##### 图 1. 原型链中的属性隐藏机制<br><br><img src="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/image001.png" alt="图 1. 原型链中的属性隐藏机制"><br><br>在 图 1 中，object1-&gt;prototype1-&gt;prototype2 构成了 对象 object1 的原型链，根据上述属性隐藏机制，可以清楚地看到 prototype1 对象中的 property4 属性和 prototype2 对象中的 property3 属性皆被隐藏。理解了原型链，那么将非常容易理解 JS 中基于原型的继承实现原理，<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing5" target="_blank" rel="noopener">程序清单 5</a> 是利用原型链实现继承的简单例子。<br><br>    ##### 清单 5. 利用原型链 Horse-&gt;Mammal-&gt;Animal 实现继承<br><br>    <div class="codesection"><br>    <pre class="displaycode"> // 声明 Animal 对象构造器<br>     function Animal() {<br>     }<br>     // 将 Animal 的 prototype 属性指向一个对象，<br>     // 亦可直接理解为指定 Animal 对象的原型<br>     Animal.prototype = {<br>        name: animal”,<br>        weight: 0,<br>        eat: function() {<br>            alert( “Animal is eating!” );<br>        }<br>     }<br>     // 声明 Mammal 对象构造器<br>     function Mammal() {<br>        this.name = “mammal”;<br>     }<br>     // 指定 Mammal 对象的原型为一个 Animal 对象。<br>     // 实际上此处便是在创建 Mammal 对象和 Animal 对象之间的原型链<br>     Mammal.prototype = new Animal();<br><br>     // 声明 Horse 对象构造器<br>     function Horse( height, weight ) {<br>        this.name = “horse”;<br>        this.height = height;<br>        this.weight = weight;<br>     }<br>     // 将 Horse 对象的原型指定为一个 Mamal 对象，继续构建 Horse 与 Mammal 之间的原型链<br>     Horse.prototype = new Mammal();<br><br>     // 重新指定 eat 方法 , 此方法将覆盖从 Animal 原型继承过来的 eat 方法<br>     Horse.prototype.eat = function() {<br>        alert( “Horse is eating grass!” );<br>     }<br>     // 验证并理解原型链<br>     var horse = new Horse( 100, 300 );<br>     console.log( horse.<strong>proto</strong> === Horse.prototype );<br>     console.log( Horse.prototype.<strong>proto</strong> === Mammal.prototype );<br>     console.log( Mammal.prototype.<strong>proto</strong> === Animal.prototype );<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[理解清单 5](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing5) 中对象原型继承逻辑实现的关键在于 Horse.prototype = new Mammal() 和 Mammal.prototype = new Animal() 这两句代码。首先，等式右边的结果是构造出一个临时对象，然后将这个对象赋值给等式左边对象的 prototype 属性。也就是说将右边新建的对象作为左边对象的原型。读者可以将这两个等式替换到相应的程序清单 5 代码最后两行的等式中自行领悟。</span><br><span class="line"></span><br><span class="line">    ## JavaScript 类式继承的实现方法</span><br><span class="line"></span><br><span class="line">从 代码清单 5 可以看出，基于原型的继承方式，虽然实现了代码复用，但其行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效地组织管理。不得不承认，类 式继承方式在语言实现上更具健壮性，且在构建可复用代码和组织架构程序方面具有明显的优势。这使得程序员们希望寻找到一种能够在 JavaScript 中以类式继承风格进行编码的方法途径。从抽象的角度来讲，既然类式继承和原型继承都是为实现面向对象而设计的，并且他们各自实现的载体语言在计算能力上是 等价的 ( 因为图灵机的计算能力与 Lambda 演算的计算能力是等价的 )，那么能不能找到一种变换，使得原型式继承语言通过该变换实现具有类式继承编码的风格呢？</span><br><span class="line"></span><br><span class="line">目前一些主流的 JS 框架都提供了这种转换机制，也即类式声明方法，比如 Dojo.declare()、Ext.entend() 等等。用户使用这些框架，可以轻易而友好地组织自己的 JS 代码。其实，在众多框架出现之前，JavaScript 大师 *Douglas Crockford* 最早利用三个函数对 Function 对象进行扩展，实现了这种变换，关于它的实现细节可以（[参考资源](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources)）。此外还有由 *Dean Edwards*实现的著名的 Base.js（[参考资源](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources)）。值得一提的是，jQuery 之父 *John Resig* 在搏众家之长之后，用不到 30 行代码便实现了自己的 **Simple Inheritance**。使用其提供的 extend 方法声明类非常简单。[程序清单 6](http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing6)是使用了 **Simple Inheritance**库实现类的声明的例子。其中最后一句打印输出语句是对 **Simple Inheritance**实现类式继承的最好说明。</span><br><span class="line"></span><br><span class="line">    ##### 清单 6. 使用 Simple Inheritance 实现类式继承</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;codesection&quot;&gt;</span><br><span class="line">    &lt;pre class=&quot;displaycode&quot;&gt; // 声明 Person 类</span><br><span class="line">     var Person = Class.extend( &#123; </span><br><span class="line">        _issleeping: true, </span><br><span class="line">        init: function( name ) &#123; </span><br><span class="line">            this._name = name; </span><br><span class="line">        &#125;, </span><br><span class="line">        isSleeping: function() &#123; </span><br><span class="line">            return this._issleeping; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; ); </span><br><span class="line">     // 声明 Programmer 类，并继承 Person </span><br><span class="line">     var Programmer = Person.extend( &#123; </span><br><span class="line">        init: function( name, issleeping ) &#123; </span><br><span class="line">            // 调用父类构造函数</span><br><span class="line">            this._super( name ); </span><br><span class="line">            // 设置自己的状态</span><br><span class="line">            this._issleeping = issleeping; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; ); </span><br><span class="line">     var person = new Person( &quot;张三&quot; ); </span><br><span class="line">     var diors = new Programmer( &quot;张江男&quot;, false ); </span><br><span class="line">     // 打印 true </span><br><span class="line">     console.log( person.isSleeping() ); </span><br><span class="line">     // 打印 false </span><br><span class="line">     console.log( diors.isSleeping() ); </span><br><span class="line">     // 此处全为 true，故打印 true </span><br><span class="line">     console.log( person instanceof Person &amp;&amp; person instanceof Class </span><br><span class="line">        &amp;&amp; diors instanceof Programmer &amp;&amp; </span><br><span class="line">        diors instanceof Person &amp;&amp; diors instanceof Class );</span><br></pre></td></tr></table></figure><br><br>如果您已对原型、函数构造器、闭包和基于上下文的 this 有了充分的理解，那么理解 Simple Inheritance 的实现原理也并非相当困难。从本质上讲，</pre></div></em>var Person = Class.extend(…)<em>该 语句中，左边的 Person 实际上是获得了由 Class 调用 extend 方法返回的一个构造器，也即一个 function 对象的引用。顺着这个思路，我们继续介绍 Simple Inheritance 是如何做到这一点，进而实现了由原型继承方式到类式继承方式的转换的。<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#fig2" target="_blank" rel="noopener">图 2</a> 是 Simple Inheritance 的源码及其附带注释。为了方便理解，用中文对代码逐行补充说明。<br><br>    ##### 图 2.Simple Inheritance 源码解析<br><br><img src="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/image003.png" alt="图 2.Simple Inheritance 源码解析"><br><br>抛开代码第二部分，整体连贯地考察第一和第三部分会发现，extend 函数的根本目的就是要构造一个具有新原型属性的新构造器。我们不禁感叹 </em>John Resig<em>的大师手笔及其对 JS 语言本质把握的细腻程度。至于 </em>John Resig<em>是如何想到这样精妙的实现方法，感兴趣的读者可以阅读本文 （<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources" target="_blank" rel="noopener">参考资源</a>），其中有详细介绍关于最初设计 Simple Inheritance 的思维过程。<br><br>    ## JavaScript 私有成员实现<br><br>到 此为止，如果您任然对 JavaScript 面向对象持怀疑态度，那么这个怀疑一定是，JavaScript 没有实现面向对象中的信息隐藏，即私有和公有。与其他类式面向对象那样显式地声明私有公有成员的方式不同，JavaScript 的信息隐藏就是靠闭包实现的。见 <a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#listing7" target="_blank" rel="noopener">程序清单 7</a>:<br><br>    ##### 清单 7. 使用闭包实现信息隐藏<br><br>    <div class="codesection"><br>    <pre class="displaycode"> // 声明 User 构造器<br>     function User( pwd ) {<br>        // 定义私有属性<br>        var password = pwd;<br>        // 定义私有方法<br>        function getPassword() {<br>            // 返回了闭包中的 password<br>            return password;<br>        }<br>        // 特权函数声明，用于该对象其他公有方法能通过该特权方法访问到私有成员<br>        this.passwordService = function() {<br>            return getPassword();<br>        }<br>     }<br>     // 公有成员声明<br>     User.prototype.checkPassword = function( pwd ) {<br>        return this.passwordService() === pwd;<br>     };<br>     // 验证隐藏性<br>     var u = new User( “123456” );<br>     // 打印 true<br>     console.log( u.checkPassword( “123456” ) );<br>     // 打印 undefined<br>     console.log( u.password );<br>     // 打印 true<br>     console.log( typeof u.gePassword === “undefined” );<code>`</code><br><br>JavaScript 必须依赖闭包实现信息隐藏，是由其函数式语言特性所决定的。本文不会对函数式语言和闭包这两个话题展开讨论，正如上文默认您理解 JavaScript 中基于上下文的 this 一样。关于 JavaScript 中实现信息隐藏，</pre></div></em>Douglas Crockford*在《 Private members in JavaScript 》（<a href="http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/#resources" target="_blank" rel="noopener">参考资源</a>）一文中有更权威和详细的介绍。<br><br>    ## 结束语<br><br>JavaScript 被认为是世界上最受误解的编程语言，因为它身披 c 语言家族的外衣，表现的却是 LISP 风格的函数式语言特性；没有类，却实也彻底实现了面向对象。要对这门语言有透彻的理解，就必须扒开其 c 语言的外衣，从新回到函数式编程的角度，同时摒弃原有类的面向对象概念去学习领悟它。随着近些年来 Web 应用的普及和 JS 语言自身的长足发展，特别是后台 JS 引擎的出现 ( 如基于 V8 的 NodeJS 等 )，可以预见，原来只是作为玩具编写页面效果的 JS 将获得更广阔发展天地。这样的发展趋势，也对 JS 程序员提出了更高要求。只有彻底领悟了这门语言，才有可能在大型的 JS 项目中发挥她的威力。<br></div><br>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>感谢支持原创技术分享</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/repo/wechatpay.png" alt="庞国明 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/repo/alipay.jpg" alt="庞国明 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/blog/tags/面向对象/" rel="tag"># 面向对象</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2014/10/15/JAVA智能设备基于OpenGL的3D开发技术 之AABB碰撞检测算法论述/" rel="prev" title="JAVA智能设备基于OpenGL的3D开发技术 之AABB碰撞检测算法论述">
                JAVA智能设备基于OpenGL的3D开发技术 之AABB碰撞检测算法论述 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  <div onclick="showGitment()" id="gitment_title" class="gitment_title">显示 Gitment 评论</div>
  <div id="container" style="display:none"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  const myTheme = {
    render(state, instance) {
      const container = document.createElement('div');
      container.lang = "en-US";
      container.className = 'gitment-container gitment-root-container';
      container.appendChild(instance.renderHeader(state, instance));
      container.appendChild(instance.renderEditor(state, instance));
      container.appendChild(instance.renderComments(state, instance));
      container.appendChild(instance.renderFooter(state, instance));
      return container;
    }
  }
  function showGitment() {
    $("#gitment_title").attr("style", "display:none");
    $("#container").attr("style", "").addClass("gitment_container");
    var gitment = new Gitment({
      id: window.location.pathname,
      theme: myTheme,
      owner: 'pangguoming',
      repo: 'pangguoming.github.io',
      oauth: {
        client_id: '1e9770fed2b4d227cd0a',
        client_secret: '51f66abac54ca9e1b5a5608d706ce6af47ffaa51'
      }
    });
    gitment.render('container');
  }
  </script>

  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/7269202?s=460&v=4" alt="庞国明">
          
            <p class="site-author-name" itemprop="name">庞国明</p>
            <p class="site-description motion-element" itemprop="description">Software make the information world run, and programer make the softeware run.</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/blog/archives">
            
                <span class="site-state-item-count">396</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/blog/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/blog/tags/index.html">
                <span class="site-state-item-count">260</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/pangguoming" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:pangguoming@yeah.net" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/pangguoming" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>Twitter</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://stackoverflow.com/users/1570700/pangguoming" target="_blank" title="StackOverflow">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://instagram.com/pangguoming" target="_blank" title="Instagram">
                  
                    <i class="fa fa-fw fa-instagram"></i>Instagram</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重新认识面向对象"><span class="nav-number">2.</span> <span class="nav-text">重新认识面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于类的面向对象和基于原型的面向对象方式比较"><span class="nav-number">3.</span> <span class="nav-text">基于类的面向对象和基于原型的面向对象方式比较</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#清单-1-对象的上下文依赖"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">清单 1. 对象的上下文依赖</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">庞国明</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/blog/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/blog/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
